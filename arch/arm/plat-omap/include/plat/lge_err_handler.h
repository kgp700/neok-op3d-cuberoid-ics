#ifndef __ARCH_ARM_PLAT_OMAP_ERR_HANDLER_H#define __ARCH_ARM_PLAT_OMAP_ERR_HANDLER_Htypedef enum{	 LGE_NVDATA_IQ_RESET_CAUSE_UNKNOWN = 0	,LGE_NVDATA_IQ_RESET_WATCHDOG_EXPIRED	,LGE_NVDATA_IQ_RESET_EXCEPTION 			 	,LGE_NVDATA_IQ_POOL_EXTENSION_FAILED		 	,LGE_NVDATA_IQ_BUFFER_TOO_LARGE			 	,LGE_NVDATA_IQ_CONCURRENT_TICK_CALL		 	,LGE_NVDATA_IQ_SUPERV_STACK_OVERFLOW		 	,LGE_NVDATA_IQ_INTERRUPT_STACK_OVERFLOW	 	,LGE_NVDATA_IQ_UNKNOWN_BREAKPOINT			 	,LGE_NVDATA_IQ_UNKNOWN_INTERRUPT			 	,LGE_NVDATA_IQ_START_STACK_OVERFLOW		 	,LGE_NVDATA_IQ_UNRECOGNIZED_CPU			 	,LGE_NVDATA_IQ_INCOMPATIBLE_CPU_HAL		 	,LGE_NVDATA_IQ_UNEXPECTED_EXCEPTION		 	,LGE_NVDATA_IQ_PRIORITY_ERROR				 	,LGE_NVDATA_IQ_UNEXPECTED_EXCEPTION_REGDUMP 	,LGE_NVDATA_IQ_EARLY_ERROR 				 	,LGE_NVDATA_IQ_SYSCALL_TOO_EARLY			 	,LGE_NVDATA_IQ_INCOMPATIBLE_CONFIGURATION	 	,LGE_NVDATA_IQ_NO_BUFFER_END_MARK			 	,LGE_NVDATA_IQ_TOO_MANY_ATTACHED			 	,LGE_NVDATA_IQ_RECURSIVE_ERROR 			 	,LGE_NVDATA_IQ_RECURSIVE_SYSERROR			 	,LGE_NVDATA_IQ_TOO_MANY_MUTEXES			 	,LGE_NVDATA_IQ_USER_STACK_OVERFLOW 		 	,LGE_NVDATA_IQ_FACTORY_DATA_RESET			 } lge_nvdata_iq_reset_cause_t;extern int 	lge_is_force_ap_crash();extern int  lge_is_crash_dump_enabled();extern int lge_is_ap_crash_dump_enabled();extern void lge_mark_ap_crash();extern void lge_mark_cp_crash();extern int  lge_is_mark_cp_crash();extern void lge_dump_ap_crash();extern void lge_user_reset();extern void lge_store_ciq_reset(int is_ap, int cause);#endif