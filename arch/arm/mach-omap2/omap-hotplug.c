#include <linux/kernel.h>#include <linux/errno.h>#include <linux/smp.h>#include <linux/completion.h>#include <asm/cacheflush.h>#include <mach/omap4-common.h>#include <mach/omap4-wakeupgen.h>#include <plat/powerdomain.h>#include <plat/clockdomain.h>static DECLARE_COMPLETION(cpu_killed);int platform_cpu_kill(unsigned int cpu){	int ret;	ret = wait_for_completion_timeout(&cpu_killed, 5000);	#if 0			pr_notice("CPU%u: shutdown\n", cpu);	#endif	return ret;}void platform_cpu_die(unsigned int cpu){	unsigned int this_cpu = hard_smp_processor_id();	struct clockdomain *cpu1_clkdm;	if (cpu != this_cpu) {		pr_crit("platform_cpu_die running on %u, should be %u\n",			   this_cpu, cpu);		BUG();	}	complete(&cpu_killed);	flush_cache_all();	wmb();	if (omap_modify_auxcoreboot0(0x0, 0x200) != 0x0)		pr_err("Secure clear status failed\n");	for (;;) {		omap4_wakeupgen_clear_all(cpu);#ifdef CONFIG_PM		omap4_enter_lowpower(cpu, PWRDM_POWER_OFF);#else		wmb();		do_wfi();#endif		if (omap_read_auxcoreboot0() == cpu) {			this_cpu = hard_smp_processor_id();			omap4_wakeupgen_set_all(this_cpu);			cpu1_clkdm = clkdm_lookup("mpu1_clkdm");			omap2_clkdm_allow_idle(cpu1_clkdm);			break;		}		pr_debug("CPU%u: spurious wakeup call\n", cpu);	}}int platform_cpu_disable(unsigned int cpu){	return cpu == 0 ? -EPERM : 0;}