#undef DEBUG#include <linux/kernel.h>#include <linux/errno.h>#include <linux/io.h>#include <linux/clk.h>#include <linux/delay.h>#include <linux/err.h>#include <linux/list.h>#include <linux/mutex.h>#include <plat/common.h>#include <plat/cpu.h>#include <plat/clockdomain.h>#include <plat/powerdomain.h>#include <plat/clock.h>#include <plat/omap_hwmod.h>#include <plat/prcm.h>#include "cm.h"#define MAX_MODULE_RESET_WAIT		10000#define MPU_INITIATOR_NAME		"mpu"static LIST_HEAD(omap_hwmod_list);#if 1static spinlock_t omap_hwmod_spinlock;unsigned long flags;#elsestatic DEFINE_MUTEX(omap_hwmod_mutex);#endifstatic struct omap_hwmod *mpu_oh;static u8 inited;static int _update_sysc_cache(struct omap_hwmod *oh){	if (!oh->class->sysc) {		WARN(1, "omap_hwmod: %s: cannot read OCP_SYSCONFIG: not defined on hwmod's class\n", oh->name);		return -EINVAL;	}	if (oh->class->sysc->sysc_flags & SYSC_READONLY)		return -EINVAL;	oh->_sysc_cache = omap_hwmod_readl(oh, oh->class->sysc->sysc_offs);	if (!(oh->class->sysc->sysc_flags & SYSC_NO_CACHE))		oh->_int_flags |= _HWMOD_SYSCONFIG_LOADED;	return 0;}static void _write_sysconfig(u32 v, struct omap_hwmod *oh){	if (!oh->class->sysc) {		WARN(1, "omap_hwmod: %s: cannot write OCP_SYSCONFIG: not defined on hwmod's class\n", oh->name);		return;	}	if (oh->class->sysc->sysc_flags & SYSC_READONLY)		return;	if ((oh->_sysc_cache != v) ||				(oh->_sysc_cache !=			 omap_hwmod_readl(oh, oh->class->sysc->sysc_offs))) {		oh->_sysc_cache = v;		omap_hwmod_writel(v, oh, oh->class->sysc->sysc_offs);	}}static int _set_master_standbymode(struct omap_hwmod *oh, u8 standbymode,				   u32 *v){	u32 mstandby_mask;	u8 mstandby_shift;	if (!oh->class->sysc ||	    !(oh->class->sysc->sysc_flags & SYSC_HAS_MIDLEMODE))		return -EINVAL;	if (!oh->class->sysc->sysc_fields) {		WARN(1, "omap_hwmod: %s: offset struct for sysconfig not provided in class\n", oh->name);		return -EINVAL;	}	mstandby_shift = oh->class->sysc->sysc_fields->midle_shift;	mstandby_mask = (0x3 << mstandby_shift);	*v &= ~mstandby_mask;	*v |= __ffs(standbymode) << mstandby_shift;	return 0;}static int _set_slave_idlemode(struct omap_hwmod *oh, u8 idlemode, u32 *v){	u32 sidle_mask;	u8 sidle_shift;	if (!oh->class->sysc ||	    !(oh->class->sysc->sysc_flags & SYSC_HAS_SIDLEMODE))		return -EINVAL;	if (!oh->class->sysc->sysc_fields) {		WARN(1, "omap_hwmod: %s: offset struct for sysconfig not provided in class\n", oh->name);		return -EINVAL;	}	sidle_shift = oh->class->sysc->sysc_fields->sidle_shift;	sidle_mask = (0x3 << sidle_shift);	*v &= ~sidle_mask;	*v |= __ffs(idlemode) << sidle_shift;	return 0;}static int _set_clockactivity(struct omap_hwmod *oh, u8 clockact, u32 *v){	u32 clkact_mask;	u8  clkact_shift;	if (!oh->class->sysc ||	    !(oh->class->sysc->sysc_flags & SYSC_HAS_CLOCKACTIVITY))		return -EINVAL;	if (!oh->class->sysc->sysc_fields) {		WARN(1, "omap_hwmod: %s: offset struct for sysconfig not provided in class\n", oh->name);		return -EINVAL;	}	clkact_shift = oh->class->sysc->sysc_fields->clkact_shift;	clkact_mask = (0x3 << clkact_shift);	*v &= ~clkact_mask;	*v |= clockact << clkact_shift;	return 0;}static int _set_softreset(struct omap_hwmod *oh, u32 *v){	u32 softrst_mask;	if (!oh->class->sysc ||	    !(oh->class->sysc->sysc_flags & SYSC_HAS_SOFTRESET))		return -EINVAL;	if (!oh->class->sysc->sysc_fields) {		WARN(1, "omap_hwmod: %s: offset struct for sysconfig not provided in class\n", oh->name);		return -EINVAL;	}	softrst_mask = (0x1 << oh->class->sysc->sysc_fields->srst_shift);	*v |= softrst_mask;	return 0;}static int _set_module_autoidle(struct omap_hwmod *oh, u8 autoidle,				u32 *v){	u32 autoidle_mask;	u8 autoidle_shift;	if (!oh->class->sysc ||	    !(oh->class->sysc->sysc_flags & SYSC_HAS_AUTOIDLE))		return -EINVAL;	if (!oh->class->sysc->sysc_fields) {		WARN(1, "omap_hwmod: %s: offset struct for sysconfig not provided in class\n", oh->name);		return -EINVAL;	}	autoidle_shift = oh->class->sysc->sysc_fields->autoidle_shift;	autoidle_mask = (0x3 << autoidle_shift);	*v &= ~autoidle_mask;	*v |= autoidle << autoidle_shift;	return 0;}static int _set_enawakeup(struct omap_hwmod *oh, u8 enawakeup, u32 *v){	u32 wakeup_mask;	u8 wakeup_shift;	if (!oh->class->sysc ||	    !(oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP))		return -EINVAL;	if (!oh->class->sysc->sysc_fields) {		WARN(1, "omap_hwmod: %s: offset struct for sysconfig not provided in class\n", oh->name);		return -EINVAL;	}	wakeup_shift = oh->class->sysc->sysc_fields->enwkup_shift;	wakeup_mask = 0x1 << wakeup_shift;	*v &= ~wakeup_mask;	*v |= enawakeup << wakeup_shift;	return 0;}static int _enable_wakeup(struct omap_hwmod *oh){	u32 v;	if (!oh->class->sysc)		return -EINVAL;	if (!(oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP) ||		(oh->class->sysc->idlemodes & SIDLE_SMART_WKUP) ||		(oh->class->sysc->idlemodes & MSTANDBY_SMART_WKUP))		return -EINVAL;	if (!oh->class->sysc->sysc_fields) {		WARN(1, "omap_hwmod: %s: offset struct for sysconfig not provided in class\n", oh->name);		return -EINVAL;	}	v = oh->_sysc_cache;	if (oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP)		_set_enawakeup(oh, 1, &v);	if (oh->class->sysc->idlemodes & SIDLE_SMART_WKUP)		_set_slave_idlemode(oh, HWMOD_IDLEMODE_SMART_WKUP, &v);	if (oh->class->sysc->idlemodes & MSTANDBY_SMART_WKUP)		_set_master_standbymode(oh, HWMOD_IDLEMODE_SMART_WKUP, &v);	_write_sysconfig(v, oh);	oh->_int_flags |= _HWMOD_WAKEUP_ENABLED;	return 0;}static int _disable_wakeup(struct omap_hwmod *oh){	u32 v;	if (!oh->class->sysc)		return -EINVAL;	if (!(oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP) ||		(oh->class->sysc->idlemodes & SIDLE_SMART_WKUP) ||		(oh->class->sysc->idlemodes & MSTANDBY_SMART_WKUP))		return -EINVAL;	if (!oh->class->sysc->sysc_fields) {		WARN(1, "omap_hwmod: %s: offset struct for sysconfig not provided in class\n", oh->name);		return -EINVAL;	}	v = oh->_sysc_cache;	if (oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP)		_set_enawakeup(oh, 0, &v);	if (oh->class->sysc->idlemodes & SIDLE_SMART_WKUP)		_set_slave_idlemode(oh, HWMOD_IDLEMODE_SMART, &v);	if (oh->class->sysc->idlemodes & MSTANDBY_SMART_WKUP)		_set_master_standbymode(oh, HWMOD_IDLEMODE_SMART_WKUP, &v);	_write_sysconfig(v, oh);	oh->_int_flags &= ~_HWMOD_WAKEUP_ENABLED;	return 0;}static int _add_initiator_dep(struct omap_hwmod *oh, struct omap_hwmod *init_oh){	if (!oh->_clk)		return -EINVAL;	return clkdm_add_sleepdep(oh->_clk->clkdm, init_oh->_clk->clkdm);}static int _del_initiator_dep(struct omap_hwmod *oh, struct omap_hwmod *init_oh){	if (!oh->_clk)		return -EINVAL;	return clkdm_del_sleepdep(oh->_clk->clkdm, init_oh->_clk->clkdm);}static int _init_main_clk(struct omap_hwmod *oh){	int ret = 0;	if (!oh->main_clk)		return 0;	oh->_clk = omap_clk_get_by_name(oh->main_clk);	if (!oh->_clk) {		pr_warning("omap_hwmod: %s: cannot clk_get main_clk %s\n",			   oh->name, oh->main_clk);		return -EINVAL;	}	if (!oh->_clk->clkdm)		pr_warning("omap_hwmod: %s: missing clockdomain for %s.\n",			   oh->main_clk, oh->_clk->name);	return ret;}static int _init_interface_clks(struct omap_hwmod *oh){	struct clk *c;	int i;	int ret = 0;	if (oh->slaves_cnt == 0)		return 0;	for (i = 0; i < oh->slaves_cnt; i++) {		struct omap_hwmod_ocp_if *os = oh->slaves[i];		if (!os->clk)			continue;		c = omap_clk_get_by_name(os->clk);		if (!c) {			pr_warning("omap_hwmod: %s: cannot clk_get interface_clk %s\n",				   oh->name, os->clk);			ret = -EINVAL;		}		os->_clk = c;	}	return ret;}static int _init_opt_clks(struct omap_hwmod *oh){	struct omap_hwmod_opt_clk *oc;	struct clk *c;	int i;	int ret = 0;	for (i = oh->opt_clks_cnt, oc = oh->opt_clks; i > 0; i--, oc++) {		c = omap_clk_get_by_name(oc->clk);		if (!c) {			pr_warning("omap_hwmod: %s: cannot clk_get opt_clk %s\n",				   oh->name, oc->clk);			ret = -EINVAL;		}		oc->_clk = c;	}	return ret;}static int _enable_clocks(struct omap_hwmod *oh){	int i;	pr_debug("omap_hwmod: %s: enabling clocks\n", oh->name);	if (oh->_clk)		clk_enable(oh->_clk);	if (oh->slaves_cnt > 0) {		for (i = 0; i < oh->slaves_cnt; i++) {			struct omap_hwmod_ocp_if *os = oh->slaves[i];			struct clk *c = os->_clk;			if (c && (os->flags & OCPIF_SWSUP_IDLE))				clk_enable(c);		}	}	return 0;}static int _disable_clocks(struct omap_hwmod *oh){	int i;	pr_debug("omap_hwmod: %s: disabling clocks\n", oh->name);	if (oh->_clk)		clk_disable(oh->_clk);	if (oh->slaves_cnt > 0) {		for (i = 0; i < oh->slaves_cnt; i++) {			struct omap_hwmod_ocp_if *os = oh->slaves[i];			struct clk *c = os->_clk;			if (c && (os->flags & OCPIF_SWSUP_IDLE))				clk_disable(c);		}	}	return 0;}static void _enable_optional_clocks(struct omap_hwmod *oh){	struct omap_hwmod_opt_clk *oc;	int i;	pr_warning("omap_hwmod: %s: enabling optional clocks\n", oh->name);	for (i = oh->opt_clks_cnt, oc = oh->opt_clks; i > 0; i--, oc++)		if (oc->_clk) {			pr_warning("omap_hwmod: enable %s:%s\n", oc->role,				   oc->_clk->name);			clk_enable(oc->_clk);		}}static void _disable_optional_clocks(struct omap_hwmod *oh){	struct omap_hwmod_opt_clk *oc;	int i;	pr_warning("omap_hwmod: %s: disabling optional clocks\n", oh->name);	for (i = oh->opt_clks_cnt, oc = oh->opt_clks; i > 0; i--, oc++)		if (oc->_clk) {			pr_warning("omap_hwmod: disable %s:%s\n", oc->role,				   oc->_clk->name);			clk_disable(oc->_clk);		}}static int _find_mpu_port_index(struct omap_hwmod *oh){	int i;	int found = 0;	if (!oh || oh->slaves_cnt == 0)		return -EINVAL;	for (i = 0; i < oh->slaves_cnt; i++) {		struct omap_hwmod_ocp_if *os = oh->slaves[i];		if (os->user & OCP_USER_MPU) {			found = 1;			break;		}	}	if (found)		pr_debug("omap_hwmod: %s: MPU OCP slave port ID  %d\n",			 oh->name, i);	else		pr_debug("omap_hwmod: %s: no MPU OCP slave port found\n",			 oh->name);	return (found) ? i : -EINVAL;}static void __iomem *_find_mpu_rt_base(struct omap_hwmod *oh, u8 index){	struct omap_hwmod_ocp_if *os;	struct omap_hwmod_addr_space *mem;	int i;	int found = 0;	void __iomem *va_start;	if (!oh || oh->slaves_cnt == 0)		return NULL;	os = oh->slaves[index];	for (i = 0, mem = os->addr; i < os->addr_cnt; i++, mem++) {		if (mem->flags & ADDR_TYPE_RT) {			found = 1;			break;		}	}	if (found) {		va_start = ioremap(mem->pa_start, mem->pa_end - mem->pa_start);		if (!va_start) {			pr_err("omap_hwmod: %s: Could not ioremap\n", oh->name);			return NULL;		}		pr_debug("omap_hwmod: %s: MPU register target at va %p\n",			 oh->name, va_start);	} else {		pr_debug("omap_hwmod: %s: no MPU register target found\n",			 oh->name);	}	return (found) ? va_start : NULL;}static void _sysc_enable(struct omap_hwmod *oh){	u8 s_idlemode = 0, m_idlemode = 0, a_idlemode = 0, sf;	u8 idlemodes;	u32 v;	if (!oh->class->sysc)		return;	v = oh->_sysc_cache;	sf = oh->class->sysc->sysc_flags;	idlemodes = oh->class->sysc->idlemodes;	if (sf & SYSC_HAS_SIDLEMODE) {		if (oh->flags & HWMOD_SWSUP_SIDLE) {			s_idlemode = HWMOD_IDLEMODE_NO;		} else {			if (sf & SYSC_HAS_ENAWAKEUP)				_set_enawakeup(oh, 1, &v);			if (idlemodes & SIDLE_SMART_WKUP)				s_idlemode = HWMOD_IDLEMODE_SMART_WKUP;			else				s_idlemode = HWMOD_IDLEMODE_SMART;		}		_set_slave_idlemode(oh, s_idlemode, &v);	}	if (sf & SYSC_HAS_MIDLEMODE) {		if (oh->flags & HWMOD_SWSUP_MSTANDBY) {			m_idlemode = HWMOD_IDLEMODE_NO;		} else {			if (sf & SYSC_HAS_ENAWAKEUP)				_set_enawakeup(oh, 1, &v);			if (idlemodes & MSTANDBY_SMART_WKUP)				m_idlemode = HWMOD_IDLEMODE_SMART_WKUP;			else				m_idlemode = HWMOD_IDLEMODE_SMART;		}		_set_master_standbymode(oh, m_idlemode, &v);	}	if ((oh->flags & HWMOD_SET_DEFAULT_CLOCKACT) &&	    (sf & SYSC_HAS_CLOCKACTIVITY))		_set_clockactivity(oh, oh->class->sysc->clockact, &v);	_write_sysconfig(v, oh);	if (sf & SYSC_HAS_AUTOIDLE) {		a_idlemode = (oh->flags & HWMOD_NO_OCP_AUTOIDLE) ?			0 : 1;		_set_module_autoidle(oh, a_idlemode, &v);		_write_sysconfig(v, oh);	}}static void _sysc_idle(struct omap_hwmod *oh){		u8 idlemode, sf;	u8 idlemodes;	u32 v;	if (!oh->class->sysc)		return;	v = oh->_sysc_cache;	sf = oh->class->sysc->sysc_flags;	idlemodes = oh->class->sysc->idlemodes;	if (sf & SYSC_HAS_SIDLEMODE) {		if (oh->flags & HWMOD_SWSUP_SIDLE) {			idlemode = HWMOD_IDLEMODE_FORCE;		} else {			if (sf & SYSC_HAS_ENAWAKEUP)				_set_enawakeup(oh, 1, &v);			if (idlemodes & SIDLE_SMART_WKUP)				idlemode = HWMOD_IDLEMODE_SMART_WKUP;			else				idlemode = HWMOD_IDLEMODE_SMART;		}		_set_slave_idlemode(oh, idlemode, &v);	}	if (sf & SYSC_HAS_MIDLEMODE) {		if (oh->flags & HWMOD_SWSUP_MSTANDBY) {			idlemode = HWMOD_IDLEMODE_FORCE;		} else {			if (sf & SYSC_HAS_ENAWAKEUP)				_set_enawakeup(oh, 1, &v);			if (idlemodes & MSTANDBY_SMART_WKUP)				idlemode = HWMOD_IDLEMODE_SMART_WKUP;			else				idlemode = HWMOD_IDLEMODE_SMART;		}			_set_master_standbymode(oh, idlemode, &v);	}	_write_sysconfig(v, oh);}static void _sysc_shutdown(struct omap_hwmod *oh){	u32 v;	u8 sf;	if (!oh->class->sysc)		return;	v = oh->_sysc_cache;	sf = oh->class->sysc->sysc_flags;	if (sf & SYSC_HAS_SIDLEMODE)		_set_slave_idlemode(oh, HWMOD_IDLEMODE_FORCE, &v);	if (sf & SYSC_HAS_MIDLEMODE)		_set_master_standbymode(oh, HWMOD_IDLEMODE_FORCE, &v);	if (sf & SYSC_HAS_AUTOIDLE)		_set_module_autoidle(oh, 1, &v);	_write_sysconfig(v, oh);}static struct omap_hwmod *_lookup(const char *name){	struct omap_hwmod *oh, *temp_oh;	oh = NULL;	list_for_each_entry(temp_oh, &omap_hwmod_list, node) {		if (!strcmp(name, temp_oh->name)) {			oh = temp_oh;			break;		}	}	return oh;}static int _init_clocks(struct omap_hwmod *oh, void *data){	int ret = 0;	if (!oh || (oh->_state != _HWMOD_STATE_REGISTERED))		return -EINVAL;	pr_debug("omap_hwmod: %s: looking up clocks\n", oh->name);	ret |= _init_main_clk(oh);	ret |= _init_interface_clks(oh);	ret |= _init_opt_clks(oh);	if (!ret)		oh->_state = _HWMOD_STATE_CLKS_INITED;	return 0;}static int _wait_target_ready(struct omap_hwmod *oh){	struct omap_hwmod_ocp_if *os;	int ret;	if (!oh)		return -EINVAL;	if (oh->_int_flags & _HWMOD_NO_MPU_PORT)		return 0;	os = oh->slaves[oh->_mpu_port_index];	if (oh->flags & HWMOD_NO_IDLEST)		return 0;	if (cpu_is_omap24xx() || cpu_is_omap34xx()) {		ret = omap2_cm_wait_module_ready(oh->prcm.omap2.module_offs,						 oh->prcm.omap2.idlest_reg_id,						 oh->prcm.omap2.idlest_idle_bit);	} else if (cpu_is_omap44xx()) {		ret = omap4_cm_wait_module_ready(oh->prcm.omap4.clkctrl_reg);	} else {		BUG();	};	return ret;}static int _reset(struct omap_hwmod *oh){	u32 v;	int c = 0;	int ret = 0;	if (!oh->class->sysc ||	    !(oh->class->sysc->sysc_flags & SYSC_HAS_RESET_STATUS) ||	    !(oh->class->sysc->sysc_flags & SYSC_HAS_SOFTRESET))		return -EINVAL;	if (oh->_state != _HWMOD_STATE_ENABLED) {		pr_warning("omap_hwmod: %s: reset can only be entered from "			   "enabled state\n", oh->name);		return -EINVAL;	}	if (oh->flags & HWMOD_CONTROL_OPT_CLKS_IN_RESET)		_enable_optional_clocks(oh);	pr_warning("omap_hwmod: %s: resetting\n", oh->name);	v = oh->_sysc_cache;	ret = _set_softreset(oh, &v);	if (ret)		goto dis_opt_clks;	_write_sysconfig(v, oh);	if (oh->class->sysc->sysc_flags & SYSS_HAS_RESET_STATUS)		omap_test_timeout((omap_hwmod_readl(oh,						    oh->class->sysc->syss_offs)				   & SYSS_RESETDONE_MASK),				  MAX_MODULE_RESET_WAIT, c);	else if (oh->class->sysc->sysc_flags & SYSC_HAS_RESET_STATUS)		omap_test_timeout(!(omap_hwmod_readl(oh,						     oh->class->sysc->sysc_offs)				   & SYSC_TYPE2_SOFTRESET_MASK),				  MAX_MODULE_RESET_WAIT, c);	if (c == MAX_MODULE_RESET_WAIT)		pr_warning("omap_hwmod: %s: failed to reset in %d usec\n",			   oh->name, MAX_MODULE_RESET_WAIT);	else		pr_debug("omap_hwmod: %s: reset in %d usec\n", oh->name, c);	ret = (c == MAX_MODULE_RESET_WAIT) ? -ETIMEDOUT : 0;dis_opt_clks:	if (oh->flags & HWMOD_CONTROL_OPT_CLKS_IN_RESET)		_disable_optional_clocks(oh);	return ret;}int _omap_hwmod_enable(struct omap_hwmod *oh){	int r;	if (oh->_state != _HWMOD_STATE_INITIALIZED &&	    oh->_state != _HWMOD_STATE_IDLE &&	    oh->_state != _HWMOD_STATE_DISABLED) {		WARN(1, "omap_hwmod: %s: enabled state can only be entered "		     "from initialized, idle, or disabled state\n", oh->name);		return -EINVAL;	}	pr_debug("omap_hwmod: %s: enabling\n", oh->name);	if ((oh->_state == _HWMOD_STATE_INITIALIZED ||	     oh->_state == _HWMOD_STATE_DISABLED) && oh->rst_lines_cnt == 1)		omap_hwmod_hardreset_deassert(oh, oh->rst_lines[0].name);	_add_initiator_dep(oh, mpu_oh);	_enable_clocks(oh);	r = _wait_target_ready(oh);	if (!r) {		oh->_state = _HWMOD_STATE_ENABLED;		if (oh->class->sysc) {			if (!(oh->_int_flags & _HWMOD_SYSCONFIG_LOADED))				_update_sysc_cache(oh);			_sysc_enable(oh);		}	} else {		_disable_clocks(oh);		pr_debug("omap_hwmod: %s: _wait_target_ready: %d\n",			 oh->name, r);	}	return r;}int _omap_hwmod_idle(struct omap_hwmod *oh){	if ((oh->_state != _HWMOD_STATE_ENABLED) &&	    !(oh->flags & HWMOD_INIT_NO_IDLE)) {		WARN(1, "omap_hwmod: %s: idle state can only be entered from "		     "enabled state\n", oh->name);		return -EINVAL;	}	pr_debug("omap_hwmod: %s: idling\n", oh->name);	if (oh->class->sysc)		_sysc_idle(oh);	_del_initiator_dep(oh, mpu_oh);	_disable_clocks(oh);	oh->_state = _HWMOD_STATE_IDLE;	oh->flags &= ~HWMOD_INIT_NO_IDLE;	return 0;}int omap_hwmod_set_module_autoidle(struct omap_hwmod *oh, u8 autoidle){	u32 v;	int retval = 0;	if (!oh)		return -EINVAL;	v = oh->_sysc_cache;	retval = _set_module_autoidle(oh, autoidle, &v);	if (!retval)		_write_sysconfig(v, oh);	return retval;}static int _shutdown(struct omap_hwmod *oh){	if (oh->_state != _HWMOD_STATE_IDLE &&	    oh->_state != _HWMOD_STATE_ENABLED) {		WARN(1, "omap_hwmod: %s: disabled state can only be entered "		     "from idle, or enabled state\n", oh->name);		return -EINVAL;	}	pr_debug("omap_hwmod: %s: disabling\n", oh->name);	if (oh->class->sysc)		_sysc_shutdown(oh);	if (oh->rst_lines_cnt == 1)		omap_hwmod_hardreset_assert(oh, oh->rst_lines[0].name);	if (oh->_state == _HWMOD_STATE_ENABLED) {		_del_initiator_dep(oh, mpu_oh);				_disable_clocks(oh);	}	oh->_state = _HWMOD_STATE_DISABLED;	return 0;}static int _setup(struct omap_hwmod *oh, void *data){	int i, r;	u8 skip_setup_idle;	if (!oh || !data)		return -EINVAL;	skip_setup_idle = *(u8 *)data;	if (oh->slaves_cnt > 0) {		for (i = 0; i < oh->slaves_cnt; i++) {			struct omap_hwmod_ocp_if *os = oh->slaves[i];			struct clk *c = os->_clk;			if (!c)				continue;			if (os->flags & OCPIF_SWSUP_IDLE) {							} else {								clk_enable(c);			}		}	}	oh->_state = _HWMOD_STATE_INITIALIZED;	if ((oh->flags & HWMOD_INIT_NO_RESET) &&	    (oh->rst_lines_cnt == 1 || cpu_is_omap34xx()))		return 0;	r = _omap_hwmod_enable(oh);	if (r) {		pr_warning("omap_hwmod: %s: cannot be enabled (%d)\n",			   oh->name, oh->_state);		return 0;	}	if (!(oh->flags & HWMOD_INIT_NO_RESET)) {		_reset(oh);		if (oh->class->sysc) {			_update_sysc_cache(oh);			_sysc_enable(oh);		}	}	if (!(oh->flags & HWMOD_INIT_NO_IDLE) && !skip_setup_idle)		_omap_hwmod_idle(oh);	return 0;}u32 omap_hwmod_readl(struct omap_hwmod *oh, u16 reg_offs){	return __raw_readl(oh->_mpu_rt_va + reg_offs);}void omap_hwmod_writel(u32 v, struct omap_hwmod *oh, u16 reg_offs){	__raw_writel(v, oh->_mpu_rt_va + reg_offs);}int omap_hwmod_set_slave_idlemode(struct omap_hwmod *oh, u8 idlemode){	u32 v;	int retval = 0;	if (!oh)		return -EINVAL;	v = oh->_sysc_cache;	retval = _set_slave_idlemode(oh, idlemode, &v);	if (!retval)		_write_sysconfig(v, oh);	return retval;}int omap_hwmod_register(struct omap_hwmod *oh){	int ret, ms_id;	if (!oh || !oh->name || !oh->class || !oh->class->name ||	    (oh->_state != _HWMOD_STATE_UNKNOWN))		return -EINVAL;#if 1  spin_lock_irqsave(&omap_hwmod_spinlock, flags);#else	mutex_lock(&omap_hwmod_mutex);#endif	pr_debug("omap_hwmod: %s: registering\n", oh->name);	if (_lookup(oh->name)) {		ret = -EEXIST;		goto ohr_unlock;	}	ms_id = _find_mpu_port_index(oh);	if (!IS_ERR_VALUE(ms_id)) {		oh->_mpu_port_index = ms_id;		oh->_mpu_rt_va = _find_mpu_rt_base(oh, oh->_mpu_port_index);	} else {		oh->_int_flags |= _HWMOD_NO_MPU_PORT;	}	list_add_tail(&oh->node, &omap_hwmod_list);	oh->_state = _HWMOD_STATE_REGISTERED;	ret = 0;ohr_unlock:#if 1  spin_unlock_irqrestore(&omap_hwmod_spinlock, flags);#else	mutex_unlock(&omap_hwmod_mutex);#endif	return ret;}struct omap_hwmod *omap_hwmod_lookup(const char *name){	struct omap_hwmod *oh;	if (!name)		return NULL;#if 1  spin_lock_irqsave(&omap_hwmod_spinlock, flags);#else	mutex_lock(&omap_hwmod_mutex);#endif	oh = _lookup(name);#if 1  spin_unlock_irqrestore(&omap_hwmod_spinlock, flags);#else	mutex_unlock(&omap_hwmod_mutex);#endif	return oh;}int omap_hwmod_for_each(int (*fn)(struct omap_hwmod *oh, void *data),			void *data){	struct omap_hwmod *temp_oh;	int ret = 0;	if (!fn)		return -EINVAL;#if 1  spin_lock_irqsave(&omap_hwmod_spinlock, flags);#else	mutex_lock(&omap_hwmod_mutex);#endif	list_for_each_entry(temp_oh, &omap_hwmod_list, node) {		ret = (*fn)(temp_oh, data);		if (ret)			break;	}#if 1  spin_unlock_irqrestore(&omap_hwmod_spinlock, flags);#else	mutex_unlock(&omap_hwmod_mutex);#endif	return ret;}int omap_hwmod_init(struct omap_hwmod **ohs){	struct omap_hwmod *oh;	int r;	if (inited)		return -EINVAL;	inited = 1;	if (!ohs)		return 0;	oh = *ohs;	while (oh) {		if (omap_chip_is(oh->omap_chip)) {			r = omap_hwmod_register(oh);			WARN(r, "omap_hwmod: %s: omap_hwmod_register returned "			     "%d\n", oh->name, r);		}		oh = *++ohs;	}#if 0  spin_lock_init(&omap_hwmod_spinlock);#endif	return 0;}int omap_hwmod_late_init(u8 skip_setup_idle){	int r;	r = omap_hwmod_for_each(_init_clocks, NULL);	WARN(r, "omap_hwmod: omap_hwmod_late_init(): _init_clocks failed\n");	mpu_oh = omap_hwmod_lookup(MPU_INITIATOR_NAME);	WARN(!mpu_oh, "omap_hwmod: could not find MPU initiator hwmod %s\n",	     MPU_INITIATOR_NAME);	if (skip_setup_idle)		pr_debug("omap_hwmod: will leave hwmods enabled during setup\n");	omap_hwmod_for_each(_setup, &skip_setup_idle);#if 1  spin_lock_init(&omap_hwmod_spinlock);#endif	return 0;}int omap_hwmod_unregister(struct omap_hwmod *oh){	if (!oh)		return -EINVAL;	pr_debug("omap_hwmod: %s: unregistering\n", oh->name);#if 1  spin_lock_irqsave(&omap_hwmod_spinlock, flags);#else	mutex_lock(&omap_hwmod_mutex);#endif	iounmap(oh->_mpu_rt_va);	list_del(&oh->node);#if 1  spin_unlock_irqrestore(&omap_hwmod_spinlock, flags);#else	mutex_unlock(&omap_hwmod_mutex);#endif	return 0;}int omap_hwmod_enable(struct omap_hwmod *oh){	int r;	if (!oh)		return -EINVAL;#if 1  spin_lock_irqsave(&omap_hwmod_spinlock, flags);#else	mutex_lock(&omap_hwmod_mutex);#endif	r = _omap_hwmod_enable(oh);#if 1  spin_unlock_irqrestore(&omap_hwmod_spinlock, flags);#else	mutex_unlock(&omap_hwmod_mutex);#endif	return r;}int omap_hwmod_idle(struct omap_hwmod *oh){	if (!oh)		return -EINVAL;#if 1  spin_lock_irqsave(&omap_hwmod_spinlock, flags);#else	mutex_lock(&omap_hwmod_mutex);#endif	_omap_hwmod_idle(oh);#if 1  spin_unlock_irqrestore(&omap_hwmod_spinlock, flags);#else	mutex_unlock(&omap_hwmod_mutex);#endif	return 0;}int omap_hwmod_shutdown(struct omap_hwmod *oh){	if (!oh)		return -EINVAL;#if 1  spin_lock_irqsave(&omap_hwmod_spinlock, flags);#else	mutex_lock(&omap_hwmod_mutex);#endif	_shutdown(oh);#if 1  spin_unlock_irqrestore(&omap_hwmod_spinlock, flags);#else	mutex_unlock(&omap_hwmod_mutex);#endif	return 0;}int omap_hwmod_enable_clocks(struct omap_hwmod *oh){#if 1  spin_lock_irqsave(&omap_hwmod_spinlock, flags);#else	mutex_lock(&omap_hwmod_mutex);#endif	_enable_clocks(oh);#if 1  spin_unlock_irqrestore(&omap_hwmod_spinlock, flags);#else	mutex_unlock(&omap_hwmod_mutex);#endif	return 0;}int omap_hwmod_disable_clocks(struct omap_hwmod *oh){#if 1  spin_lock_irqsave(&omap_hwmod_spinlock, flags);#else	mutex_lock(&omap_hwmod_mutex);#endif	_disable_clocks(oh);#if 1  spin_unlock_irqrestore(&omap_hwmod_spinlock, flags);#else	mutex_unlock(&omap_hwmod_mutex);#endif	return 0;}void omap_hwmod_ocp_barrier(struct omap_hwmod *oh){	BUG_ON(!oh);	if (!oh->class->sysc || !oh->class->sysc->sysc_flags) {		WARN(1, "omap_device: %s: OCP barrier impossible due to "		      "device configuration\n", oh->name);		return;	}	omap_hwmod_readl(oh, oh->class->sysc->sysc_offs);}int omap_hwmod_reset(struct omap_hwmod *oh){	int r;	if (!oh)		return -EINVAL;#if 1  spin_lock_irqsave(&omap_hwmod_spinlock, flags);#else	mutex_lock(&omap_hwmod_mutex);#endif	r = _reset(oh);#if 1  spin_unlock_irqrestore(&omap_hwmod_spinlock, flags);#else	mutex_unlock(&omap_hwmod_mutex);#endif	return r;}#define RST_CTRL_ST_OFFSET 4u8 _lookup_reset(struct omap_hwmod *oh, const char *name){	int i;	for (i = 0; i < oh->rst_lines_cnt; i++) {		const char *rst_line = oh->rst_lines[i].name;		if (!strcmp(rst_line, name)) {			u8 shift = oh->rst_lines[i].rst_shift;			pr_debug("omap_hwmod: %s: _lookup_reset: %s: %d\n",				 oh->name, rst_line, shift);			return shift;		}	}	return -ENOENT;}int omap_hwmod_hardreset_assert(struct omap_hwmod *oh, const char *name){	u8 shift;	u32 mask;	if (!oh)		return -EINVAL;	if (!cpu_is_omap44xx()) {		pr_warning("%s only supported on OMAP4\n", __func__);		return -EINVAL;	}	shift = _lookup_reset(oh, name);	if (IS_ERR_VALUE(shift))		return shift;	mask = 1 << shift;	omap4_prm_rmw_reg_bits(mask, mask, oh->prcm.omap4.rstctrl_reg);	return 0;}int omap_hwmod_hardreset_deassert(struct omap_hwmod *oh, const char *name){	u8 shift;	u32 mask;	int c = 0;	if (!oh)		return -EINVAL;	if (!cpu_is_omap44xx()) {		pr_warning("%s only supported on OMAP4\n", __func__);		return -EINVAL;	}	shift = _lookup_reset(oh, name);	if (IS_ERR_VALUE(shift))		return shift;	mask = 1 << shift;	if (omap4_prm_read_bits_shift(oh->prcm.omap4.rstctrl_reg, mask) == 0) {		pr_warning("omap_hwmod: %s: reset already de-asserted\n",			   oh->name);		return 0;	}	omap4_prm_rmw_reg_bits(0xffffffff, mask, oh->prcm.omap4.rstctrl_reg						 + RST_CTRL_ST_OFFSET);		omap4_prm_rmw_reg_bits(mask, 0, oh->prcm.omap4.rstctrl_reg);		omap_test_timeout(omap4_prm_read_bits_shift(oh->prcm.omap4.rstctrl_reg						    + RST_CTRL_ST_OFFSET, mask),			  MAX_MODULE_RESET_WAIT, c);	if (c == MAX_MODULE_RESET_WAIT) {		pr_warning("omap_hwmod: %s: failed to reset in %d usec\n",			   oh->name, MAX_MODULE_RESET_WAIT);		return -EBUSY;	} else {		pr_debug("omap_hwmod: %s: reset %s in %d usec\n",			 oh->name, name, c);	}	return 0;}int omap_hwmod_hardreset_state(struct omap_hwmod *oh, const char *name){	u8 shift;	u32 mask;	if (!oh)		return -EINVAL;	if (!cpu_is_omap44xx()) {		pr_warning("%s only supported on OMAP4\n", __func__);		return -EINVAL;	}	shift = _lookup_reset(oh, name);	if (IS_ERR_VALUE(shift))		return shift;	mask = 1 << shift;	return omap4_prm_read_bits_shift(oh->prcm.omap4.rstctrl_reg, mask);}int omap_hwmod_count_resources(struct omap_hwmod *oh){	int ret, i;	ret = oh->mpu_irqs_cnt + oh->sdma_reqs_cnt;	for (i = 0; i < oh->slaves_cnt; i++)		ret += oh->slaves[i]->addr_cnt;	return ret;}int omap_hwmod_fill_resources(struct omap_hwmod *oh, struct resource *res){	int i, j;	int r = 0;	for (i = 0; i < oh->mpu_irqs_cnt; i++) {		(res + r)->name = (oh->mpu_irqs + i)->name;		(res + r)->start = (oh->mpu_irqs + i)->irq;		(res + r)->end = (oh->mpu_irqs + i)->irq;		(res + r)->flags = IORESOURCE_IRQ;		r++;	}	for (i = 0; i < oh->sdma_reqs_cnt; i++) {		(res + r)->name = (oh->sdma_reqs + i)->name;		(res + r)->start = (oh->sdma_reqs + i)->dma_req;		(res + r)->end = (oh->sdma_reqs + i)->dma_req;		(res + r)->flags = IORESOURCE_DMA;		r++;	}	for (i = 0; i < oh->slaves_cnt; i++) {		struct omap_hwmod_ocp_if *os;		os = oh->slaves[i];		for (j = 0; j < os->addr_cnt; j++) {			(res + r)->start = (os->addr + j)->pa_start;			(res + r)->end = (os->addr + j)->pa_end;			(res + r)->flags = IORESOURCE_MEM;			r++;		}	}	return r;}struct powerdomain *omap_hwmod_get_pwrdm(struct omap_hwmod *oh){	struct clk *c;	if (!oh)		return NULL;	if (oh->_clk) {		c = oh->_clk;	} else {		if (oh->_int_flags & _HWMOD_NO_MPU_PORT)			return NULL;		c = oh->slaves[oh->_mpu_port_index]->_clk;	}	if (!c->clkdm)		return NULL;	return c->clkdm->pwrdm.ptr;}void __iomem *omap_hwmod_get_mpu_rt_va(struct omap_hwmod *oh){	if (!oh)		return NULL;	if (oh->_int_flags & _HWMOD_NO_MPU_PORT)		return NULL;	if (oh->_state == _HWMOD_STATE_UNKNOWN)		return NULL;	return oh->_mpu_rt_va;}struct clk *omap_hwmod_get_clk(struct omap_hwmod *oh){	if (!oh)		return NULL;	if (oh->_int_flags & _HWMOD_NO_MPU_PORT)		return NULL;	if (oh->_state == _HWMOD_STATE_UNKNOWN)		return NULL;	return oh->_clk;}int omap_hwmod_add_initiator_dep(struct omap_hwmod *oh,				 struct omap_hwmod *init_oh){	return _add_initiator_dep(oh, init_oh);}int omap_hwmod_del_initiator_dep(struct omap_hwmod *oh,				 struct omap_hwmod *init_oh){	return _del_initiator_dep(oh, init_oh);}int omap_hwmod_enable_wakeup(struct omap_hwmod *oh){	if (!oh->class->sysc ||	    !(oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP))		return -EINVAL;#if 1  spin_lock_irqsave(&omap_hwmod_spinlock, flags);#else	mutex_lock(&omap_hwmod_mutex);#endif	_enable_wakeup(oh);#if 1  spin_unlock_irqrestore(&omap_hwmod_spinlock, flags);#else	mutex_unlock(&omap_hwmod_mutex);#endif	return 0;}int omap_hwmod_disable_wakeup(struct omap_hwmod *oh){	if (!oh->class->sysc ||	    !(oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP))		return -EINVAL;#if 1  spin_lock_irqsave(&omap_hwmod_spinlock, flags);#else	mutex_lock(&omap_hwmod_mutex);#endif	_disable_wakeup(oh);#if 1  spin_unlock_irqrestore(&omap_hwmod_spinlock, flags);#else	mutex_unlock(&omap_hwmod_mutex);#endif	return 0;}int omap_hwmod_for_each_by_class(const char *classname,				 int (*fn)(struct omap_hwmod *oh,					   void *user),				 void *user){	struct omap_hwmod *temp_oh;	int ret = 0;	if (!classname || !fn)		return -EINVAL;	pr_debug("omap_hwmod: %s: looking for modules of class %s\n",		 __func__, classname);#if 1  spin_lock_irqsave(&omap_hwmod_spinlock, flags);#else	mutex_lock(&omap_hwmod_mutex);#endif	list_for_each_entry(temp_oh, &omap_hwmod_list, node) {		if (!strcmp(temp_oh->class->name, classname)) {			pr_debug("omap_hwmod: %s: %s: calling callback fn\n",				 __func__, temp_oh->name);			ret = (*fn)(temp_oh, user);			if (ret)				break;		}	}#if 1  spin_unlock_irqrestore(&omap_hwmod_spinlock, flags);#else	mutex_unlock(&omap_hwmod_mutex);#endif	if (ret)		pr_debug("omap_hwmod: %s: iterator terminated early: %d\n",			 __func__, ret);	return ret;}