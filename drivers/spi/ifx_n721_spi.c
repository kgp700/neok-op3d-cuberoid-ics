#include <linux/init.h>#include <linux/module.h>#include <linux/ioctl.h>#include <linux/fs.h>#include <linux/device.h>#include <linux/err.h>#include <linux/list.h>#include <linux/errno.h>#include <linux/mutex.h>#include <linux/slab.h>#include <linux/smp_lock.h>#include <asm/uaccess.h>#include <linux/irq.h>#include <mach/gpio.h>#include <linux/tty.h>#include <linux/tty_driver.h>#include <linux/tty_flip.h>#include <linux/interrupt.h>#include <linux/completion.h>#include <linux/spi/spi.h>#include <linux/workqueue.h>#include <linux/delay.h>#include <linux/spi/ifx_n721_spi.h>#include <linux/cosmo/charger_rt9524.h>#include <plat/lge_err_handler.h>#include <plat/lge_nvdata_handler.h>#include <linux/input.h>#include <linux/rtc.h>#ifndef ENABLE_CP_CRASH_RESET#define EVENT_KEY KEY_F24 #define EVENT_HARD_RESET_KEY	195	#endif#if defined(LGE_VT_DATA_DUMP)#define VT_MUX12_DEBUG#if defined(VT_MUX12_DEBUG)extern bool mux_12_open;#endifextern unsigned int mux_written_counter;#endif#define MODEM_SEND 121 struct ifx_spi_data {	dev_t			devt;	spinlock_t		spi_lock;	struct spi_device	*spi;	struct list_head	device_entry;        struct completion       ifx_read_write_completion;        struct tty_struct       *ifx_tty;	struct mutex		buf_lock;	unsigned		users;        unsigned int		throttle;        struct work_struct      ifx_work;#if 1 	struct workqueue_struct *ifx_wq;#else        struct work_queue_struct *ifx_wq;#endifint ifx_spi_lock;		};union ifx_spi_frame_header{	struct{		unsigned int curr_data_size:12;		unsigned int more:1;		unsigned int res1:1;		unsigned int res2:2;      		unsigned int next_data_size:12;		unsigned int ri:1;		unsigned int dcd:1;		unsigned int cts_rts:1;		unsigned int dsr_dtr:1;	}ifx_spi_header;	unsigned char framesbytes[IFX_SPI_HEADER_SIZE];};struct ifx_spi_data	*gspi_data;struct tty_driver 	*ifx_spi_tty_driver;unsigned long		minors[IFX_N_SPI_MINORS / BITS_PER_LONG];unsigned int		ifx_master_initiated_transfer = 0;unsigned int		ifx_spi_count;unsigned int		ifx_ril_is_modem_alive = 1;unsigned int		ifx_sender_buf_size;unsigned int		ifx_receiver_buf_size;unsigned int		ifx_current_frame_size;unsigned int		ifx_valid_frame_size;unsigned int		ifx_ret_count;const unsigned char 	*ifx_spi_buf;unsigned char		*ifx_tx_buffer;unsigned char           *ifx_rx_buffer;static void ifx_spi_set_header_info(unsigned char *header_buffer, unsigned int curr_buf_size, unsigned int next_buf_size);static int ifx_spi_get_header_info(unsigned int *valid_buf_size);static void ifx_spi_set_mrdy_signal(int value);static void ifx_spi_setup_transmission(void);static void ifx_spi_send_and_receive_data(struct ifx_spi_data *spi_data);static int ifx_spi_get_next_frame_size(int count);static int ifx_spi_allocate_frame_memory(unsigned int memory_size);static void ifx_spi_buffer_initialization(void);static unsigned int ifx_spi_sync_read_write(struct ifx_spi_data *spi_data, unsigned int len);static irqreturn_t ifx_spi_handle_srdy_irq(int irq, void *handle);static void ifx_spi_handle_work(struct work_struct *work);unsigned char rx_dummy[]={0xff,0xff,0xff,0xff};static struct work_struct CP_CRASH_INT_wq;static struct delayed_work	cp_crash_int_delayed_wq;static void CP_CRASH_wq_func(struct work_struct *cp_crash_wq);static irqreturn_t CP_CRASH_interrupt_handler(s32 irq, void *data);#ifndef ENABLE_CP_CRASH_RESETstatic struct input_dev *in_dev = NULL;#endifstatic LIST_HEAD(device_list);static DEFINE_MUTEX(device_list_lock);static int ifx_spi_open(struct tty_struct *tty, struct file *filp){	int status = 0;	struct ifx_spi_data *spi_data = gspi_data;  	spi_data->ifx_tty = tty;	tty->driver_data = spi_data;	spi_data->ifx_spi_lock =0;		ifx_spi_buffer_initialization();	spi_data->throttle = 0;	return status;}static void ifx_spi_close(struct tty_struct *tty, struct file *filp){  }#ifdef LGE_DUMP_SPI_BUFFER#define COL_SIZE 50static void dump_spi_buffer(const unsigned char *txt, const unsigned char *buf, int count){    char dump_buf_str[COL_SIZE+1];    if (buf != NULL)     {        int j = 0;        char *cur_str = dump_buf_str;        unsigned char ch;        while((j < COL_SIZE) && (j  < count))        {            ch = buf[j];            if ((ch < 32) || (ch > 126))            {                *cur_str = '.';            } else            {                *cur_str = ch;            }            cur_str++;            j++;        }        *cur_str = 0;        printk("%s:count:%d [%s]\n", txt, count, dump_buf_str);                            }    else    {        printk("%s: buffer is NULL\n", txt);                     }}#elif defined(LGE_VT_DATA_DUMP)#define COL_SIZE 160static void dump_spi_wr_buffer(const unsigned char *buf, int count){  static unsigned int spi_write_cnt = 0;  char dump_buf_str[(COL_SIZE+1)*2];#if 0  if(mux_12_open == 0)		   	return;#endif  #if 0          if ((buf != NULL) && (count >= 160))    {        	int j = 0;        	char *cur_str = dump_buf_str;        	unsigned char ch;        	while((j < COL_SIZE) && (j  < count))        	{                        ch = buf[j];            sprintf(cur_str, "%0.2x", ch);			            cur_str = cur_str+2;            j++;                }	*cur_str = 0;       	printk("SPI WR[%d] [%s]\n", spi_write_cnt, dump_buf_str);                            		spi_write_cnt++;    }  #else        if ((buf != NULL) && (count >= 160))    {         printk("IFX OK[%d], MUX[%d]\n", spi_write_cnt, mux_written_counter);         	 spi_write_cnt++;    }  #endif	}static void dump_spi_rd_buffer(const unsigned char *buf, int count){    char dump_buf_str[COL_SIZE+1];#if defined(VT_MUX12_DEBUG)  if(mux_12_open == 0)		   	return;#endif  if ((buf != NULL)  && (count <= 170))    {        int j = 0;        char *cur_str = dump_buf_str;        while((j < count))            {            if (0 == buf[j])            	{                *cur_str = '.';            	            	}	    else		{		  if ((j <=4) && ((0x0d == buf[j]) || (0x0a == buf[j])))		  	{		                *cur_str = '.'; 		  	}		  else		  	{		              *cur_str = buf[j];				  	}		}				if ((0x0d == buf[j]) && (0x0a == buf[j]))		{        		*cur_str = ']';			break;		}			                    cur_str++;		            j++;        }        *cur_str = 0;        printk("SPI Read count:%d [%s]\n", count, dump_buf_str);                            }	}#else#define dump_spi_buffer(...)#endifstatic int ifx_spi_write(struct tty_struct *tty, const unsigned char *buf, int count){		struct ifx_spi_data *spi_data = (struct ifx_spi_data *)tty->driver_data;        ifx_ret_count = 0;#ifdef LGE_DUMP_SPI_BUFFER    dump_spi_buffer("ifx_spi_write()", buf, count);#elif defined(LGE_VT_DATA_DUMP)    if (count == 167)     {           }#endif	if(spi_data->ifx_spi_lock)		return ifx_ret_count;	spi_data->ifx_tty = tty;	spi_data->ifx_tty->low_latency = 1;	if( !buf ){		printk("File: ifx_n721_spi.c\tFunction: int ifx_spi_write()\t Buffer NULL\n");		return ifx_ret_count;	}	if(!count){		printk("File: ifx_n721_spi.c\tFunction: int ifx_spi_write()\t Count is ZERO\n");		return ifx_ret_count;	}	ifx_master_initiated_transfer = 1;	ifx_spi_buf = buf;	ifx_spi_count = count;	{		int i, max_retry_count=8;		unsigned long timeout=HZ;		long rc;		for (i=0 ; i<max_retry_count ; i++) {						ifx_spi_set_mrdy_signal(1);			rc = wait_for_completion_timeout(					&spi_data->ifx_read_write_completion,					timeout);			if (rc == 0) {						printk("***** unable to detect SREADY within %lu, RETRY (counter=%d) *****\n", timeout, i+1);								ifx_spi_set_mrdy_signal(0);				if(i == (max_retry_count-1))				{					{						set_modem_alive(0);						ifx_ril_is_modem_alive = 0;					}				}				udelay(100);					} else {							if(!ifx_ril_is_modem_alive)				{					set_modem_alive(1);					ifx_ril_is_modem_alive = 1;				}				break;			}		}	}	init_completion(&spi_data->ifx_read_write_completion);	return ifx_ret_count; }static int ifx_spi_write_room(struct tty_struct *tty){		return 2048;}static int ifx_spi_probe(struct spi_device *spi){	int ret;	int status;	int err;	struct ifx_spi_data *spi_data;	printk("[e] ifx_spi_probe\n");	spi_data = (struct ifx_spi_data*)kmalloc(sizeof(struct ifx_spi_data), GFP_KERNEL);	if (!spi_data){		return -ENOMEM;        }        status = ifx_spi_allocate_frame_memory(IFX_SPI_MAX_BUF_SIZE + IFX_SPI_HEADER_SIZE);        if(status != 0){		printk("File: ifx_n721_spi.c\tFunction: int ifx_spi_probe\tFailed to allocate memory for buffers\n");				kfree(spi_data);				return -ENOMEM;        }	        dev_set_drvdata(&spi->dev,spi_data);        spin_lock_init(&spi_data->spi_lock);        INIT_WORK(&spi_data->ifx_work,ifx_spi_handle_work);		printk("[e] INIT_WORK\n");        spi_data->ifx_wq = create_singlethread_workqueue("ifxn721");        if(!spi_data->ifx_wq){		printk("Failed to setup workqueue - ifx_wq \n");                  }	init_completion(&spi_data->ifx_read_write_completion);                spi_data->spi = spi;        spi->mode = SPI_MODE_1;        spi->bits_per_word = 8;        status = spi_setup(spi);        if(status < 0){			printk("Failed to setup SPI \n");        }             	spi_data->ifx_spi_lock =1;	status = request_irq(spi->irq, ifx_spi_handle_srdy_irq,  IRQF_TRIGGER_RISING, spi->dev.driver->name, spi_data);	printk("[e] spi->irq:%d  status:%d\n", spi->irq, status);	if (status != 0){		printk(KERN_ERR "Failed to request IRQ for SRDY\n");		printk(KERN_ERR "IFX SPI Probe Failed\n");		if(ifx_tx_buffer){			kfree(ifx_tx_buffer);		}		if(ifx_rx_buffer){			kfree(ifx_rx_buffer);            		}		if(spi_data){			kfree(spi_data);		}          	}	else{		gspi_data = spi_data;	}                enable_irq_wake(spi->irq);	ret = gpio_request(MODEM_SEND, "MODEM_SEND");	if (ret < 0) {		printk(KERN_ERR "%s: Failed to request GPIO_%d for MODEM_SEND\n", __func__, MODEM_SEND);		return -ENOSYS;	}        gpio_direction_output(MODEM_SEND,1);        gpio_set_value(MODEM_SEND,1);	#define CP_CRASH_INT_N  26	ret = gpio_request(CP_CRASH_INT_N, "CP CRASH IRQ GPIO");	if (ret < 0) {		printk(KERN_INFO "[CP CRASH IRQ] GPIO#%03d is already occupied by other driver!\n", CP_CRASH_INT_N);		return -ENOSYS;	}	ret = gpio_direction_input(CP_CRASH_INT_N);	if (ret < 0) {		printk(KERN_INFO "[CP CRASH IRQ] GPIO#%03d direction initialization failed!\n", CP_CRASH_INT_N);		return -ENOSYS;	}	INIT_WORK(&CP_CRASH_INT_wq, CP_CRASH_wq_func);	INIT_DELAYED_WORK(&cp_crash_int_delayed_wq, CP_CRASH_wq_func);	ret = request_irq(gpio_to_irq(CP_CRASH_INT_N), CP_CRASH_interrupt_handler, IRQF_TRIGGER_RISING, "cp_crash_irq", &spi->dev);	if (ret < 0) {		printk(KERN_INFO "[CP CRASH IRQ] GPIO#%03d IRQ line set up failed!\n", CP_CRASH_INT_N);		free_irq(gpio_to_irq(CP_CRASH_INT_N), &spi->dev);		return -ENOSYS;	}#ifndef ENABLE_CP_CRASH_RESET		in_dev = input_allocate_device();	if (!in_dev) {		printk("Can't allocate power button\n");		return -ENOMEM;	}	in_dev->evbit[0] = BIT_MASK(EV_KEY);	in_dev->keybit[BIT_WORD(EVENT_KEY)] = BIT_MASK(EVENT_KEY);	in_dev->name = "ifxn721";	in_dev->phys = "ifxn721/input0";	in_dev->dev.parent = &spi->dev;	err = input_register_device(in_dev);	if (err) {		printk("Can't register EVENT_KEY button: %d\n", err);	}#endif	return status;}static void CP_CRASH_wq_func(struct work_struct *cp_crash_wq){	volatile unsigned long *make_panic = 0;	extern void set_muic_mode(u32 mode);	int ret;	struct timespec ts;	struct rtc_time tm;	getnstimeofday(&ts);	rtc_time_to_tm(ts.tv_sec, &tm);		printk(KERN_INFO "[CP CRASH IRQ] CP_CRASH_wq_func()");		printk(KERN_INFO "(%d-%02d-%02d %02d:%02d:%02d.%09lu UTC)\n", tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,			tm.tm_hour, tm.tm_min, tm.tm_sec, ts.tv_nsec);		if(gpio_get_value(CP_CRASH_INT_N)){#if 0   		*make_panic = 0xDEAD;	#endif				lge_store_ciq_reset(0, LGE_NVDATA_IQ_RESET_EXCEPTION);		{			unsigned char data;			lge_dynamic_nvdata_read(LGE_NVDATA_DYNAMIC_CP_CRASH_COUNT_OFFSET,&data,1);			data++;			lge_dynamic_nvdata_write(LGE_NVDATA_DYNAMIC_CP_CRASH_COUNT_OFFSET,&data,1);		}		if (lge_is_crash_dump_enabled() != 1)		{	#ifndef ENABLE_CP_CRASH_RESET				printk(" CP CRASH! immediate RIL/CP reset");			input_report_key(in_dev, EVENT_KEY, 1);			input_report_key(in_dev, EVENT_KEY, 0);			input_sync(in_dev);			printk("[CPW] input_report_key(): %d\n", EVENT_KEY);#endif			return;		}		printk(KERN_INFO "[CP CRASH IRQ] launch ifx_coredump process\n");		{		char* argv[] = {"/system/bin/ifx_coredump", "CP_CRASH_IRQ", NULL};		char *envp[] = { "HOME=/",	"PATH=/sbin:/bin:/system/bin",	NULL };					ret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);		printk(KERN_INFO "[CP CRASH IRQ] launch ifx_coredump process ret:%d\n",ret);		}		gpio_set_value(82, 1);#if 0				int toggle = 0;		for(;;)		{			if(toggle == 0)			{				gpio_set_value(82, 1);				toggle = 1;			}			else                                 			{				gpio_set_value(82, 0);				toggle = 0;			}			msleep(100);		}#endif			}	else	{		return;			}}static irqreturn_t CP_CRASH_interrupt_handler(s32 irq, void *data){	schedule_delayed_work( &cp_crash_int_delayed_wq, msecs_to_jiffies(500));	return IRQ_HANDLED;}static int ifx_spi_remove(struct spi_device *spi){		struct ifx_spi_data *spi_data;	spi_data = spi_get_drvdata(spi);	if(spi_data == NULL){		return 0;	}	spin_lock_irq(&spi_data->spi_lock);	spi_data->spi = NULL;	spi_set_drvdata(spi, NULL);	spin_unlock_irq(&spi_data->spi_lock);        if(ifx_tx_buffer){		kfree(ifx_tx_buffer);	}        if(ifx_rx_buffer){		kfree(ifx_rx_buffer);	}        if(spi_data){		kfree(spi_data);        }                  return 0;}static intifx_spi_suspend(struct spi_device *spi){	    gpio_set_value(MODEM_SEND,0);        return 0;}static intifx_spi_resume(struct spi_device *spi){    	    gpio_set_value(MODEM_SEND,1);        return 0;}static struct spi_driver ifx_spi_driver = {	.driver = {		.name = "ifxn721",                .bus = &spi_bus_type,		.owner = THIS_MODULE,	},	.probe = ifx_spi_probe,	.remove = __devexit_p(ifx_spi_remove),    .suspend = ifx_spi_suspend,    .resume = ifx_spi_resume,};static const struct tty_operations ifx_spi_ops = {    .open = ifx_spi_open,    .close = ifx_spi_close,    .write = ifx_spi_write,    .write_room = ifx_spi_write_room,            };static void ifx_spi_buffer_initialization(void){	ifx_sender_buf_size = IFX_SPI_DEFAULT_BUF_SIZE;        ifx_receiver_buf_size = IFX_SPI_DEFAULT_BUF_SIZE;}static int ifx_spi_allocate_frame_memory(unsigned int memory_size){	int status = 0;	ifx_rx_buffer = kmalloc(memory_size+IFX_SPI_HEADER_SIZE, GFP_KERNEL);	if (!ifx_rx_buffer){		printk("Open Failed ENOMEM\n");		status = -ENOMEM;	}	ifx_tx_buffer = kmalloc(memory_size+IFX_SPI_HEADER_SIZE, GFP_KERNEL);	if (!ifx_tx_buffer){				printk("Open Failed ENOMEM\n");		status = -ENOMEM;	}	if(status == -ENOMEM){		if(ifx_tx_buffer){			kfree(ifx_tx_buffer);		}		if(ifx_rx_buffer){			kfree(ifx_rx_buffer);            		}	}	return status;}static void ifx_spi_set_header_info(unsigned char *header_buffer, unsigned int curr_buf_size, unsigned int next_buf_size){	int i;	union ifx_spi_frame_header header;	for(i=0; i<4; i++){		header.framesbytes[i] = 0;	}	header.ifx_spi_header.curr_data_size = curr_buf_size;	if(next_buf_size){		header.ifx_spi_header.more=1;		header.ifx_spi_header.next_data_size = next_buf_size;	}	else{		header.ifx_spi_header.more=0;		header.ifx_spi_header.next_data_size = 128;	}	for(i=3; i>=0; i--){	header_buffer[i] = header.framesbytes[i];	}}static int ifx_spi_get_header_info(unsigned int *valid_buf_size){	int i;	union ifx_spi_frame_header header;	for(i=0; i<4; i++){		header.framesbytes[i] = 0;	}	for(i=3; i>=0; i--){		header.framesbytes[i] = ifx_rx_buffer[i];	}	*valid_buf_size = header.ifx_spi_header.curr_data_size;	if(header.ifx_spi_header.more){		return header.ifx_spi_header.next_data_size;	}	return 0;}static void ifx_spi_set_mrdy_signal(int value){	gpio_set_value(IFX_MRDY_GPIO, value);}static int ifx_spi_get_next_frame_size(int count){	if(count > IFX_SPI_MAX_BUF_SIZE){		return IFX_SPI_MAX_BUF_SIZE;    	}	else{   		return count;	}}static void ifx_spi_setup_transmission(void){	if( (ifx_sender_buf_size != 0) || (ifx_receiver_buf_size != 0) ){		if(ifx_sender_buf_size > ifx_receiver_buf_size){			ifx_current_frame_size = ifx_sender_buf_size;		}		else{ 			ifx_current_frame_size = ifx_receiver_buf_size;    		}		if(ifx_spi_count > 0){			if(ifx_spi_count > ifx_current_frame_size){				ifx_valid_frame_size = ifx_current_frame_size;				ifx_spi_count = ifx_spi_count - ifx_current_frame_size;			}			else{				ifx_valid_frame_size = ifx_spi_count;				ifx_spi_count = 0;			}                }		else{			ifx_valid_frame_size = 0;			ifx_sender_buf_size = 0;		}		ifx_sender_buf_size = ifx_spi_get_next_frame_size(ifx_spi_count);		memset(ifx_tx_buffer,0,IFX_SPI_MAX_BUF_SIZE+IFX_SPI_HEADER_SIZE);		memset(ifx_rx_buffer,0,IFX_SPI_MAX_BUF_SIZE+IFX_SPI_HEADER_SIZE);		ifx_spi_set_header_info(ifx_tx_buffer, ifx_valid_frame_size, ifx_sender_buf_size);		if( ifx_valid_frame_size > 0 ){      			memcpy(ifx_tx_buffer+IFX_SPI_HEADER_SIZE, ifx_spi_buf, ifx_valid_frame_size);			ifx_spi_buf = ifx_spi_buf + ifx_valid_frame_size;		}	}}static void ifx_spi_send_and_receive_data(struct ifx_spi_data *spi_data){	unsigned int rx_valid_buf_size;	int status = 0; 	status = ifx_spi_sync_read_write(spi_data, ifx_current_frame_size+IFX_SPI_HEADER_SIZE);                          	if(status > 0){#if defined(LGE_DUMP_SPI_BUFFER)    dump_spi_buffer("ifx_spi_send_and_receive_data()[Trans]", &(ifx_tx_buffer[4]), COL_SIZE);#elif defined(LGE_VT_DATA_DUMP)    dump_spi_wr_buffer(&(ifx_tx_buffer[4]), ifx_valid_frame_size + 4);#endif		memset(ifx_tx_buffer,0,IFX_SPI_MAX_BUF_SIZE+IFX_SPI_HEADER_SIZE);		ifx_ret_count = ifx_ret_count + ifx_valid_frame_size;	}	if(memcmp(rx_dummy, ifx_rx_buffer, IFX_SPI_HEADER_SIZE) ==0) {		ifx_receiver_buf_size = 0;		return;	}	ifx_receiver_buf_size = ifx_spi_get_header_info(&rx_valid_buf_size);	if((spi_data->throttle == 0) && (rx_valid_buf_size != 0) && !(spi_data->ifx_spi_lock)){#ifdef LGE_DUMP_SPI_BUFFER    dump_spi_buffer("ifx_spi_send_and_receive_data()[Recev]", &(ifx_rx_buffer[4]), COL_SIZE);#elif defined(LGE_VT_DATA_DUMP)    #endif		tty_insert_flip_string(spi_data->ifx_tty, ifx_rx_buffer+IFX_SPI_HEADER_SIZE, rx_valid_buf_size);		tty_flip_buffer_push(spi_data->ifx_tty);	}  }static unsigned int ifx_spi_sync_read_write(struct ifx_spi_data *spi_data, unsigned int len){	int status;	struct spi_message	m;	struct spi_transfer	t = {					.tx_buf		= ifx_tx_buffer,                        		.rx_buf		= ifx_rx_buffer,					.len		= len,				    };    spi_message_init(&m);	spi_message_add_tail(&t, &m);		if (spi_data->spi == NULL)		status = -ESHUTDOWN;	else		status = spi_sync(spi_data->spi, &m);		if (status == 0){          		status = m.status;		if (status == 0)			status = m.actual_length;	}        else{		printk("File: ifx_n721_spi.c\tFunction: unsigned int ifx_spi_sync\tTransmission UNsuccessful\n");        }	return status;}static irqreturn_t ifx_spi_handle_srdy_irq(int irq, void *handle){	struct ifx_spi_data *spi_data = (struct ifx_spi_data *)handle;		queue_work(spi_data->ifx_wq, &spi_data->ifx_work);    	return IRQ_HANDLED; }static void ifx_spi_handle_work(struct work_struct *work){	struct ifx_spi_data *spi_data = container_of(work, struct ifx_spi_data, ifx_work);	if (!ifx_master_initiated_transfer){		ifx_spi_setup_transmission();		ifx_spi_set_mrdy_signal(1);		ifx_spi_send_and_receive_data(spi_data);				if((ifx_sender_buf_size == 0)  && (ifx_receiver_buf_size == 0)){			ifx_spi_set_mrdy_signal(0);			ifx_spi_buffer_initialization();		}		if(ifx_master_initiated_transfer == 1){	 		udelay(100);	 		            ifx_spi_set_mrdy_signal(1);		}	}	else{		ifx_spi_setup_transmission();     		ifx_spi_send_and_receive_data(spi_data);				if(ifx_sender_buf_size == 0){			if(ifx_receiver_buf_size == 0){						ifx_spi_set_mrdy_signal(0);				udelay(100);								ifx_spi_buffer_initialization();			}			ifx_master_initiated_transfer = 0;			complete(&spi_data->ifx_read_write_completion);		}	}}static int __init ifx_spi_init(void){int status = 0;	ifx_spi_tty_driver = alloc_tty_driver(IFX_N_SPI_MINORS);	if (!ifx_spi_tty_driver){		printk(KERN_ERR "Fail to allocate TTY Driver\n");		return -ENOMEM;	}	ifx_spi_tty_driver->owner = THIS_MODULE;	ifx_spi_tty_driver->driver_name = "ifxn721";	ifx_spi_tty_driver->name = "ttyspi";	ifx_spi_tty_driver->major = IFX_SPI_MAJOR;	ifx_spi_tty_driver->minor_start = 0;	ifx_spi_tty_driver->type = TTY_DRIVER_TYPE_SERIAL;	ifx_spi_tty_driver->subtype = SERIAL_TYPE_NORMAL;	ifx_spi_tty_driver->flags = TTY_DRIVER_REAL_RAW;	ifx_spi_tty_driver->init_termios = tty_std_termios;	ifx_spi_tty_driver->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;	tty_set_operations(ifx_spi_tty_driver, &ifx_spi_ops);	status = tty_register_driver(ifx_spi_tty_driver);	if (status){		printk(KERN_ERR "Failed to register IFX SPI tty driver");		put_tty_driver(ifx_spi_tty_driver);		return status;	}	status = spi_register_driver(&ifx_spi_driver);	printk(KERN_ERR "spi_register_driver return %d\n", status);	if (status < 0){ 		printk(KERN_ERR "Failed to register SPI device");		tty_unregister_driver(ifx_spi_tty_driver);		put_tty_driver(ifx_spi_tty_driver);		return status;	}	return status;}module_init(ifx_spi_init);static void __exit ifx_spi_exit(void){  	spi_unregister_driver(&ifx_spi_driver);	tty_unregister_driver(ifx_spi_tty_driver);        put_tty_driver(ifx_spi_tty_driver);}module_exit(ifx_spi_exit);MODULE_AUTHOR("Umesh Bysani and Shreekanth D.H, <bysani@ti.com> <sdh@ti.com>");MODULE_DESCRIPTION("IFX SPI Framing Layer");MODULE_LICENSE("GPL");