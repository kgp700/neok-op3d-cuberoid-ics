#ifndef __XMD_HSI_LL_INTERNAL_H__#define __XMD_HSI_LL_INTERNAL_H__#include <linux/timer.h>#define HSI_LL_CTRL_CHANNEL 0#define HSI_LL_INVALID_CHANNEL 0xFF#define HSI_LL_MAX_CMD_Q_SIZE       32#define HSI_LL_TIMER_Q_SIZE (3 * HSI_LL_MAX_CHANNELS)#if defined (HSI_LL_ENABLE_PM)#define HSI_LL_PV_READ_CMD_Q_TIMEOUT   80#define HSI_LL_PV_THREAD_SLEEP_TIME    20#define HSI_LL_PV_RESTART_CMD_Q_TIMEOUT   100 * HZ#endifenum{	FALSE,	TRUE,};enum {	HSI_LL_HSI_HW_ON,	HSI_LL_HSI_HW_OFF,};enum {	HSI_LL_WAKE_LINE_LOW,	HSI_LL_WAKE_LINE_HIGH,};enum {	HSI_LL_PHY_ID_RX,	HSI_LL_PHY_ID_TX,	HSI_LL_PHY_UNKNOWN,};enum {	HSI_LL_ROLE_TRANSMITTER,	HSI_LL_ROLE_RECEIVER,};enum {	HSI_LL_PSV_EVENT_INVALID,	HSI_LL_PSV_EVENT_PSV_DISABLE,	HSI_LL_PSV_EVENT_PSV_ENABLE,#if 1		HSI_LL_PSV_EVENT_PSV_RESTART,#endif	};enum {	HSI_LL_IF_STATE_UN_INIT,	HSI_LL_IF_STATE_READY,	HSI_LL_IF_STATE_CONFIG,	HSI_LL_IF_STATE_ERR_RECOVERY,	HSI_LL_IF_STATE_PERM_ERROR,};enum {	HSI_LL_MSG_BREAK           = 0x00,	HSI_LL_MSG_ECHO            = 0x01,	HSI_LL_MSG_INFO_REQ        = 0x02,	HSI_LL_MSG_INFO            = 0x03,	HSI_LL_MSG_CONFIGURE       = 0x04,	HSI_LL_MSG_ALLOCATE_CH     = 0x05,	HSI_LL_MSG_RELEASE_CH      = 0x06,	HSI_LL_MSG_OPEN_CONN       = 0x07,	HSI_LL_MSG_CONN_READY      = 0x08,	HSI_LL_MSG_CONN_CLOSED     = 0x09,	HSI_LL_MSG_CANCEL_CONN     = 0x0A,	HSI_LL_MSG_ACK             = 0x0B,	HSI_LL_MSG_NAK             = 0x0C,	HSI_LL_MSG_CONF_RATE       = 0x0D,	HSI_LL_MSG_OPEN_CONN_OCTET = 0x0E,	HSI_LL_MSG_INVALID         = 0xFF,};enum {	HSI_LL_TX_STATE_UNDEF,	HSI_LL_TX_STATE_CLOSED,	HSI_LL_TX_STATE_IDLE,	HSI_LL_TX_STATE_POWER_DOWN,	HSI_LL_TX_STATE_ERROR,	HSI_LL_TX_STATE_OPEN_CONN,	HSI_LL_TX_STATE_WAIT_FOR_ACK,	HSI_LL_TX_STATE_NACK,	HSI_LL_TX_STATE_WAIT_FOR_CONN_READY,	HSI_LL_TX_STATE_SEND_CONF_RATE,	HSI_LL_TX_STATE_WAIT_FOR_CONF_ACK,	HSI_LL_TX_STATE_TX,	HSI_LL_TX_STATE_WAIT_FOR_CONN_CLOSED,	HSI_LL_TX_STATE_TO_OPEN_CONN,	HSI_LL_TX_STATE_TO_ACK,	HSI_LL_TX_STATE_TO_READY,	HSI_LL_TX_STATE_TO_CONF,	HSI_LL_TX_STATE_TO_CONF_ACK,	HSI_LL_TX_STATE_TO_TX,	HSI_LL_TX_STATE_TO_CLOSE,	HSI_LL_TX_STATE_SEND_BREAK,	HSI_LL_TX_STATE_WAIT_FOR_TX_COMPLETE,};enum {	HSI_LL_RX_STATE_UNDEF,	HSI_LL_RX_STATE_CLOSED,	HSI_LL_RX_STATE_IDLE,	HSI_LL_RX_STATE_POWER_DOWN,	HSI_LL_RX_STATE_ERROR,	HSI_LL_RX_STATE_BLOCKED,	HSI_LL_RX_STATE_SEND_ACK,	HSI_LL_RX_STATE_SEND_NACK,	HSI_LL_RX_STATE_SEND_CONN_READY,	HSI_LL_RX_STATE_RX,	HSI_LL_RX_STATE_SEND_CONN_CLOSED,	HSI_LL_RX_STATE_SEND_CONN_CANCEL,	HSI_LL_RX_STATE_WAIT_FOR_CANCEL_CONN_ACK,	HSI_LL_RX_STATE_SEND_CONF_ACK,	HSI_LL_RX_STATE_SEND_CONF_NACK,	HSI_LL_RX_STATE_TO_RX,	HSI_LL_RX_STATE_TO_ACK,	HSI_LL_RX_STATE_TO_NACK,	HSI_LL_RX_STATE_TO_CONN_READY,	HSI_LL_RX_STATE_TO_CONN_CLOSED,	HSI_LL_RX_STATE_TO_CONN_CANCEL,	HSI_LL_RX_STATE_TO_CONN_CANCEL_ACK,	HSI_LL_RX_STATE_TO_CONF_ACK,	HSI_LL_RX_STATE_SEND_BREAK,};enum {	HIS_LL_TIMER_DIR_UNDEF,	HIS_LL_TIMER_DIR_RX,	HIS_LL_TIMER_DIR_TX,};enum {	HIS_LL_TIMER_QUEUE_CMD_INVALID,	HIS_LL_TIMER_QUEUE_CMD_START,	HIS_LL_TIMER_QUEUE_CMD_STOP,};typedef struct hsi_ll_timer_Q {	unsigned int timer_cmd;	unsigned int timer_dir;	unsigned int channel;	unsigned int time_out;} ll_timer_Q;typedef struct hsi_ll_cmd_queue {	unsigned int command;	unsigned int channel;	unsigned int phy_id;} ll_cmd_queue;typedef struct hsi_ll_tx_cmd_q {	unsigned int read_index;	unsigned int write_index;	unsigned int count;	unsigned int phy_id;	unsigned int channel;	struct hsi_ll_cmd_queue cmd_q[HSI_LL_MAX_CMD_Q_SIZE];} ll_tx_cmd_q;typedef struct hsi_ll_tx_ch {	unsigned int channel;	unsigned int state;	unsigned int close_req;	unsigned int data_rate;	unsigned int pending;	unsigned int retry;	void	    *buffer;	unsigned int size;	struct timer_list timer_id;#if defined (HSI_LL_ENABLE_TX_RETRY_WQ)	struct work_struct retry_work;#endif} ll_tx_ch;typedef struct hsi_ll_rx_ch {	unsigned int state;	void        *buffer;	unsigned int size;	unsigned int close_req;	struct timer_list timer_id;#if 1		unsigned int nak_sent;#endif} ll_rx_ch;typedef struct hsi_ll_channel {	unsigned int        open;	struct hsi_ll_tx_ch tx;	struct hsi_ll_rx_ch rx;} ll_channel;typedef struct hsi_ll_tx_cfg {	unsigned int   new_data_rate_valid;	unsigned int   baud_rate;	unsigned int   ac_wake;	struct hst_ctx ctx;} ll_tx_cfg;typedef struct hsi_ll_rx_cfg {	unsigned int   new_data_rate_valid;	unsigned int   baud_rate;	unsigned int   ca_wake;	struct hsr_ctx ctx;} ll_rx_cfg;typedef struct hsi_ll_data_struct {	unsigned int            initialized;	unsigned int            state;	unsigned int            rx_cmd;	struct hsi_ll_tx_cmd_q  tx_cmd;	struct hsi_ll_tx_cfg    tx_cfg;	struct hsi_ll_rx_cfg    rx_cfg;	struct hsi_ll_channel   ch[HSI_LL_MAX_CHANNELS];	struct hsi_device      *dev[HSI_LL_MAX_CHANNELS];} ll_data_struct;typedef struct hsi_ll_if_struct {	int                   wr_complete_flag;	int                   rd_complete_flag;	int                   msg_avaliable_flag;	int                   reg_complete_flag;#if defined (HSI_LL_ENABLE_PM)	int                   psv_event_flag;#endif#if defined (HSI_LL_ENABLE_TIMERS)	unsigned int          timer_queue_cnt;	unsigned int          timer_queue_wr;	unsigned int          timer_queue_rd;#endif	unsigned int          reg_complete_ch_count;	spinlock_t            phy_cb_lock;#if defined (HSI_LL_ENABLE_TIMERS)	spinlock_t            start_tx_timer_lock;	spinlock_t            start_rx_timer_lock;	spinlock_t            stop_tx_timer_lock;	spinlock_t            stop_rx_timer_lock;	spinlock_t            tx_timer_cb_lock;	spinlock_t            rx_timer_cb_lock;	spinlock_t            timer_bh_lock;#endif	spinlock_t            wr_cmd_cb_lock;	spinlock_t            rd_cmd_cb_lock;	spinlock_t            wr_cb_lock;	spinlock_t            rd_cb_lock;	spinlock_t            wr_cmd_lock;	wait_queue_head_t     wr_complete;	wait_queue_head_t     rd_complete;	wait_queue_head_t     msg_avaliable;	wait_queue_head_t     reg_complete;#if defined (HSI_LL_ENABLE_PM)	wait_queue_head_t     psv_event;#endif	struct task_struct   *rd_th;	struct task_struct   *wr_th;#if defined (HSI_LL_ENABLE_PM)	struct task_struct   *psv_th;#endif#if defined (HSI_LL_ENABLE_TX_RETRY_WQ)	struct workqueue_struct *hsi_tx_retry_wq;#endif#if defined (HSI_LL_ENABLE_TIMERS)	struct tasklet_struct timer_tasklet;#endif} ll_if_struct;static int hsi_ll_probe_cb(struct hsi_device *dev);static int hsi_ll_remove_cb(struct hsi_device *dev);static void hsi_ll_read_complete_cb(struct hsi_device *dev, unsigned int size);static void hsi_ll_write_complete_cb(struct hsi_device *dev, unsigned int size);static void hsi_ll_port_event_cb(struct hsi_device *dev, unsigned int event, void *arg);static void hsi_ll_read_cb(struct hsi_device *dev, unsigned int size);static void hsi_ll_write_cb(struct hsi_device *dev, unsigned int size);static void hsi_ll_start_tx_timer(unsigned int channel, unsigned int time_out);static void hsi_ll_start_rx_timer(unsigned int channel, unsigned int time_out);static void hsi_ll_stop_tx_timer(unsigned int channel);static void hsi_ll_stop_rx_timer(unsigned int channel);#if defined (HSI_LL_ENABLE_TIMERS)static void hsi_ll_tx_timer_cb(unsigned long channel);static void hsi_ll_rx_timer_cb(unsigned long channel);static void hsi_ll_stop_channel(unsigned int channel);#endifstatic int hsi_ll_rd_ctrl_ch_th(void *data);static int hsi_ll_wr_ctrl_ch_th(void *data);static void hsi_ll_wakeup_cp(unsigned int val);#if defined (HSI_LL_ENABLE_TX_RETRY_WQ)static void hsi_ll_retry_work(struct work_struct *work);#endif#endif