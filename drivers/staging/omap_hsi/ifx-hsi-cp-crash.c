#include <linux/irq.h>#include <linux/input.h>#include <linux/interrupt.h>#include <linux/rtc.h>#include <mach/gpio.h>#include <plat/lge_err_handler.h>#include <plat/lge_nvdata_handler.h>#include "hsi_driver.h"#include "xmd-ch.h"#include "xmd-hsi-ll-if.h"#define CP_CRASH_INT_N  			26static struct delayed_work	cp_crash_int_delayed_wq;#ifndef ENABLE_CP_CRASH_RESET#define EVENT_KEY 				KEY_F24static struct input_dev *in_dev = NULL;#endifstatic void CP_CRASH_wq_func(struct work_struct *cp_crash_wq);static irqreturn_t CP_CRASH_interrupt_handler(s32 irq, void *data);int IFX_CP_CRASH_DUMP_INIT(void){	int ret = 0;	ret = gpio_request(CP_CRASH_INT_N, "CP CRASH IRQ GPIO");	if (ret < 0) {		printk(KERN_INFO "[CP CRASH IRQ] GPIO#%03d is already occupied by other driver!\n", CP_CRASH_INT_N);		return -ENOSYS;	}	ret = gpio_direction_input(CP_CRASH_INT_N);	if (ret < 0) {		printk(KERN_INFO "[CP CRASH IRQ] GPIO#%03d direction initialization failed!\n", CP_CRASH_INT_N);		return -ENOSYS;	}	INIT_DELAYED_WORK(&cp_crash_int_delayed_wq, CP_CRASH_wq_func);	ret = request_irq(gpio_to_irq(CP_CRASH_INT_N), CP_CRASH_interrupt_handler, IRQF_TRIGGER_RISING, "cp_crash_irq", NULL);	if (ret < 0) {		printk(KERN_INFO "[CP CRASH IRQ] GPIO#%03d IRQ line set up failed!\n", CP_CRASH_INT_N);		free_irq(gpio_to_irq(CP_CRASH_INT_N), NULL);		return -ENOSYS;	}#ifndef ENABLE_CP_CRASH_RESET	in_dev = input_allocate_device();	if (!in_dev) {		printk("Can't allocate power button\n");		return -ENOMEM;	}	in_dev->evbit[0] = BIT_MASK(EV_KEY);	in_dev->keybit[BIT_WORD(EVENT_KEY)] = BIT_MASK(EVENT_KEY);	in_dev->name = "hsi";	in_dev->phys = "hsi/input0";	in_dev->dev.parent = NULL;	ret = input_register_device(in_dev);	if (ret) {		printk("Can't register EVENT_KEY button: %d\n", ret);	}#endif 	return ret;}static void CP_CRASH_wq_func(struct work_struct *cp_crash_wq){	int ret;	unsigned char data;	struct timespec ts;	struct rtc_time tm;	char* argv[] = {"/system/bin/ifx_coredump", "CP_CRASH_IRQ", NULL};	char *envp[] = { "HOME=/",	"PATH=/sbin:/bin:/system/bin",	NULL };		getnstimeofday(&ts);	rtc_time_to_tm(ts.tv_sec, &tm);	printk(KERN_INFO "[CP CRASH IRQ] CP_CRASH_wq_func()\n");		printk(KERN_INFO "(%d-%02d-%02d %02d:%02d:%02d.%09lu UTC)\n", tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,			tm.tm_hour, tm.tm_min, tm.tm_sec, ts.tv_nsec);		if(gpio_get_value(CP_CRASH_INT_N))	{		lge_store_ciq_reset(0, LGE_NVDATA_IQ_RESET_EXCEPTION);		lge_dynamic_nvdata_read(LGE_NVDATA_DYNAMIC_CP_CRASH_COUNT_OFFSET, &data, 1);		data++;		lge_dynamic_nvdata_write(LGE_NVDATA_DYNAMIC_CP_CRASH_COUNT_OFFSET, &data, 1);		if (lge_is_crash_dump_enabled() != 1)		{	#ifndef ENABLE_CP_CRASH_RESET				printk(" CP CRASH! immediate RIL/CP reset");			input_report_key(in_dev, EVENT_KEY, 1);			input_report_key(in_dev, EVENT_KEY, 0);			input_sync(in_dev);			printk("[CPW] input_report_key(): %d\n", EVENT_KEY);#endif			return;		}		hsi_ll_reset(HSI_LL_RESET_IFX_COREDUMP);		ret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);		printk(KERN_INFO "[CP CRASH IRQ] launch ifx_coredump process ret:%d\n", ret);		gpio_set_value(82, 1);	}	else	{#if 1			printk(KERN_INFO "[CP CRASH IRQ] CP_CRASH_wq_func() - CP_CRASH_INT_N - Invaild\n");#ifndef ENABLE_CP_CRASH_RESET			printk(" CP CRASH! immediate RIL/CP reset");		input_report_key(in_dev, EVENT_KEY, 1);		input_report_key(in_dev, EVENT_KEY, 0);		input_sync(in_dev);		printk("[CPW] input_report_key(): %d\n", EVENT_KEY);#endif#endif			}}void ifx_schedule_cp_dump_or_reset(void){	schedule_delayed_work( &cp_crash_int_delayed_wq, msecs_to_jiffies(500));}static irqreturn_t CP_CRASH_interrupt_handler(s32 irq, void *data){	ifx_schedule_cp_dump_or_reset();	return IRQ_HANDLED;}