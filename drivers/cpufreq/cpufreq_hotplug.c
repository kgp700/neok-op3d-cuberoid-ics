#include <linux/kernel.h>#include <linux/module.h>#include <linux/init.h>#include <linux/cpufreq.h>#include <linux/cpu.h>#include <linux/jiffies.h>#include <linux/kernel_stat.h>#include <linux/mutex.h>#include <linux/hrtimer.h>#include <linux/tick.h>#include <linux/ktime.h>#include <linux/sched.h>#include <linux/err.h>#include <linux/slab.h>#define DEFAULT_UP_FREQ_MIN_LOAD			(80)#define DEFAULT_DOWN_FREQ_MAX_LOAD			(20)#define DEFAULT_SAMPLING_PERIOD				(100000)#define DEFAULT_HOTPLUG_IN_SAMPLING_PERIODS		(5)#define DEFAULT_HOTPLUG_OUT_SAMPLING_PERIODS		(20)static void do_dbs_timer(struct work_struct *work);static int cpufreq_governor_dbs(struct cpufreq_policy *policy,		unsigned int event);#ifndef CONFIG_CPU_FREQ_DEFAULT_GOV_HOTPLUGstatic#endifstruct cpufreq_governor cpufreq_gov_hotplug = {       .name                   = "hotplug",       .governor               = cpufreq_governor_dbs,       .owner                  = THIS_MODULE,};struct cpu_dbs_info_s {	cputime64_t prev_cpu_idle;	cputime64_t prev_cpu_wall;	cputime64_t prev_cpu_nice;	struct cpufreq_policy *cur_policy;	struct delayed_work work;	struct cpufreq_frequency_table *freq_table;	int cpu;	struct mutex timer_mutex;};static DEFINE_PER_CPU(struct cpu_dbs_info_s, hp_cpu_dbs_info);static unsigned int dbs_enable;	static DEFINE_MUTEX(dbs_mutex);static struct workqueue_struct	*khotplug_wq;static struct dbs_tuners {	unsigned int sampling_rate;	unsigned int up_threshold;	unsigned int down_threshold;	unsigned int hotplug_in_sampling_periods;	unsigned int hotplug_out_sampling_periods;	unsigned int hotplug_load_index;	unsigned int *hotplug_load_history;	unsigned int ignore_nice;	unsigned int io_is_busy;} dbs_tuners_ins = {	.sampling_rate =		DEFAULT_SAMPLING_PERIOD,	.up_threshold =			DEFAULT_UP_FREQ_MIN_LOAD,	.down_threshold =		DEFAULT_DOWN_FREQ_MAX_LOAD,	.hotplug_in_sampling_periods =	DEFAULT_HOTPLUG_IN_SAMPLING_PERIODS,	.hotplug_out_sampling_periods =	DEFAULT_HOTPLUG_OUT_SAMPLING_PERIODS,	.hotplug_load_index =		0,	.ignore_nice =			0,	.io_is_busy =			0,};static inline cputime64_t get_cpu_idle_time(unsigned int cpu, cputime64_t *wall){        u64 idle_time;        u64 iowait_time;                idle_time = get_cpu_idle_time_us(cpu, wall);        if (dbs_tuners_ins.io_is_busy) {                iowait_time = get_cpu_iowait_time_us(cpu, wall);                                if (iowait_time != -1ULL && idle_time >= iowait_time)                        idle_time -= iowait_time;        }        return idle_time;}#define show_one(file_name, object)					\static ssize_t show_##file_name						\(struct kobject *kobj, struct attribute *attr, char *buf)		\{									\	return sprintf(buf, "%u\n", dbs_tuners_ins.object);		\}show_one(sampling_rate, sampling_rate);show_one(up_threshold, up_threshold);show_one(down_threshold, down_threshold);show_one(hotplug_in_sampling_periods, hotplug_in_sampling_periods);show_one(hotplug_out_sampling_periods, hotplug_out_sampling_periods);show_one(ignore_nice_load, ignore_nice);show_one(io_is_busy, io_is_busy);static ssize_t store_sampling_rate(struct kobject *a, struct attribute *b,				   const char *buf, size_t count){	unsigned int input;	int ret;	ret = sscanf(buf, "%u", &input);	if (ret != 1)		return -EINVAL;	mutex_lock(&dbs_mutex);	dbs_tuners_ins.sampling_rate = input;	mutex_unlock(&dbs_mutex);	return count;}static ssize_t store_up_threshold(struct kobject *a, struct attribute *b,				  const char *buf, size_t count){	unsigned int input;	int ret;	ret = sscanf(buf, "%u", &input);	if (ret != 1 || input <= dbs_tuners_ins.down_threshold) {		return -EINVAL;	}	mutex_lock(&dbs_mutex);	dbs_tuners_ins.up_threshold = input;	mutex_unlock(&dbs_mutex);	return count;}static ssize_t store_down_threshold(struct kobject *a, struct attribute *b,				  const char *buf, size_t count){	unsigned int input;	int ret;	ret = sscanf(buf, "%u", &input);	if (ret != 1 || input >= dbs_tuners_ins.up_threshold) {		return -EINVAL;	}	mutex_lock(&dbs_mutex);	dbs_tuners_ins.down_threshold = input;	mutex_unlock(&dbs_mutex);	return count;}static ssize_t store_hotplug_in_sampling_periods(struct kobject *a,		struct attribute *b, const char *buf, size_t count){	unsigned int input;	unsigned int *temp;	unsigned int max_windows;	int ret;	ret = sscanf(buf, "%u", &input);	if (ret != 1)		return -EINVAL;	if (input == dbs_tuners_ins.hotplug_in_sampling_periods)		return count;	mutex_lock(&dbs_mutex);	ret = count;	max_windows = max(dbs_tuners_ins.hotplug_in_sampling_periods,			dbs_tuners_ins.hotplug_out_sampling_periods);	if (input <= max_windows) {		dbs_tuners_ins.hotplug_in_sampling_periods = input;		goto out;	}	temp = kmalloc((sizeof(unsigned int) * input), GFP_KERNEL);	if (!temp || IS_ERR(temp)) {		ret = -ENOMEM;		goto out;	}	memcpy(temp, dbs_tuners_ins.hotplug_load_history,			(max_windows * sizeof(unsigned int)));	kfree(dbs_tuners_ins.hotplug_load_history);	dbs_tuners_ins.hotplug_load_history = temp;	dbs_tuners_ins.hotplug_in_sampling_periods = input;	dbs_tuners_ins.hotplug_load_index = max_windows;out:	mutex_unlock(&dbs_mutex);	return ret;}static ssize_t store_hotplug_out_sampling_periods(struct kobject *a,		struct attribute *b, const char *buf, size_t count){	unsigned int input;	unsigned int *temp;	unsigned int max_windows;	int ret;	ret = sscanf(buf, "%u", &input);	if (ret != 1)		return -EINVAL;	if (input == dbs_tuners_ins.hotplug_out_sampling_periods)		return count;	mutex_lock(&dbs_mutex);	ret = count;	max_windows = max(dbs_tuners_ins.hotplug_in_sampling_periods,			dbs_tuners_ins.hotplug_out_sampling_periods);	if (input <= max_windows) {		dbs_tuners_ins.hotplug_out_sampling_periods = input;		goto out;	}	temp = kmalloc((sizeof(unsigned int) * input), GFP_KERNEL);	if (!temp || IS_ERR(temp)) {		ret = -ENOMEM;		goto out;	}	memcpy(temp, dbs_tuners_ins.hotplug_load_history,			(max_windows * sizeof(unsigned int)));	kfree(dbs_tuners_ins.hotplug_load_history);	dbs_tuners_ins.hotplug_load_history = temp;	dbs_tuners_ins.hotplug_out_sampling_periods = input;	dbs_tuners_ins.hotplug_load_index = max_windows;out:	mutex_unlock(&dbs_mutex);	return ret;}static ssize_t store_ignore_nice_load(struct kobject *a, struct attribute *b,				      const char *buf, size_t count){	unsigned int input;	int ret;	unsigned int j;	ret = sscanf(buf, "%u", &input);	if (ret != 1)		return -EINVAL;	if (input > 1)		input = 1;	mutex_lock(&dbs_mutex);	if (input == dbs_tuners_ins.ignore_nice) { 		mutex_unlock(&dbs_mutex);		return count;	}	dbs_tuners_ins.ignore_nice = input;	for_each_online_cpu(j) {		struct cpu_dbs_info_s *dbs_info;		dbs_info = &per_cpu(hp_cpu_dbs_info, j);		dbs_info->prev_cpu_idle = get_cpu_idle_time(j,						&dbs_info->prev_cpu_wall);		if (dbs_tuners_ins.ignore_nice)			dbs_info->prev_cpu_nice = kstat_cpu(j).cpustat.nice;	}	mutex_unlock(&dbs_mutex);	return count;}static ssize_t store_io_is_busy(struct kobject *a, struct attribute *b,				   const char *buf, size_t count){	unsigned int input;	int ret;	ret = sscanf(buf, "%u", &input);	if (ret != 1)		return -EINVAL;	mutex_lock(&dbs_mutex);	dbs_tuners_ins.io_is_busy = !!input;	mutex_unlock(&dbs_mutex);	return count;}define_one_global_rw(sampling_rate);define_one_global_rw(up_threshold);define_one_global_rw(down_threshold);define_one_global_rw(hotplug_in_sampling_periods);define_one_global_rw(hotplug_out_sampling_periods);define_one_global_rw(ignore_nice_load);define_one_global_rw(io_is_busy);static struct attribute *dbs_attributes[] = {	&sampling_rate.attr,	&up_threshold.attr,	&down_threshold.attr,	&hotplug_in_sampling_periods.attr,	&hotplug_out_sampling_periods.attr,	&ignore_nice_load.attr,	&io_is_busy.attr,	NULL};static struct attribute_group dbs_attr_group = {	.attrs = dbs_attributes,	.name = "hotplug",};extern int cosmo_panel_suspend_flag;static void dbs_check_cpu(struct cpu_dbs_info_s *this_dbs_info){	extern bool in_dpll_cascading;	unsigned int total_load = 0;		unsigned int max_load = 0;		unsigned int avg_load = 0;		unsigned int hotplug_in_avg_load = 0;	unsigned int hotplug_out_avg_load = 0;		unsigned int periods;	struct cpufreq_policy *policy;	unsigned int index = 0;	unsigned int i, j;	static int overload_cnt = 0;		policy = this_dbs_info->cur_policy;	for_each_cpu(j, policy->cpus) {		unsigned int load;		unsigned int idle_time, wall_time;		cputime64_t cur_wall_time, cur_idle_time;		struct cpu_dbs_info_s *j_dbs_info;		j_dbs_info = &per_cpu(hp_cpu_dbs_info, j);		cur_idle_time = get_cpu_idle_time(j, &cur_wall_time);		wall_time = (unsigned int) cputime64_sub(cur_wall_time,				j_dbs_info->prev_cpu_wall);		j_dbs_info->prev_cpu_wall = cur_wall_time;		idle_time = (unsigned int) cputime64_sub(cur_idle_time,				j_dbs_info->prev_cpu_idle);		j_dbs_info->prev_cpu_idle = cur_idle_time;		if (unlikely(!wall_time || wall_time < idle_time))			continue;		load = 100 * (wall_time - idle_time) / wall_time;		total_load += load;		if (load > max_load)			max_load = load;	}	avg_load = total_load / num_online_cpus();	mutex_lock(&dbs_mutex);	periods = max(dbs_tuners_ins.hotplug_in_sampling_periods,			dbs_tuners_ins.hotplug_out_sampling_periods);	dbs_tuners_ins.hotplug_load_history[dbs_tuners_ins.hotplug_load_index]		= avg_load;	for (i = 0, j = dbs_tuners_ins.hotplug_load_index;			i < periods; i++, j--) {		if (i < dbs_tuners_ins.hotplug_in_sampling_periods)			hotplug_in_avg_load +=				dbs_tuners_ins.hotplug_load_history[j];		if (i < dbs_tuners_ins.hotplug_out_sampling_periods)			hotplug_out_avg_load +=				dbs_tuners_ins.hotplug_load_history[j];		if (j == 0)			j = periods;	}	hotplug_in_avg_load = hotplug_in_avg_load /		dbs_tuners_ins.hotplug_in_sampling_periods;	hotplug_out_avg_load = hotplug_out_avg_load /		dbs_tuners_ins.hotplug_out_sampling_periods;	if (++dbs_tuners_ins.hotplug_load_index == periods)		dbs_tuners_ins.hotplug_load_index = 0;#if 0	if (avg_load > dbs_tuners_ins.up_threshold) {				if (num_online_cpus() < 2 && hotplug_in_avg_load >				dbs_tuners_ins.up_threshold) {			cpu_up(1);			goto out;		}#else	if ((max_load > dbs_tuners_ins.up_threshold) || 		     (avg_load > dbs_tuners_ins.up_threshold)) {		if(in_dpll_cascading && overload_cnt < 2){				overload_cnt++;			goto out;		}		overload_cnt = 0;		if (!in_dpll_cascading && num_online_cpus() < 2 && hotplug_in_avg_load >				dbs_tuners_ins.up_threshold) {			cpu_up(1);			goto out;		}#endif		if (policy->cur < policy->max) {		mutex_lock(&this_dbs_info->timer_mutex);			__cpufreq_driver_target(policy, policy->max,					CPUFREQ_RELATION_H);			mutex_unlock(&this_dbs_info->timer_mutex);                 }		goto out;	}	overload_cnt = 0;	if (avg_load < dbs_tuners_ins.down_threshold) {				if (policy->cur == policy->min) {						if (num_online_cpus() > 1 && hotplug_out_avg_load < dbs_tuners_ins.down_threshold) {				#if 1 	 					cpu_down(1);				#endif			}			goto out;		}		if (cpufreq_frequency_table_next_lowest(policy,					this_dbs_info->freq_table, &index)) {			pr_err("%s: failed to get next lowest frequency\n",					__func__);			goto out;		}		mutex_lock(&this_dbs_info->timer_mutex);		__cpufreq_driver_target(policy,				this_dbs_info->freq_table[index].frequency,				CPUFREQ_RELATION_L);		mutex_unlock(&this_dbs_info->timer_mutex);	   	if (num_online_cpus() > 1 && in_dpll_cascading) {   			cpu_down(1);	   	}	}out:	mutex_unlock(&dbs_mutex);	return;}static void do_dbs_timer(struct work_struct *work){	struct cpu_dbs_info_s *dbs_info =		container_of(work, struct cpu_dbs_info_s, work.work);	unsigned int cpu = dbs_info->cpu;	int delay = usecs_to_jiffies(dbs_tuners_ins.sampling_rate);	delay -= jiffies % delay;	dbs_check_cpu(dbs_info);	queue_delayed_work_on(cpu, khotplug_wq, &dbs_info->work, delay);}static inline void dbs_timer_init(struct cpu_dbs_info_s *dbs_info){		int delay = usecs_to_jiffies(dbs_tuners_ins.sampling_rate);	delay -= jiffies % delay;	INIT_DELAYED_WORK_DEFERRABLE(&dbs_info->work, do_dbs_timer);	queue_delayed_work_on(dbs_info->cpu, khotplug_wq, &dbs_info->work,		delay);}static inline void dbs_timer_exit(struct cpu_dbs_info_s *dbs_info){	cancel_delayed_work_sync(&dbs_info->work);}static int cpufreq_governor_dbs(struct cpufreq_policy *policy,				   unsigned int event){	unsigned int cpu = policy->cpu;	struct cpu_dbs_info_s *this_dbs_info;	unsigned int i, j, max_periods;	int rc;	this_dbs_info = &per_cpu(hp_cpu_dbs_info, cpu);	switch (event) {	case CPUFREQ_GOV_START:		if ((!cpu_online(cpu)) || (!policy->cur))			return -EINVAL;		mutex_lock(&dbs_mutex);		dbs_enable++;		for_each_cpu(j, policy->cpus) {			struct cpu_dbs_info_s *j_dbs_info;			j_dbs_info = &per_cpu(hp_cpu_dbs_info, j);			j_dbs_info->cur_policy = policy;			j_dbs_info->prev_cpu_idle = get_cpu_idle_time(j,						&j_dbs_info->prev_cpu_wall);			if (dbs_tuners_ins.ignore_nice) {				j_dbs_info->prev_cpu_nice =						kstat_cpu(j).cpustat.nice;			}			max_periods = max(DEFAULT_HOTPLUG_IN_SAMPLING_PERIODS,					DEFAULT_HOTPLUG_OUT_SAMPLING_PERIODS);			dbs_tuners_ins.hotplug_load_history = kmalloc(					(sizeof(unsigned int) * max_periods),					GFP_KERNEL);			for (i = 0; i < max_periods; i++)				dbs_tuners_ins.hotplug_load_history[i] = 50;		}		this_dbs_info->cpu = cpu;		this_dbs_info->freq_table = cpufreq_frequency_get_table(cpu);		if (dbs_enable == 1) {			rc = sysfs_create_group(cpufreq_global_kobject,						&dbs_attr_group);			if (rc) {				mutex_unlock(&dbs_mutex);				return rc;			}		}		mutex_unlock(&dbs_mutex);		mutex_init(&this_dbs_info->timer_mutex);		dbs_timer_init(this_dbs_info);		break;	case CPUFREQ_GOV_STOP:		dbs_timer_exit(this_dbs_info);		mutex_lock(&dbs_mutex);		mutex_destroy(&this_dbs_info->timer_mutex);		dbs_enable--;		mutex_unlock(&dbs_mutex);		if (!dbs_enable)			sysfs_remove_group(cpufreq_global_kobject,					   &dbs_attr_group);		kfree(dbs_tuners_ins.hotplug_load_history);		break;	case CPUFREQ_GOV_LIMITS:		mutex_lock(&this_dbs_info->timer_mutex);		if (policy->max < this_dbs_info->cur_policy->cur)			__cpufreq_driver_target(this_dbs_info->cur_policy,				policy->max, CPUFREQ_RELATION_H);		else if (policy->min > this_dbs_info->cur_policy->cur)			__cpufreq_driver_target(this_dbs_info->cur_policy,				policy->min, CPUFREQ_RELATION_L);		mutex_unlock(&this_dbs_info->timer_mutex);		break;	}	return 0;}static int __init cpufreq_gov_dbs_init(void){	int err;	cputime64_t wall;	u64 idle_time;	int cpu = get_cpu();	idle_time = get_cpu_idle_time_us(cpu, &wall);	put_cpu();	if (idle_time != -1ULL) {		dbs_tuners_ins.up_threshold = DEFAULT_UP_FREQ_MIN_LOAD;	} else {		pr_err("cpufreq-hotplug: %s: assumes CONFIG_NO_HZ\n",				__func__);		return -EINVAL;	}	khotplug_wq = create_workqueue("khotplug");	if (!khotplug_wq) {		pr_err("Creation of khotplug failed\n");		return -EFAULT;	}	err = cpufreq_register_governor(&cpufreq_gov_hotplug);	if (err)		destroy_workqueue(khotplug_wq);	return err;}static void __exit cpufreq_gov_dbs_exit(void){	cpufreq_unregister_governor(&cpufreq_gov_hotplug);	destroy_workqueue(khotplug_wq);}MODULE_AUTHOR("Mike Turquette <mturquette@ti.com>");MODULE_DESCRIPTION("'cpufreq_hotplug' - cpufreq governor for dynamic frequency scaling and CPU hotplugging");MODULE_LICENSE("GPL");#ifdef CONFIG_CPU_FREQ_DEFAULT_GOV_HOTPLUGfs_initcall(cpufreq_gov_dbs_init);#elsemodule_init(cpufreq_gov_dbs_init);#endifmodule_exit(cpufreq_gov_dbs_exit);