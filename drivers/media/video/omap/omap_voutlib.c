#include <linux/module.h>#include <linux/errno.h>#include <linux/kernel.h>#include <linux/types.h>#include <linux/videodev2.h>#include <plat/cpu.h>MODULE_AUTHOR("Texas Instruments");MODULE_DESCRIPTION("OMAP Video library");MODULE_LICENSE("GPL");void omap_vout_default_crop(struct v4l2_pix_format *pix,		  struct v4l2_framebuffer *fbuf, struct v4l2_rect *crop){	crop->width = (pix->width < fbuf->fmt.width) ?		pix->width : fbuf->fmt.width;	crop->height = (pix->height < fbuf->fmt.height) ?		pix->height : fbuf->fmt.height;	crop->width &= ~1;	crop->height &= ~1;	crop->left = ((pix->width - crop->width) >> 1) & ~1;	crop->top = ((pix->height - crop->height) >> 1) & ~1;}EXPORT_SYMBOL_GPL(omap_vout_default_crop);int omap_vout_try_window(struct v4l2_framebuffer *fbuf,			struct v4l2_window *new_win){	struct v4l2_rect try_win;	try_win = new_win->w;	if (try_win.left < 0) {		try_win.width += try_win.left;		try_win.left = 0;	}	if (try_win.top < 0) {		try_win.height += try_win.top;		try_win.top = 0;	}	try_win.width = (try_win.width < fbuf->fmt.width) ?		try_win.width : fbuf->fmt.width;	try_win.height = (try_win.height < fbuf->fmt.height) ?		try_win.height : fbuf->fmt.height;	if (try_win.left + try_win.width > fbuf->fmt.width)		try_win.width = fbuf->fmt.width - try_win.left;	if (try_win.top + try_win.height > fbuf->fmt.height)		try_win.height = fbuf->fmt.height - try_win.top;	try_win.width &= ~1;	try_win.height &= ~1;	if (try_win.width <= 0 || try_win.height <= 0)		return -EINVAL;	new_win->w = try_win;	return 0;}EXPORT_SYMBOL_GPL(omap_vout_try_window);int omap_vout_new_window(struct v4l2_rect *crop,		struct v4l2_window *win, struct v4l2_framebuffer *fbuf,		struct v4l2_window *new_win){	int err;	win->w = new_win->w;	win->field = new_win->field;	win->chromakey = new_win->chromakey;	if (cpu_is_omap24xx()) {				if ((crop->height/win->w.height) >= 2)			crop->height = win->w.height * 2;		if ((crop->width/win->w.width) >= 2)			crop->width = win->w.width * 2;		if (crop->width > 768) {			if (crop->height != win->w.height)				crop->width = 768;		}	} else if (cpu_is_omap34xx()) {				if ((crop->height/win->w.height) >= 4)			crop->height = win->w.height * 4;		if ((crop->width/win->w.width) >= 4)			crop->width = win->w.width * 4;	}	return 0;}EXPORT_SYMBOL_GPL(omap_vout_new_window);int omap_vout_new_crop(struct v4l2_pix_format *pix,	      struct v4l2_rect *crop, struct v4l2_window *win,	      struct v4l2_framebuffer *fbuf, const struct v4l2_rect *new_crop){	struct v4l2_rect try_crop;	unsigned long vresize, hresize;	try_crop = *new_crop;	if (try_crop.left < 0) {		try_crop.width += try_crop.left;		try_crop.left = 0;	}	if (try_crop.top < 0) {		try_crop.height += try_crop.top;		try_crop.top = 0;	}	try_crop.width = (try_crop.width < pix->width) ?		try_crop.width : pix->width;	try_crop.height = (try_crop.height < pix->height) ?		try_crop.height : pix->height;	if (try_crop.left + try_crop.width > pix->width)		try_crop.width = pix->width - try_crop.left;	if (try_crop.top + try_crop.height > pix->height)		try_crop.height = pix->height - try_crop.top;	try_crop.width &= ~1;	try_crop.height &= ~1;	if (try_crop.width <= 0 || try_crop.height <= 0)		return -EINVAL;	if (win->w.width <= 0 || win->w.height <= 0)		return -EINVAL;	if (cpu_is_omap24xx()) {		if (crop->height != win->w.height) {			if (try_crop.width > 768)				try_crop.width = 768;		}	}		vresize = (1024 * crop->height) / win->w.height;	if (cpu_is_omap24xx() && (vresize > 2048))		vresize = 2048;	else if (cpu_is_omap34xx() && (vresize > 4096))		vresize = 4096;	if (win->w.height == 0)		win->w.height = 2;	if (win->w.height + win->w.top > fbuf->fmt.height) {		if (try_crop.height == 0)			try_crop.height = 2;	}		hresize = (1024 * crop->width) / win->w.width;	if (cpu_is_omap24xx() && (hresize > 2048))		hresize = 2048;	else if (cpu_is_omap34xx() && (hresize > 4096))		hresize = 4096;	if (win->w.width == 0)		win->w.width = 2;	if (win->w.width + win->w.left > fbuf->fmt.width) {		if (try_crop.width == 0)			try_crop.width = 2;	}	if (cpu_is_omap24xx()) {		if ((try_crop.height/win->w.height) >= 2)			try_crop.height = win->w.height * 2;		if ((try_crop.width/win->w.width) >= 2)			try_crop.width = win->w.width * 2;		if (try_crop.width > 768) {			if (try_crop.height != win->w.height)				try_crop.width = 768;		}	} else if (cpu_is_omap34xx()) {		if ((try_crop.height/win->w.height) >= 4)			try_crop.height = win->w.height * 4;		if ((try_crop.width/win->w.width) >= 4)			try_crop.width = win->w.width * 4;	}		*crop = try_crop;	return 0;}EXPORT_SYMBOL_GPL(omap_vout_new_crop);void omap_vout_new_format(struct v4l2_pix_format *pix,		struct v4l2_framebuffer *fbuf, struct v4l2_rect *crop,		struct v4l2_window *win){	omap_vout_default_crop(pix, fbuf, crop);	win->w.width = crop->width;	win->w.height = crop->height;	win->w.left = ((fbuf->fmt.width - win->w.width) >> 1) & ~1;	win->w.top = ((fbuf->fmt.height - win->w.height) >> 1) & ~1;}EXPORT_SYMBOL_GPL(omap_vout_new_format);