#include <linux/module.h>#include <linux/kernel.h>		#include <linux/init.h>			#include <linux/uaccess.h>		#include <linux/interrupt.h>	#include <linux/irq.h>			#include <linux/types.h>		#include <linux/syscalls.h>#include <asm/system.h>#include <asm/gpio.h>#include <linux/i2c.h>#include <linux/platform_device.h>#include <linux/device.h>#include <linux/delay.h>		#include <linux/proc_fs.h>#include <linux/workqueue.h>	#include <linux/wakelock.h>#include <linux/mutex.h>#include <linux/cosmo/cosmo_muic.h>#include <linux/cosmo/charger_rt9524.h>#include <plat/lge_nvdata_handler.h>static struct i2c_client *muic_client;static struct work_struct muic_wq;TYPE_USIF_MODE usif_mode = USIF_AP;TYPE_DP3T_MODE dp3t_mode = DP3T_NC;TYPE_MUIC_MODE muic_path = MUIC_NONE;TYPE_CHARGING_MODE charging_mode = CHARGING_NONE;TYPE_UPON_IRQ  upon_irq  = NOT_UPON_IRQ;static int retain_mode = NO_RETAIN;atomic_t muic_charger_detected;static int muic_chager_event = 0;const char *muic_path_str[] = {	"MUIC_UNKNOWN",				"MUIC_NONE",   				"MUIC_NA_TA",   			"MUIC_LG_TA",   			"MUIC_TA_1A", 	  			"MUIC_INVALID_CHG",  		"MUIC_AP_UART",   			"MUIC_CP_UART",				"MUIC_AP_USB", 				"MUIC_CP_USB",			};const char *charging_mode_str[] = {	"CHARGING_UNKNOWN",	"CHARGING_NONE",	"CHARGING_NA_TA",	"CHARGING_LG_TA",	"CHARGING_TA_1A",	"CHARGING_INVALID_CHG",	"CHARGING_USB",	"CHARGING_FACTORY",};void (*muic_init_device)(TYPE_RESET);s32 (*muic_detect_accessory)(s32);extern void muic_init_ts5usba33402(TYPE_RESET reset);extern void muic_init_max14526(TYPE_RESET reset);extern s32 muic_ts5usba33402_detect_accessory(s32 upon_irq);extern s32 muic_max14526_detect_accessory(s32 upon_irq);extern void ifx_fota_reset(void);static s32 muic_proc_set_ap_uart(void);static s32 muic_proc_set_cp_uart(void);static s32 muic_proc_set_ap_usb(void);static s32 muic_proc_set_cp_usb(void);#ifdef CONFIG_PROC_FS#define	MUIC_PATH_PROC_FILE "driver/cmuic"#define MUIC_INT_STAT_PROC_FILE "driver/muic_int_stat"static struct proc_dir_entry *muic_path_proc_file;static struct proc_dir_entry *muic_int_stat_proc_file;static ssize_t muic_path_read(struct file *filp, char *buf, size_t len, loff_t *offset){	s32 i;	u32 val;	for (i = 0; i <= 5; i++) {		val = i2c_smbus_read_byte_data(muic_client, (u8)i);		printk(KERN_INFO "[MUIC] reg 0x%02x, val = 0x%02x\n", i, val);	}	len = sprintf(buf, "%d\n", muic_path);	printk(KERN_INFO "[MUIC] mode = %s\n", muic_path_str[muic_path]);	return len;}static ssize_t muic_path_write(struct file *filp, const char *buf, size_t len, loff_t *off){	u8 cmd;	u8 dummy;	u8 nv_muic_retain_mode[1] = {0x00};	len = sscanf(buf, "%c %c", &cmd, &dummy);	printk(KERN_INFO "[MUIC] LGE: muic_proc_write, cmd = %c, dummy = %c len = %d\n", cmd, dummy, len);	switch (cmd) {	case '0' :		printk(KERN_INFO "[MUIC] CP usb download mode  \n");		muic_proc_set_cp_usb();		ifx_fota_reset();		retain_mode = NO_RETAIN;		muic_path = MUIC_CP_USB;		mdelay(2000);		printk(KERN_INFO "[MUIC] CP usb download mode  \n");		break;	case '1' :		retain_mode = NO_RETAIN;		nv_muic_retain_mode[0] = 0x00;		lge_dynamic_nvdata_write(LGE_NVDATA_DYNAMIC_MUIC_RETENTION_OFFSET, nv_muic_retain_mode, 1);		break;	case '2' :		muic_proc_set_ap_uart();		retain_mode = NO_RETAIN;		muic_path = MUIC_AP_UART;		break;	case '3' :		muic_proc_set_cp_uart();		retain_mode = NO_RETAIN;		muic_path = MUIC_CP_UART;		break;	case '4' :		muic_proc_set_ap_usb();		retain_mode = NO_RETAIN;		muic_path = MUIC_AP_USB;		break;	case '5' :		muic_proc_set_cp_usb();		retain_mode = NO_RETAIN;		muic_path = MUIC_CP_USB;		break;	case '6' :		muic_proc_set_ap_uart();		retain_mode = RETAIN;		muic_path = MUIC_AP_UART;		break;	case '7' :		muic_proc_set_cp_uart();		retain_mode = RETAIN;		muic_path = MUIC_CP_UART;		break;	case '8' :		muic_proc_set_ap_usb();		retain_mode = RETAIN;		muic_path = MUIC_AP_USB;		break;	case '9' :		muic_proc_set_cp_usb();		retain_mode = RETAIN;		muic_path = MUIC_CP_USB;		break;	case 'a' :				nv_muic_retain_mode[0] = 0x02;		lge_dynamic_nvdata_write(LGE_NVDATA_DYNAMIC_MUIC_RETENTION_OFFSET, nv_muic_retain_mode, 1);		break;	case 'b' :				nv_muic_retain_mode[0] = 0x03;		lge_dynamic_nvdata_write(LGE_NVDATA_DYNAMIC_MUIC_RETENTION_OFFSET, nv_muic_retain_mode, 1);		break;	default :			printk(KERN_INFO "[MUIC] LGE: Cosmo MUIC invalid command\n");			printk(KERN_INFO "[MUIC] 6: AP_UART, 7: CP_UART, 8: AP_USB, 9: CP_USB\n");			break;	}	check_charging_mode();	return len;}static ssize_t muic_int_stat_read(struct file *filp, char *buf, size_t len, loff_t *offset){	u32 value;	value = i2c_smbus_read_byte_data(muic_client, INT_STAT);	printk(KERN_INFO "[MUIC] INT_STAT = 0x%02x\n", value);		len = sprintf(buf, "%02x\n", 0xff & value);	return len;}static struct file_operations muic_path_ops = {	.read = muic_path_read,	.write = muic_path_write,};static struct file_operations muic_int_stat_ops = {	.read = muic_int_stat_read,	};static void create_cosmo_muic_proc_file(void){	muic_path_proc_file = create_proc_entry(MUIC_PATH_PROC_FILE, 0666, NULL);	muic_int_stat_proc_file = create_proc_entry(MUIC_INT_STAT_PROC_FILE, 0666, NULL);		if (muic_path_proc_file) {#if 0 		cosmo_muic_proc_file->owner = THIS_MODULE;#endif		muic_path_proc_file->proc_fops = &muic_path_ops;	} else		printk(KERN_INFO "[MUIC] Cosmo MUIC path proc file create failed!\n");	if (muic_int_stat_proc_file)		muic_int_stat_proc_file->proc_fops = &muic_int_stat_ops;			else		printk(KERN_INFO "[MUIC] Cosmo MUIC int_stat proc file create failed!\n");		}static void remove_cosmo_muic_proc_file(void){	remove_proc_entry(MUIC_PATH_PROC_FILE, NULL);	remove_proc_entry(MUIC_INT_STAT_PROC_FILE, NULL);}#endif void check_charging_mode(void){	s32 value;	value = i2c_smbus_read_byte_data(muic_client, INT_STAT);	if (value & VBUS) {		if ((value & IDNO) == IDNO_0010 || 			(value & IDNO) == IDNO_0100 ||			(value & IDNO) == IDNO_1001 ||			(value & IDNO) == IDNO_1010)			charging_mode = CHARGING_FACTORY;		else if (value & CHGDET) 			charging_mode = CHARGING_LG_TA;		else			charging_mode = CHARGING_USB;	} else		charging_mode = CHARGING_NONE;	set_muic_charger_detected();}EXPORT_SYMBOL(check_charging_mode);void muic_mdelay(u32 microsec){	do {		udelay(1000);	} while (microsec--);}EXPORT_SYMBOL(muic_mdelay);TYPE_MUIC_MODE get_muic_mode(void){	return charging_mode;}EXPORT_SYMBOL(get_muic_mode);void set_muic_mode(u32 mode){	switch (mode) {	case MUIC_AP_UART:			muic_proc_set_ap_uart();		break;	case MUIC_CP_UART:			muic_proc_set_cp_uart();		break;	case MUIC_AP_USB:			muic_proc_set_ap_usb();		break;	case MUIC_CP_USB:			muic_proc_set_cp_usb();		break;	default :		break;	}	check_charging_mode();}EXPORT_SYMBOL(set_muic_mode);#if 0 int get_muic_charger_detected(void){	printk(KERN_WARNING "[MUIC] LGE: get_muic_charger_detected\n");#if 1	if (muic_chager_event ) {		muic_chager_event = 0;		return 1;	}#else	if (muic_charger_detected.counter) {		atomic_set(&muic_charger_detected,0);		return 1;	}#endif	return 0;}EXPORT_SYMBOL(get_muic_charger_detected);#endifvoid set_muic_charger_detected(void){#if 0 	printk(KERN_WARNING "[MUIC] LGE: set_muic_charger_detected\n");	muic_chager_event = 1;	#endif	charger_fsm(CHARG_FSM_CAUSE_ANY);}EXPORT_SYMBOL(set_muic_charger_detected);s32 muic_i2c_read_byte(u8 addr, u8 *value){	s32 ret;	ret = i2c_smbus_read_byte_data(muic_client, (u8)addr);	if (ret < 0) {		printk("[MUIC] muic_i2c_read_byte failed.\n");		return ret;	} else {		*value = (u8)ret;		return 0;	}}EXPORT_SYMBOL(muic_i2c_read_byte);s32 muic_i2c_write_byte(u8 addr, u8 value){	s32 ret;	ret = i2c_smbus_write_byte_data(muic_client, (u8)addr, (u8)value);	if (ret < 0)		printk(KERN_INFO "[MUIC] muic_i2c_write_byte failed.\n");	return ret;}EXPORT_SYMBOL(muic_i2c_write_byte);void usif_switch_ctrl(TYPE_USIF_MODE mode){	if (mode == USIF_AP) {		gpio_set_value(USIF_IN_1_GPIO, 0);		printk(KERN_INFO "[MUIC] usif_switch_ctrl, CP UART is connected to AP\n");	} else if (mode == USIF_DP3T) {		gpio_set_value(USIF_IN_1_GPIO, 1);		printk(KERN_INFO "[MUIC] usif_switch_ctrl, CP UART is connected to DP3T (then, MUIC)\n");	} else {			}	usif_mode = mode;	}EXPORT_SYMBOL(usif_switch_ctrl);void dp3t_switch_ctrl(TYPE_DP3T_MODE mode){	if (mode == DP3T_AP_UART) {		gpio_set_value(IFX_USB_VBUS_EN_GPIO, 0);		gpio_set_value(DP3T_IN_1_GPIO, 1);		gpio_set_value(DP3T_IN_2_GPIO, 0);		printk(KERN_INFO "[MUIC] dp3t_switch_ctrl, AP UART is connected to MUIC UART\n");	} else if (mode == DP3T_CP_UART) {		gpio_set_value(IFX_USB_VBUS_EN_GPIO, 0);		gpio_set_value(DP3T_IN_1_GPIO, 0);		gpio_set_value(DP3T_IN_2_GPIO, 1);		printk(KERN_INFO "[MUIC] dp3t_switch_ctrl, CP UART is connected to MUIC UART\n");	} else if (mode == DP3T_CP_USB) {		gpio_set_value(IFX_USB_VBUS_EN_GPIO, 1);		gpio_set_value(DP3T_IN_1_GPIO, 1);		gpio_set_value(DP3T_IN_2_GPIO, 1);		printk(KERN_INFO "[MUIC] dp3t_switch_ctrl, CP USB is connected to MUIC UART\n");	} else if (mode == DP3T_NC) {		gpio_set_value(IFX_USB_VBUS_EN_GPIO, 0);		gpio_set_value(DP3T_IN_1_GPIO, 0);		gpio_set_value(DP3T_IN_2_GPIO, 0);		printk(KERN_INFO "[MUIC] dp3t_switch_ctrl, None is connected to MUIC UART\n");	} else {			}	dp3t_mode = mode;	}EXPORT_SYMBOL(dp3t_switch_ctrl);static s32 muic_proc_set_ap_uart(void){	s32 ret;	usif_switch_ctrl(USIF_AP);	dp3t_switch_ctrl(DP3T_AP_UART);	ret = muic_i2c_write_byte(SW_CONTROL, DP_UART | DM_UART);	muic_path = MUIC_AP_UART;	charging_mode = CHARGING_UNKNOWN;	printk("[MUIC] muic_proc_set_ap_uart(): AP_UART\n");	return ret;}static s32 muic_proc_set_ap_usb(void){	s32 ret;	ret = muic_i2c_write_byte(SW_CONTROL, OPEN);	dp3t_switch_ctrl(DP3T_NC);	muic_mdelay(100);	usif_switch_ctrl(USIF_AP);	dp3t_switch_ctrl(DP3T_AP_UART);	ret = muic_i2c_write_byte(SW_CONTROL, DP_USB | DM_USB);	muic_path = MUIC_AP_USB;	charging_mode = CHARGING_USB;	printk("[MUIC] muic_proc_set_ap_usb(): AP_USB\n");	return ret;}static s32 muic_proc_set_cp_uart(void){	s32 ret;	usif_switch_ctrl(USIF_DP3T);	dp3t_switch_ctrl(DP3T_CP_UART);	ret = muic_i2c_write_byte(SW_CONTROL, DP_UART | DM_UART);	muic_path = MUIC_CP_UART;	charging_mode = CHARGING_UNKNOWN;	printk("[MUIC] muic_proc_set_cp_uart(): CP_UART\n");	return ret;}static s32 muic_proc_set_cp_usb(void){	s32 ret;	ret = muic_i2c_write_byte(SW_CONTROL, OPEN);	dp3t_switch_ctrl(DP3T_NC);	muic_mdelay(100);	usif_switch_ctrl(USIF_AP);	dp3t_switch_ctrl(DP3T_CP_USB);	ret = muic_i2c_write_byte(SW_CONTROL, DP_UART | DM_UART);	muic_path = MUIC_CP_USB;	charging_mode = CHARGING_USB;	printk("[MUIC] muic_proc_set_cp_usb(): CP_USB\n");	return ret;}static void muic_detect_device(void){	s32 ret;	u8 muic_device;	printk(KERN_INFO "[MUIC] muic_detect_device()\n");	ret = muic_i2c_read_byte(DEVICE_ID, &muic_device);	if ((muic_device & 0xf0) == TS5USBA33402)		muic_device = TS5USBA33402;	else if ((muic_device & 0xf0) == MAX14526)		muic_device = MAX14526;	else if ((muic_device & 0xf0) == ANY_VENDOR)		muic_device = ANY_VENDOR;	if (muic_device == TS5USBA33402) {		muic_init_device = muic_init_ts5usba33402;		muic_detect_accessory = muic_ts5usba33402_detect_accessory;		printk(KERN_INFO "[MUIC] muic chip : TS5USBA33402\n");	} else if (muic_device == MAX14526) {		muic_init_device = muic_init_max14526;		muic_detect_accessory = muic_max14526_detect_accessory;		printk(KERN_INFO "[MUIC] muic chip : MAX14526\n");	} else {		printk(KERN_INFO "ANY VENDOR\n");	}}static void muic_wq_func(struct work_struct *muic_wq){	s32 ret = 0;	printk(KERN_INFO "[MUIC] muic_wq_func()\n");	if (retain_mode == NO_RETAIN) {		ret = muic_detect_accessory(UPON_IRQ);		printk(KERN_INFO "[MUIC] muic_detect_accessory(UPON_IRQ)detedted!!!!\n");		set_muic_charger_detected();		} else {		muic_mdelay(250);		ret = i2c_smbus_read_byte_data(muic_client, INT_STAT);		if (muic_path == MUIC_CP_USB)			muic_proc_set_cp_usb();		check_charging_mode();		set_muic_charger_detected();			printk(KERN_INFO "[MUIC] Now...path retain mode,  muic_path = %s, charing = %s\n", 		   	   muic_path_str[muic_path], charging_mode_str[charging_mode]);	}}static irqreturn_t muic_interrupt_handler(s32 irq, void *data){		schedule_work(&muic_wq);	return IRQ_HANDLED;}static s32 __init muic_probe(struct i2c_client *client, const struct i2c_device_id *id){	s32 ret = 0;	muic_client = client;	ret = gpio_request(USIF_IN_1_GPIO, "USIF switch control GPIO");	if (ret < 0) {		printk(KERN_INFO "[MUIC] GPIO 165 USIF1_SW is already occupied by other driver!\n");		return -ENOSYS;	}	ret = gpio_direction_output(USIF_IN_1_GPIO, 0);	if (ret < 0) {		printk(KERN_INFO "[MUIC] gpio_16 USIF_IN_1_GPIO direction initialization failed!\n");		return -ENOSYS;	}	ret = gpio_request(DP3T_IN_1_GPIO, "DP3T switch control 1 GPIO");	if (ret < 0) {		printk(KERN_INFO "[MUIC] GPIO 11 DP3T_IN_1_GPIO is already occupied by other driver!\n");		return -ENOSYS;	}	ret = gpio_direction_output(DP3T_IN_1_GPIO, 0);	if (ret < 0) {		printk(KERN_INFO "[MUIC] gpio_11 DP3T_IN_1_GPIO direction initialization failed!\n");		return -ENOSYS;	}	ret = gpio_request(DP3T_IN_2_GPIO, "DP3T switch control 2 GPIO");	if (ret < 0) {		printk(KERN_INFO "[MUIC] gpio_12 DP3T_IN_2_GPIO is already occupied by other driver!\n");		return -ENOSYS;	}	ret = gpio_direction_output(DP3T_IN_2_GPIO, 0);	if (ret < 0) {		printk(KERN_INFO "[MUIC] gpio_12 DP3T_IN_2_GPIO direction initialization failed!\n");		return -ENOSYS;	}	ret = gpio_request(IFX_USB_VBUS_EN_GPIO, "DP3T switch control 2 GPIO");	if (ret < 0) {		printk(KERN_INFO "[MUIC] gpio_55 IFX_USB_VBUS_EN_GPIO is already occupied by other driver!\n");		return -ENOSYS;	}	ret = gpio_direction_output(IFX_USB_VBUS_EN_GPIO, 0);	if (ret < 0) {		printk(KERN_INFO "[MUIC] gpio_55 IFX_USB_VBUS_EN_GPIO direction initialization failed!\n");		return -ENOSYS;	}	ret = gpio_request(MUIC_INT, "MUIC IRQ GPIO");	if (ret < 0) {		printk(KERN_INFO "[MUIC] gpiio_wk8 MUIC_INT_N is already occupied by other driver!\n");		return -ENOSYS;	}	ret = gpio_direction_input(MUIC_INT);	if (ret < 0) {		printk(KERN_INFO "[MUIC] gpio_wk8 MUIC_INT_N direction initialization failed!\n");		return -ENOSYS;	}	INIT_WORK(&muic_wq, muic_wq_func);	ret = request_irq(gpio_to_irq(MUIC_INT), muic_interrupt_handler, IRQF_TRIGGER_FALLING, "muic_irq", &client->dev);	if (ret < 0) {		printk(KERN_INFO "[MUIC] gpio_wk7 MUIC_INT_N IRQ line set up failed!\n");		free_irq(gpio_to_irq(MUIC_INT), &client->dev);		return -ENOSYS;	}	create_cosmo_muic_proc_file();	muic_detect_device();	if (retain_mode == BOOT_FIRST) {		muic_proc_set_cp_uart();		muic_init_device(DEFAULT);		check_charging_mode();		printk("[MUIC] muic_init_device... first boot\n");	} else if (retain_mode == BOOT_AP_USB) {		muic_path = MUIC_AP_USB;		muic_init_device(DEFAULT);		check_charging_mode();		printk("[MUIC] muic_init_device... retain mode = AP_USB\n");	} else if (retain_mode == BOOT_CP_USB) {		muic_proc_set_cp_usb();		muic_path = MUIC_CP_USB;		muic_init_device(DEFAULT);		check_charging_mode();		printk("[MUIC] muic_detect_accessory... retain mode = CP_USB\n");	} else {		if (muic_init_device)			muic_init_device(DEFAULT);		else			printk("[MUIC] You should add codes for new MUIC chip");		if (muic_detect_accessory)			muic_detect_accessory(NOT_UPON_IRQ);		else			printk("[muic] You should add codes for new MUIC chip");	}	set_muic_charger_detected();	ret = enable_irq_wake(gpio_to_irq(MUIC_INT));	if (ret < 0) {		printk(KERN_INFO "[MUIC] GPIO 40 MUIC_INT_N wake up source setting failed!\n");		disable_irq_wake(gpio_to_irq(MUIC_INT));		return -ENOSYS;	}	printk(KERN_WARNING "[MUIC] muic_probe()\n");	return ret;}static s32 muic_remove(struct i2c_client *client){	free_irq(gpio_to_irq(MUIC_INT), &client->dev);	gpio_free(MUIC_INT);	gpio_free(USIF_IN_1_GPIO);	gpio_free(DP3T_IN_1_GPIO);	gpio_free(DP3T_IN_2_GPIO);	i2c_set_clientdata(client, NULL);		remove_cosmo_muic_proc_file();	return 0;}static s32 muic_suspend(struct i2c_client *client, pm_message_t state){	client->dev.power.power_state = state;	return 0;}static s32 muic_resume(struct i2c_client *client){	client->dev.power.power_state = PMSG_ON;	return 0;}static const struct i2c_device_id muic_ids[] = {	{"max14526" , 0},	{},};int fota_ebl_download(void){   return 0;}static int __init muic_state(char *str){	int initial_path = simple_strtol(str, NULL, 0);	if (initial_path == 1)		retain_mode = BOOT_FIRST;	else if (initial_path == 2)		retain_mode = BOOT_AP_USB;	else if (initial_path == 3)		retain_mode = BOOT_CP_USB;	else		printk("[MUIC] no retain\n");	printk("[MUIC] muic_state = %d\n", retain_mode);	return 1;}__setup("muic=", muic_state);static struct i2c_driver muic_driver = {	.probe	 	= muic_probe,	.remove	 	= muic_remove,	.suspend 	= muic_suspend,	.resume  	= muic_resume,	.id_table	= muic_ids,	.driver	 	= {		.name       = "max14526",	 		.owner      = THIS_MODULE,	},};static s32 __init muic_init(void){    printk(KERN_WARNING "[MUIC] muic_init()\n");	return i2c_add_driver(&muic_driver);}static void __exit muic_exit(void){	i2c_del_driver(&muic_driver);}module_init(muic_init);module_exit(muic_exit);MODULE_AUTHOR("LG Electronics");MODULE_DESCRIPTION("Cosmo MUIC Driver");MODULE_LICENSE("GPL");