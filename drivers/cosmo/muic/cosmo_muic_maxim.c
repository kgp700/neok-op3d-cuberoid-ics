#include <linux/module.h>#include <linux/kernel.h>		#include <linux/init.h>			#include <linux/uaccess.h>		#include <linux/interrupt.h>	#include <linux/irq.h>			#include <linux/types.h>		#include <asm/system.h>#include <asm/gpio.h>#include <linux/i2c.h>#include <linux/platform_device.h>#include <linux/device.h>#include <linux/delay.h>		#include <linux/proc_fs.h>#include <linux/workqueue.h>	#include <linux/wakelock.h>#include <linux/cosmo/cosmo_muic.h>#include <linux/cosmo/charger_rt9524.h>void muic_init_max14526(TYPE_RESET reset){	printk(KERN_WARNING "[MUIC] max14526_init()\n");	atomic_set(&muic_charger_detected, 0); 		if (reset == RESET) {				muic_i2c_write_byte(SW_CONTROL, COMP2_TO_HZ | COMN1_TO_HZ); 	}	muic_i2c_write_byte(CONTROL_1, ID_200 | ADC_EN | CP_EN);	muic_i2c_write_byte(CONTROL_2, INT_EN);}EXPORT_SYMBOL(muic_init_max14526);void set_max14526_ap_uart_mode(void) {	printk(KERN_WARNING "[MUIC] set_max14526_ap_uart_mode\n" );	usif_switch_ctrl(USIF_AP);	dp3t_switch_ctrl(DP3T_AP_UART);	muic_i2c_write_byte(CONTROL_1, ID_200 | ADC_EN | CP_EN);	muic_i2c_write_byte(SW_CONTROL, COMP2_TO_U2 | COMN1_TO_U1);}void set_max14526_ap_usb_mode(void){	printk(KERN_WARNING "[MUIC] set_max14526_ap_usb_mode\n" );		usif_switch_ctrl(USIF_AP);	dp3t_switch_ctrl(DP3T_CP_UART);	muic_i2c_write_byte(SW_CONTROL, COMP2_TO_DP2 | COMN1_TO_DN1);	muic_i2c_write_byte(CONTROL_1, ID_200 | ADC_EN | CP_EN);}void set_max14526_cp_uart_mode(void) {	printk(KERN_WARNING "[MUIC] set_max14526_cp_uart_mode\n" );	usif_switch_ctrl(USIF_DP3T);	dp3t_switch_ctrl(DP3T_CP_UART);	muic_i2c_write_byte(CONTROL_1, ID_200 | ADC_EN | CP_EN);	muic_i2c_write_byte(SW_CONTROL, COMP2_TO_U2 | COMN1_TO_U1);}void set_max14526_cp_usb_mode(void) {	printk(KERN_WARNING "[MUIC] set_max14526_cp_usb_mode\n" );	usif_switch_ctrl(USIF_AP);	dp3t_switch_ctrl(DP3T_CP_USB);	muic_i2c_write_byte(CONTROL_1, ID_200 | ADC_EN | CP_EN);	muic_i2c_write_byte(SW_CONTROL, COMP2_TO_U2 | COMN1_TO_U1);}void set_max14526_charger_mode(unsigned char int_stat_value){	unsigned char reg_value;	printk(KERN_WARNING "[MUIC] set_max14526_charger_mode, int_stat_value = 0x%02x\n", int_stat_value);	if (((int_stat_value & IDNO) == IDNO_0101) || ((int_stat_value & IDNO) == IDNO_1011)) {				muic_path = MUIC_LG_TA;	} else if ((int_stat_value & IDNO) == IDNO_0110) {				muic_path = MUIC_TA_1A;	} else {				muic_i2c_write_byte(CONTROL_2, INT_EN | CHG_TYPE);		muic_i2c_read_byte(INT_STAT, &reg_value);		muic_i2c_read_byte(STATUS, &reg_value);		if (reg_value & DCPORT) {						muic_path = MUIC_NA_TA;		} else if (reg_value & CHPORT) {			set_max14526_ap_usb_mode();		}	}}void set_max14526_muic_path(unsigned char int_stat_value){	unsigned char reg_value;		printk(KERN_WARNING "[MUIC] set_max14526_muic_path, int_stat_value = 0x%02x \n", int_stat_value);	if (int_stat_value & VBUS) {		if ((int_stat_value & IDNO) == IDNO_0010 || 			(int_stat_value & IDNO) == IDNO_1001 ||			(int_stat_value & IDNO) == IDNO_1010) {			set_max14526_cp_usb_mode();			muic_path = MUIC_CP_USB;			charging_mode = CHARGING_FACTORY;		} else if ((int_stat_value & IDNO) == IDNO_0100) {			set_max14526_cp_uart_mode();			muic_path = MUIC_CP_UART;			charging_mode = CHARGING_FACTORY;		} else if (int_stat_value & CHGDET) {			muic_i2c_write_byte(SW_CONTROL, COMP2_TO_HZ | COMN1_TO_HZ);			muic_path = MUIC_LG_TA;			charging_mode = CHARGING_LG_TA;		} else {			muic_i2c_write_byte(SW_CONTROL, COMP2_TO_HZ | COMN1_TO_C1COMP);			muic_mdelay(2);			muic_i2c_read_byte(STATUS, &reg_value);			if (reg_value & C1COMP) {				muic_i2c_write_byte(SW_CONTROL, COMP2_TO_HZ | COMN1_TO_HZ);				muic_path = MUIC_LG_TA;				charging_mode = CHARGING_LG_TA;			} else {				set_max14526_ap_usb_mode();				muic_path = MUIC_AP_USB;				charging_mode = CHARGING_USB;			}		}	} else {		if ((int_stat_value & IDNO) == IDNO_0010) {			set_max14526_ap_uart_mode();			muic_path = MUIC_AP_UART;			charging_mode = CHARGING_NONE;		} else if ((int_stat_value & IDNO) == IDNO_0100) {			set_max14526_cp_uart_mode();			muic_path = MUIC_CP_UART;			charging_mode = CHARGING_NONE;		} else {			muic_path = MUIC_UNKNOWN;			charging_mode = CHARGING_NONE;		}	}}s32 muic_max14526_detect_accessory(s32 upon_irq){	s32 ret = 0;	u8 int_stat_value;	muic_mdelay(250);	ret = muic_i2c_read_byte(INT_STAT, &int_stat_value);	printk(KERN_WARNING "[MUIC] muic_max14526_detect_accessory, int_stat_value = 0x%02x \n", int_stat_value);		if (ret < 0) {		printk(KERN_INFO "[MUIC] INT_STAT reading failed\n");		muic_path = MUIC_UNKNOWN;		charging_mode = CHARGING_UNKNOWN;		return ret;	}	    	switch (muic_path) {	case MUIC_UNKNOWN :	case MUIC_NONE :		set_max14526_muic_path(int_stat_value);           		break;	case MUIC_NA_TA:	case MUIC_TA_1A:	case MUIC_INVALID_CHG :	case MUIC_LG_TA :	case MUIC_AP_UART :	case MUIC_CP_UART :	case MUIC_AP_USB :	case MUIC_CP_USB :		if ((int_stat_value & VBUS) != 0) {			set_max14526_muic_path(int_stat_value);		} else if ((int_stat_value & IDNO) == IDNO_1011) {			charging_mode = CHARGING_NONE;			muic_path = MUIC_NONE;		} else			set_max14526_muic_path(int_stat_value);		break;			default :		printk(KERN_WARNING "[MUIC] Failed to detect an accessory. Try again!");		muic_path = MUIC_UNKNOWN;		charging_mode = CHARGING_UNKNOWN;		ret = -1;	}			printk(KERN_WARNING "[MUIC] muic_max14526_detect_accessory, muic_path = %s, charing = %s\n", 		   muic_path_str[muic_path], charging_mode_str[charging_mode]);	if (muic_path == MUIC_UNKNOWN || muic_path == MUIC_NONE) {		muic_init_max14526(RESET);		gpio_set_value(IFX_USB_VBUS_EN_GPIO, 0);        printk(KERN_INFO "[MUIC] charging_ic_deactive()\n");    }	return ret;}EXPORT_SYMBOL(muic_max14526_detect_accessory);