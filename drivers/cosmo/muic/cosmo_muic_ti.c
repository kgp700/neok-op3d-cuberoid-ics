#include <linux/module.h>#include <linux/kernel.h>		#include <linux/init.h>			#include <linux/uaccess.h>		#include <linux/interrupt.h>	#include <linux/irq.h>			#include <linux/types.h>		#include <asm/system.h>  #include <asm/gpio.h>#include <linux/i2c.h>#include <linux/platform_device.h>#include <linux/device.h>#include <linux/delay.h>		#include <linux/proc_fs.h>#include <linux/workqueue.h>	#include <linux/wakelock.h> #include <linux/cosmo/cosmo_muic.h>#include <linux/cosmo/charger_rt9524.h>void muic_init_ts5usba33402(TYPE_RESET reset){	printk(KERN_INFO "[MUIC] muic_init_ts5usba33402()\n");	if (reset == RESET) {				muic_i2c_write_byte(SW_CONTROL, COMP2_TO_HZ | COMN1_TO_HZ); 	}  		muic_i2c_write_byte(CONTROL_1, ID_200 | SEMREN | CP_EN);	muic_i2c_write_byte(CONTROL_2, INT_EN);	return;}EXPORT_SYMBOL(muic_init_ts5usba33402);void set_ts5usba33402_cp_uart_mode(void){		usif_switch_ctrl(USIF_DP3T);	dp3t_switch_ctrl(DP3T_CP_UART);  	muic_i2c_write_byte(CONTROL_1, ID_200 | SEMREN | CP_EN);    	  	muic_i2c_write_byte(SW_CONTROL, COMP2_TO_U2 | COMN1_TO_U1);}void set_ts5usba33402_ap_uart_mode(void){ 		usif_switch_ctrl(USIF_AP);	dp3t_switch_ctrl(DP3T_AP_UART);  	   	muic_i2c_write_byte(CONTROL_1, ID_200 | SEMREN | CP_EN);  		muic_i2c_write_byte(SW_CONTROL, COMP2_TO_U2 | COMN1_TO_U1);}void set_ts5usba33402_ap_usb_mode(void){		usif_switch_ctrl(USIF_AP);	dp3t_switch_ctrl(DP3T_AP_UART);    muic_i2c_write_byte(SW_CONTROL, COMP2_TO_DP2 | COMN1_TO_DN1);   	   	muic_i2c_write_byte(CONTROL_1, ID_200 | SEMREN | CP_EN);  }void set_ts5usba33402_cp_usb_mode(void) {		usif_switch_ctrl(USIF_AP);	dp3t_switch_ctrl(DP3T_CP_USB);	muic_i2c_write_byte(CONTROL_1, ID_200 | SEMREN | CP_EN);	muic_i2c_write_byte(SW_CONTROL, COMP2_TO_U2 | COMN1_TO_U1);}void set_ts5usba33402_charger_mode(unsigned char int_stat_value){	s32 ret = 0;  	unsigned char reg_value;  	  	if (((int_stat_value & IDNO) == IDNO_0101) || ((int_stat_value & IDNO) == IDNO_1011)) {    	       	muic_path = MUIC_LG_TA;	} else if ((int_stat_value & IDNO) == IDNO_0110) {				muic_path = MUIC_TA_1A;	} else {	    	    muic_i2c_write_byte(CONTROL_2, INT_EN | CHG_TYPE);	    muic_mdelay(2);	    	    ret = muic_i2c_read_byte(INT_STAT, &reg_value);	    ret = muic_i2c_read_byte(STATUS, &reg_value);	    if (reg_value & DCPORT) { 	    	muic_path = MUIC_NA_TA;	    } else			set_ts5usba33402_ap_usb_mode();		  	}}void set_ts5usba33402_muic_path(unsigned char int_stat_value){	if (int_stat_value & VBUS) {		if ((int_stat_value & IDNO) == IDNO_0010 || 			(int_stat_value & IDNO) == IDNO_1001 ||			(int_stat_value & IDNO) == IDNO_1010) {			set_ts5usba33402_cp_usb_mode();			muic_path = MUIC_CP_USB;			charging_mode = CHARGING_FACTORY;		} else if ((int_stat_value & IDNO) == IDNO_0100) {			set_ts5usba33402_cp_uart_mode();			muic_path = MUIC_CP_UART;			charging_mode = CHARGING_FACTORY;		} else if (int_stat_value & CHGDET) {			muic_i2c_write_byte(SW_CONTROL, COMP2_TO_HZ | COMN1_TO_HZ);			muic_path = MUIC_LG_TA;			charging_mode = CHARGING_LG_TA;		} else {			set_ts5usba33402_ap_usb_mode();			muic_path = MUIC_AP_USB;			charging_mode = CHARGING_USB;		}	} else {		if ((int_stat_value & IDNO) == IDNO_0010) {			set_ts5usba33402_ap_uart_mode();			muic_path = MUIC_AP_UART;			charging_mode = CHARGING_NONE;		} else if ((int_stat_value & IDNO) == IDNO_0100) {			set_ts5usba33402_cp_uart_mode();			muic_path = MUIC_CP_UART;			charging_mode = CHARGING_NONE;		} else {			muic_path = MUIC_UNKNOWN;			charging_mode = CHARGING_NONE;		}	}}s32 muic_ts5usba33402_detect_accessory(s32 upon_irq){	s32 ret = 0;	u8 int_stat_value;	muic_mdelay(70);	ret = muic_i2c_read_byte(INT_STAT, &int_stat_value);	printk("[MUIC] muic_ts5usba33402_detect_accessory, int_stat_value:0x%02x \n", int_stat_value);		if (ret < 0) {		printk(KERN_INFO "[MUIC] INT_STAT reading failed\n");		muic_path = MUIC_UNKNOWN;		charging_mode = muic_path;		return ret;	}	switch (muic_path) {	case MUIC_UNKNOWN :	case MUIC_NONE :		set_ts5usba33402_muic_path(int_stat_value);		break;	case MUIC_AP_UART :	case MUIC_CP_UART :		if ((int_stat_value & IDNO) == IDNO_1011) {	        			muic_i2c_write_byte(SW_CONTROL, COMP2_TO_HZ | COMN1_TO_HZ);		        muic_path = MUIC_NONE;			charging_mode = CHARGING_NONE;	    }       		break;			case MUIC_NA_TA :	case MUIC_LG_TA :	case MUIC_TA_1A :	case MUIC_INVALID_CHG :		if (((int_stat_value & VBUS) == 0) || ((int_stat_value & CHGDET) == 0)) {	         	        muic_path = MUIC_NONE;			charging_mode = CHARGING_NONE;        }		break;			case MUIC_AP_USB :	case MUIC_CP_USB :		if ((int_stat_value & VBUS) == 0) {               		      		muic_path = MUIC_NONE;			charging_mode = CHARGING_NONE;    	}		break;			default :		printk(KERN_WARNING "[MUIC] Failed to detect an accessory. Try again!");		muic_path = MUIC_UNKNOWN;		charging_mode = CHARGING_NONE;		ret = -1;	}		printk(KERN_WARNING "[MUIC] muic_ts5usba33402_detect_accessory, muic_path = %s\n", muic_path_str[muic_path]);	if (muic_path == MUIC_UNKNOWN || muic_path == MUIC_NONE){		muic_init_ts5usba33402(RESET);		gpio_set_value(IFX_USB_VBUS_EN_GPIO, 0);        printk(KERN_INFO "[MUIC] charging_ic_deactive()\n");    }	return ret;}