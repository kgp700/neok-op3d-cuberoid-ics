#include <linux/interrupt.h>#include <linux/irq.h>#include <linux/i2c.h>#include <linux/gpio.h>#include <asm/irq.h>#include <linux/delay.h>#include <linux/syscalls.h> #include <linux/fcntl.h> #include <asm/uaccess.h> #include <linux/hrtimer.h>#include <linux/ktime.h>#include "SiI9244_Reg.h"#include "Common_Def.h"#include "SiI9244_I2C_master.h"#include "SiI9244_I2C_slave_add.h"#include "si_cbusDefs.h"#include "si_cbus_regs.h"#include "si_cbus.h"#include "si_apiCbus.h"#define TX_HW_RESET_PERIOD      200#define SiI_DEVICE_ID           0xB0#define DDC_XLTN_TIMEOUT_MAX_VAL		0x30#define INDEXED_PAGE_0		0x01#define INDEXED_PAGE_1		0x02#define INDEXED_PAGE_2		0x03#define ASR_VALUE 0x04#define	TX_POWER_STATE_D0_NO_MHL		TX_POWER_STATE_D2#define	TX_POWER_STATE_D0_MHL			TX_POWER_STATE_D0#define	TX_POWER_STATE_FIRST_INIT		0xFF#define MHL_INIT_POWER_OFF        0x00#define MHL_POWER_ON              0x01#define MHL_1K_IMPEDANCE_VERIFIED 0x02#define MHL_RSEN_VERIFIED         0x04#define MHL_TV_OFF_CABLE_CONNECT 0x08#define TX_DEBUG_PRINT(x) printk x#define	I2C_READ_MODIFY_WRITE(saddr,offset,mask)	I2C_WriteByte(saddr, offset, I2C_ReadByte(saddr, offset) | (mask));#define	SET_BIT(saddr,offset,bitnumber)		I2C_READ_MODIFY_WRITE(saddr,offset, (1<<bitnumber))#define	CLR_BIT(saddr,offset,bitnumber)		I2C_WriteByte(saddr, offset, I2C_ReadByte(saddr, offset) & ~(1<<bitnumber))#define	DISABLE_DISCOVERY				CLR_BIT(SA_TX_Page0_Primary, 0x90, 0);#define	ENABLE_DISCOVERY				SET_BIT(SA_TX_Page0_Primary, 0x90, 0);#define	INTR_4_DESIRED_MASK				( BIT_2 | BIT_3 | BIT_4 | BIT_6) #define	UNMASK_INTR_4_INTERRUPTS		I2C_WriteByte(SA_TX_Page0_Primary, 0x78, 0x00) #define	MASK_INTR_4_INTERRUPTS	I2C_WriteByte(SA_TX_Page0_Primary, 0x78, INTR_4_DESIRED_MASK)		#define	INTR_1_DESIRED_MASK				(BIT_5|BIT_6) #define	UNMASK_INTR_1_INTERRUPTS		I2C_WriteByte(SA_TX_Page0_Primary, 0x75, 0x00)#define	MASK_INTR_1_INTERRUPTS			I2C_WriteByte(SA_TX_Page0_Primary, 0x75, INTR_1_DESIRED_MASK)#define	INTR_CBUS1_DESIRED_MASK			(BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6)#define	UNMASK_CBUS1_INTERRUPTS		I2C_WriteByte(SA_TX_CBUS_Primary, 0x09, 0x00)	#define	MASK_CBUS1_INTERRUPTS			I2C_WriteByte(SA_TX_CBUS_Primary, 0x09, INTR_CBUS1_DESIRED_MASK)#define	INTR_CBUS2_DESIRED_MASK			(BIT_2 | BIT_3)#define	UNMASK_CBUS2_INTERRUPTS		 I2C_WriteByte(SA_TX_CBUS_Primary, 0x1F, 0x00)	#define	MASK_CBUS2_INTERRUPTS			 I2C_WriteByte(SA_TX_CBUS_Primary, 0x1F, INTR_CBUS2_DESIRED_MASK)#define		MHL_TX_EVENT_NONE			0x00	#define		MHL_TX_EVENT_DISCONNECTION	0x01	#define		MHL_TX_EVENT_CONNECTION		0x02	#define		MHL_TX_EVENT_RCP_READY		0x03	#define		MHL_TX_EVENT_RCP_RECEIVED	0x04	#define		MHL_TX_EVENT_RCPK_RECEIVED	0x05	#define		MHL_TX_EVENT_RCPE_RECEIVED	0x06	#define	MS_TO_NS(x)	(x * 1000000)DECLARE_WAIT_QUEUE_HEAD(wake_wq);static struct hrtimer hr_wake_timer;static bool wakeup_time_expired;static bool hrtimer_initialized;static bool first_timer;enum hrtimer_restart hrtimer_wakeup_callback(struct hrtimer *timer){	wake_up(&wake_wq);	wakeup_time_expired = true;	return HRTIMER_NORESTART;}void start_hrtimer_ms(unsigned long delay_in_ms){	ktime_t ktime;	ktime = ktime_set(0, MS_TO_NS(delay_in_ms));	wakeup_time_expired = false;	if (first_timer)		first_timer = false;	else		hrtimer_cancel(&hr_wake_timer);	hrtimer_start(&hr_wake_timer, ktime, HRTIMER_MODE_REL);}byte	fwPowerState = TX_POWER_STATE_FIRST_INIT;static	bool		mscCmdInProgress;	static	byte	dsHpdStatus = 0;byte mhl_cable_status =MHL_INIT_POWER_OFF;			#define	MHL_MAX_RCP_KEY_CODE	(0x7F + 1)	byte		rcpSupportTable [MHL_MAX_RCP_KEY_CODE] = {	(MHL_DEV_LD_GUI),			(MHL_DEV_LD_GUI),			(MHL_DEV_LD_GUI),			(MHL_DEV_LD_GUI),			(MHL_DEV_LD_GUI),			0, 0, 0, 0,					(MHL_DEV_LD_GUI),			0, 0, 0,					(MHL_DEV_LD_GUI),			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,		0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,							0,	0,	0, 0, 0,					0,	0,	0,	0,	0,							0,							0,							0,							0,							0, 0, 0, 0, 0, 0, 0,		0,							0,	0,	0,	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO),		(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_RECORD),		(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_RECORD),		0,	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO),		(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO),		0,	0,	0,	0, 0, 0,					0,							0,							0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO),		(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO),		0,	0,	(MHL_DEV_LD_VIDEO | MHL_DEV_LD_AUDIO | MHL_DEV_LD_RECORD),		0,	0,	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 		};static	void	Int4Isr(void);static	void	Int1RsenIsr(void);static	void	MhlCbusIsr(void);void	CbusReset(void);void	SwitchToD0(void);void	SwitchToD3(void);void	WriteInitialRegisterValues(void);static	void	InitCBusRegs(void);static	void	ForceUsbIdSwitchOpen(void);static	void	ReleaseUsbIdSwitchOpen(void);void	MhlTxDrvProcessConnection(void);void	MhlTxDrvProcessDisconnection(void);static	void	ApplyDdcAbortSafety(void);static	mhlTx_config_t	mhlTxConfig;static	bool 		SiiMhlTxRapkSend( void );static	void		MhlTxDriveStates( void );static	void		MhlTxResetStates( void );static	bool		MhlTxSendMscMsg ( byte command, byte cmdData );void	SiiMhlTxNotifyConnection( bool mhlConnected );void	AppVbusControl( bool powerOn );void	AppRcpDemo( byte event, byte eventParameter);void	SiiMhlTxNotifyDsHpdChange( byte dsHpdStatus );bool SiiMhlTxReadDevcap( byte offset );bool SiiMhlTxRcpkSend( byte );void	SiiMhlTxGotMhlStatus( byte status_0, byte status_1 );void	SiiMhlTxGotMhlIntr( byte intr_0, byte intr_1 );void	SiiMhlTxGotMhlMscMsg( byte subCommand, byte cmdData );void	SiiMhlTxMscCommandDone( byte data1 );void SiiMhlTxGetEvents( byte *event, byte *eventParameter );bool SiiMhlTxRcpeSend( byte rcpeErrorCode );void DelayMS(word msec);void sii9244_hw_reset(void);void sii_mhl_tx_init( void );Bool sii9244_init(void);void sii9244_interrupt_event(void);void	ProcessRgnd( void );extern void rcp_cbus_uevent(u8);		void DelayMS(word msec){	msleep(msec);}void sii9244_hw_reset(void){	printk(KERN_ERR ">>TxHW_Reset()\n");	#if 0	s3c_gpio_setpull(GPIO_MHL_RST, S3C_GPIO_PULL_NONE);#endif	gpio_direction_output(GPIO_MHL_RST, GPIO_LEVEL_LOW);	gpio_set_value(GPIO_MHL_RST, GPIO_LEVEL_LOW);		DelayMS(TX_HW_RESET_PERIOD);	gpio_set_value(GPIO_MHL_RST, GPIO_LEVEL_HIGH);	printk(KERN_ERR ">>TxHW_Reset() done\n");}Bool SiI9244_startTPI(void){	byte devID = 0x00;	printk(KERN_ERR ">>StartTPI()\n");	WriteByteTPI(TPI_ENABLE, 0x00);            	DelayMS(10);	devID = ReadByteTPI(TPI_DEVICE_ID);	if (devID == SiI_DEVICE_ID) 	{		printk(KERN_ERR "######## Subhransu: Silicon Device Id: %x\n", devID);		return TRUE;	}	printk(KERN_ERR "Unsupported TX\n");	return FALSE;}Bool sii9244_init(void){	printk(KERN_ERR "# SiI9244 initialization start~ \n"); 	sii_mhl_tx_init();	return TRUE;}bool SiiMhlTxChipInitialize ( void ){	TX_DEBUG_PRINT( ("Drv: SiiMhlTxChipInitialize: %02X44\n", (int)I2C_ReadByte(SA_TX_Page0_Primary, 0x03)) );	WriteInitialRegisterValues();	MASK_INTR_4_INTERRUPTS;	MASK_INTR_1_INTERRUPTS;	SwitchToD3();	return TRUE;}void 	SiiMhlTxDeviceIsr( void ){	byte tmp;			if( TX_POWER_STATE_D0_MHL != fwPowerState )	{  		Int4Isr();		if(mhl_cable_status == MHL_TV_OFF_CABLE_CONNECT)		{			return ;		}                		tmp = ReadByteCBUS(0x08);		WriteByteCBUS(0x08, tmp);		tmp = ReadByteCBUS(0x1E);		WriteByteCBUS(0x1E, tmp);                    	}	else if( TX_POWER_STATE_D0_MHL == fwPowerState ) 	{		MhlCbusIsr();	}	Int1RsenIsr();}void	SiiMhlTxDrvTmdsControl( bool enable ){	if( enable )	{		SET_BIT(SA_TX_Page0_Primary, 0x80, 4);		TX_DEBUG_PRINT(("Drv: TMDS Output Enabled\n"));	}	else	{		CLR_BIT(SA_TX_Page0_Primary, 0x80, 4);		TX_DEBUG_PRINT(("Drv: TMDS Ouput Disabled\n"));	}}void	SiiMhlTxDrvNotifyEdidChange ( void ){	TX_DEBUG_PRINT(("Drv: SiiMhlTxDrvNotifyEdidChange\n"));	SET_BIT(SA_TX_Page0_Primary, 0x79, 4);	CLR_BIT(SA_TX_Page0_Primary, 0x79, 5);	DelayMS(110);	SET_BIT(SA_TX_Page0_Primary, 0x79, 5);}bool SiiMhlTxDrvSendCbusCommand ( cbus_req_t *pReq  ){	bool  success = TRUE;	byte i, startbit;  if( (TX_POWER_STATE_D0_MHL != fwPowerState ) || (mscCmdInProgress))	{	    TX_DEBUG_PRINT(("Error: Drv: fwPowerState: %02X, CBUS[0x0A]: %02X or mscCmdInProgress = %d\n",				(int) fwPowerState,					(int) ReadByteCBUS(0x0a),					(int) mscCmdInProgress));		return FALSE;	}		mscCmdInProgress	= TRUE;	TX_DEBUG_PRINT(("Drv: Sending MSC command %02X, %02X, %02X, %02X\n",				(int)pReq->command,				(int)(pReq->offsetData),				(int)pReq->msgData[0],				(int)pReq->msgData[1]));	WriteByteCBUS( 0x13, pReq->offsetData); 		WriteByteCBUS( 0x14, pReq->msgData[0] );	startbit = 0x00;	switch ( pReq->command )	{		case MHL_SET_INT:				WriteByteCBUS( (REG_CBUS_PRI_ADDR_CMD & 0xFF), pReq->offsetData + 0x20 ); 				startbit = MSC_START_BIT_WRITE_REG;			break;		case MHL_WRITE_STAT:				WriteByteCBUS( (REG_CBUS_PRI_ADDR_CMD & 0xFF), pReq->offsetData + 0x30 ); 				startbit = MSC_START_BIT_WRITE_REG;			break;		case MHL_READ_DEVCAP:				startbit = MSC_START_BIT_READ_REG;			break;		case MHL_GET_STATE:					case MHL_GET_VENDOR_ID:				case MHL_SET_HPD:					case MHL_CLR_HPD:					case MHL_GET_SC1_ERRORCODE:						case MHL_GET_MSC_ERRORCODE:				case MHL_GET_SC3_ERRORCODE:					WriteByteCBUS( (REG_CBUS_PRI_ADDR_CMD & 0xFF), pReq->command );			startbit = MSC_START_BIT_MSC_CMD;			break;    		case MHL_GET_DDC_ERRORCODE:					WriteByteCBUS( (REG_CBUS_PRI_ADDR_CMD & 0xFF), 0x00 );            		startbit = MSC_START_BIT_MSC_CMD;            break;		case MHL_MSC_MSG:			WriteByteCBUS( (REG_CBUS_PRI_WR_DATA_2ND & 0xFF), pReq->msgData[1] );			WriteByteCBUS( (REG_CBUS_PRI_ADDR_CMD & 0xFF), pReq->command );			startbit = MSC_START_BIT_VS_CMD;			break;		case MHL_WRITE_BURST:			WriteByteCBUS( (REG_CBUS_PRI_ADDR_CMD & 0xFF), pReq->offsetData + 0x40 );			WriteByteCBUS( (REG_MSC_WRITE_BURST_LEN & 0xFF), pReq->length -1 );			for ( i = 0; i < pReq->length; i++ )			{				WriteByteCBUS( (REG_CBUS_SCRATCHPAD_0 & 0xFF) + i, pReq->msgData[i] );			}			startbit = MSC_START_BIT_WRITE_BURST;			break;		default:			success = FALSE;			break;	}	if ( success )	{		WriteByteCBUS( REG_CBUS_PRI_START & 0xFF, startbit );	}	return( success );}void	Int1RsenIsr( void ){	byte		reg71 = I2C_ReadByte(SA_TX_Page0_Primary, 0x71);	byte		rsen  = I2C_ReadByte(SA_TX_Page0_Primary, 0x09) & BIT_2;	if(reg71 & BIT_5)	{		TX_DEBUG_PRINT (("Drv: Got INTR_1: reg71 = %02X, rsen = %02X\n", (int) reg71, (int) rsen));		if(rsen == 0x00)		{	      		if(TX_POWER_STATE_D0_MHL != fwPowerState)	      		{				TX_DEBUG_PRINT (("Drv: Got1 INTR_1: reg71 = %02X, rsen = %02X\n", (int) reg71, (int) rsen));				I2C_WriteByte(SA_TX_Page0_Primary, 0x71, reg71);				return ;	      		}			if(mhl_cable_status & MHL_1K_IMPEDANCE_VERIFIED)#if 1      			{        			TX_DEBUG_PRINT((KERN_ERR "RSEN Low and 1K impedance\n"));				DelayMS(120);         			if((I2C_ReadByte(SA_TX_Page0_Primary, 0x09) & BIT_2) == 0x00)         			{			           TX_DEBUG_PRINT((KERN_ERR "Really RSEN Low\n"));					          					mhl_cable_status = MHL_TV_OFF_CABLE_CONNECT;#if defined(CONFIG_S5PC110_DEMPSEY_BOARD)	FSA9480_MhlSwitchSel(0);#endif					MHL_On(0);         			}        		 	else        			{         				TX_DEBUG_PRINT((KERN_ERR "RSEN Stable\n"));        			}      			}#else			{			mhl_cable_status =MHL_TV_OFF_CABLE_CONNECT;			printk(KERN_ERR "MHL Connection Fail Power off ###\n");			SiI9244_HW_Reset();			For_check_resen_int();			fwPowerState = TX_POWER_STATE_D3;			return ;		      	}#endif      			else	      		{				printk(KERN_ERR "%s: MHL Cable disconnect### 2\n", __func__);				mhl_cable_status =MHL_INIT_POWER_OFF;				MHL_On(0);			}			return ;		}		else if(rsen == 0x04)		{  			mhl_cable_status |= MHL_RSEN_VERIFIED;			printk("MHL Cable Connection ###\n");		}	}	if(reg71 & BIT_6)	{		byte cbusInt;				printk(KERN_ERR "HPD \n");		cbusInt = ReadByteCBUS(0x0D);		if((BIT_6 & cbusInt) != dsHpdStatus)		{						SiiMhlTxNotifyDsHpdChange( cbusInt );			TX_DEBUG_PRINT(("Drv: Downstream HPD changed to: %02X\n", (int) cbusInt));			dsHpdStatus = (BIT_6 & cbusInt);		}	}	I2C_WriteByte(SA_TX_Page0_Primary, 0x71, reg71);}void WriteInitialRegisterValues ( void ){	TX_DEBUG_PRINT(("Drv: WriteInitialRegisterValues\n"));		I2C_WriteByte(SA_TX_Page1_Primary, 0x3D, 0x3F);		I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x11, 0x01);		I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x12, 0x15);		I2C_WriteByte(SA_TX_Page0_Primary, 0x08, 0x35);		I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x10, 0xC1);		I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x17, 0x03);		I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x1A, 0x20);		I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x22, 0x8A);		I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x23, 0x6A);		I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x24, 0xAA);		I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x25, 0xCA);		I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x26, 0xEA);		I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x4C, 0xA0);		I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x4D, 0x00);		I2C_WriteByte(SA_TX_Page0_Primary, 0x80, 0x34);		I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x45, 0x44);		I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x31, 0x0A);		I2C_WriteByte(SA_TX_Page0_Primary, 0xA0, 0xD0);	I2C_WriteByte(SA_TX_Page0_Primary, 0xA1, 0xFC);	#ifdef CONFIG_TARGET_LOCALE_KOR	I2C_WriteByte(SA_TX_Page0_Primary, 0xA3, 0xED);#else	I2C_WriteByte(SA_TX_Page0_Primary, 0xA3, 0xEB);#endif	I2C_WriteByte(SA_TX_Page0_Primary, 0xA6, 0x0C);	I2C_WriteByte(SA_TX_Page0_Primary, 0x2B, 0x01);		ReadModifyWriteTPI(0x90, BIT_3 | BIT_2, BIT_3);	I2C_WriteByte(SA_TX_Page0_Primary, 0x91, 0xA5);		    I2C_WriteByte(SA_TX_Page0_Primary, 0x94, 0x75);				I2C_WriteByte(SA_TX_CBUS_Primary, 0x31, I2C_ReadByte(SA_TX_CBUS_Primary, 0x31) | 0x0c);    I2C_WriteByte(SA_TX_Page0_Primary, 0xA5, 0xA0);				TX_DEBUG_PRINT(("Drv: MHL 1.0 Compliant Clock\n"));	I2C_WriteByte(SA_TX_Page0_Primary, 0x95, 0x31);	I2C_WriteByte(SA_TX_Page0_Primary, 0x97, 0x00);	ReadModifyWriteTPI(0x95, BIT_6, BIT_6);			WriteByteTPI(0x92, 0x86);						WriteByteTPI(0x93, 0x8C);				 		DelayMS(25);	ReadModifyWriteTPI(0x95, BIT_6, 0x00);			I2C_WriteByte(SA_TX_Page0_Primary, 0x90, 0x27);				CbusReset();	InitCBusRegs();	I2C_WriteByte(SA_TX_Page0_Primary, 0x05, 0x04);	I2C_WriteByte(SA_TX_Page0_Primary, 0x0D, 0x1C); 	}#define MHL_DEVICE_CATEGORY             0x02 #define	MHL_LOGICAL_DEVICE_MAP			(MHL_DEV_LD_AUDIO | MHL_DEV_LD_VIDEO | MHL_DEV_LD_MEDIA | MHL_DEV_LD_GUI )static void InitCBusRegs( void ){	byte		regval;	TX_DEBUG_PRINT(("Drv: InitCBusRegs\n"));		I2C_WriteByte(SA_TX_CBUS_Primary, 0x07, 0x36);	I2C_WriteByte(SA_TX_CBUS_Primary, 0x40, 0x03); 				I2C_WriteByte(SA_TX_CBUS_Primary, 0x42, 0x06); 				I2C_WriteByte(SA_TX_CBUS_Primary, 0x36, 0x0C);	I2C_WriteByte(SA_TX_CBUS_Primary, 0x3D, 0xFD);		I2C_WriteByte(SA_TX_CBUS_Primary, 0x1C, 0x00);	I2C_WriteByte(SA_TX_CBUS_Primary, 0x44, 0x02);	I2C_WriteByte(SA_TX_CBUS_Primary, 0x80, MHL_DEV_ACTIVE);	I2C_WriteByte(SA_TX_CBUS_Primary, 0x81, MHL_VERSION);	I2C_WriteByte(SA_TX_CBUS_Primary, 0x82, MHL_DEVICE_CATEGORY);	I2C_WriteByte(SA_TX_CBUS_Primary, 0x83, 0);  							I2C_WriteByte(SA_TX_CBUS_Primary, 0x84, 0);							I2C_WriteByte(SA_TX_CBUS_Primary, 0x85, (MHL_DEV_VID_LINK_SUPPRGB444|MHL_DEV_VID_LINK_SUPPYCBCR444));	I2C_WriteByte(SA_TX_CBUS_Primary, 0x86, MHL_DEV_AUD_LINK_2CH);	I2C_WriteByte(SA_TX_CBUS_Primary, 0x87, 0);											I2C_WriteByte(SA_TX_CBUS_Primary, 0x88, MHL_LOGICAL_DEVICE_MAP);	I2C_WriteByte(SA_TX_CBUS_Primary, 0x89, 0x0F);											I2C_WriteByte(SA_TX_CBUS_Primary, 0x8A, MHL_FEATURE_RCP_SUPPORT | MHL_FEATURE_RAP_SUPPORT|MHL_FEATURE_SP_SUPPORT);	I2C_WriteByte(SA_TX_CBUS_Primary, 0x8B, 0);	I2C_WriteByte(SA_TX_CBUS_Primary, 0x8C, 0);											I2C_WriteByte(SA_TX_CBUS_Primary, 0x8D, MHL_SCRATCHPAD_SIZE);	I2C_WriteByte(SA_TX_CBUS_Primary, 0x8E, 0x44 ); 	I2C_WriteByte(SA_TX_CBUS_Primary, 0x8F, 0);											regval = I2C_ReadByte(SA_TX_CBUS_Primary, REG_CBUS_LINK_CONTROL_2 );	regval = (regval | 0x0C);	I2C_WriteByte(SA_TX_CBUS_Primary,REG_CBUS_LINK_CONTROL_2, regval);    regval = I2C_ReadByte(SA_TX_CBUS_Primary, REG_MSC_TIMEOUT_LIMIT);    I2C_WriteByte(SA_TX_CBUS_Primary, REG_MSC_TIMEOUT_LIMIT, (regval & MSC_TIMEOUT_LIMIT_MSB_MASK));	I2C_WriteByte(SA_TX_CBUS_Primary, REG_CBUS_LINK_CONTROL_1, 0x01);}static void ForceUsbIdSwitchOpen ( void ){	I2C_WriteByte(SA_TX_Page0_Primary, 0x90, 0x26);			ReadModifyWriteTPI(0x95, BIT_6, BIT_6);		WriteByteTPI(0x92, 0x86);		ReadModifyWriteTPI(0x79, BIT_5 | BIT_4, BIT_4);}static void ReleaseUsbIdSwitchOpen ( void ){	DelayMS(50);	ReadModifyWriteTPI(0x95, BIT_6, 0x00);	ENABLE_DISCOVERY;}void CbusWakeUpPulseGenerator(void){	TX_DEBUG_PRINT(("Drv: CbusWakeUpPulseGenerator\n"));	if (!hrtimer_initialized) {		hrtimer_init(&hr_wake_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);		hr_wake_timer.function = &hrtimer_wakeup_callback;		hrtimer_initialized = true;		first_timer = true;	}	I2C_WriteByte(SA_TX_Page0_Primary, 0x96, (I2C_ReadByte(SA_TX_Page0_Primary, 0x96) | 0xC0));	start_hrtimer_ms(19);	wait_event_interruptible(wake_wq, wakeup_time_expired);	I2C_WriteByte(SA_TX_Page0_Primary, 0x96, (I2C_ReadByte(SA_TX_Page0_Primary, 0x96) & 0x3F));	start_hrtimer_ms(19);	wait_event_interruptible(wake_wq, wakeup_time_expired);	I2C_WriteByte(SA_TX_Page0_Primary, 0x96, (I2C_ReadByte(SA_TX_Page0_Primary, 0x96) | 0xC0));	start_hrtimer_ms(19);	wait_event_interruptible(wake_wq, wakeup_time_expired);	I2C_WriteByte(SA_TX_Page0_Primary, 0x96, (I2C_ReadByte(SA_TX_Page0_Primary, 0x96) & 0x3F));	start_hrtimer_ms(60);	wait_event_interruptible(wake_wq, wakeup_time_expired);	I2C_WriteByte(SA_TX_Page0_Primary, 0x96, (I2C_ReadByte(SA_TX_Page0_Primary, 0x96) | 0xC0));	start_hrtimer_ms(19);	wait_event_interruptible(wake_wq, wakeup_time_expired);	I2C_WriteByte(SA_TX_Page0_Primary, 0x96, (I2C_ReadByte(SA_TX_Page0_Primary, 0x96) & 0x3F));	start_hrtimer_ms(19);	wait_event_interruptible(wake_wq, wakeup_time_expired);	I2C_WriteByte(SA_TX_Page0_Primary, 0x96, (I2C_ReadByte(SA_TX_Page0_Primary, 0x96) | 0xC0));	start_hrtimer_ms(19);	wait_event_interruptible(wake_wq, wakeup_time_expired);	I2C_WriteByte(SA_TX_Page0_Primary, 0x96, (I2C_ReadByte(SA_TX_Page0_Primary, 0x96) & 0x3F));	start_hrtimer_ms(T_SRC_WAKE_TO_DISCOVER);	wait_event_interruptible(wake_wq, wakeup_time_expired);}static	void	ApplyDdcAbortSafety(){	byte		bTemp, bPost;	WriteByteCBUS(0x29, 0xFF);	bTemp = ReadByteCBUS(0x29);	DelayMS(3);	bPost = ReadByteCBUS(0x29);	if ((bPost > (bTemp + 50)))	{		TX_DEBUG_PRINT(("Drv: Applying DDC Abort Safety(SWWA 18958)\n"));		SET_BIT(SA_TX_Page0_Primary, 0x05, 3);		CLR_BIT(SA_TX_Page0_Primary, 0x05, 3);		InitCBusRegs();		ForceUsbIdSwitchOpen();		ReleaseUsbIdSwitchOpen();		MhlTxDrvProcessDisconnection();	}}void	ProcessRgnd( void ){	byte		reg99RGNDRange;	reg99RGNDRange = I2C_ReadByte(SA_TX_Page0_Primary, 0x99) & 0x03;	TX_DEBUG_PRINT(("Drv: RGND Reg 99 = %02X : ", (int)reg99RGNDRange));#if defined(CONFIG_S5PC110_DEMPSEY_BOARD)        DisableFSA9480Interrupts(); #endif	if (reg99RGNDRange == 0x00 || reg99RGNDRange == 0x03)	{		TX_DEBUG_PRINT((" : USB impedance. Disable MHL discovery.\n", (int)reg99RGNDRange));		CLR_BIT(SA_TX_Page0_Primary, 0x95, 5);		mhl_cable_status =MHL_INIT_POWER_OFF;		MHL_On(0); 		#if defined(CONFIG_S5PC110_DEMPSEY_BOARD)		FSA9480_CheckAndHookAudioDock(); #endif	}	else	{		mhl_cable_status |= MHL_1K_IMPEDANCE_VERIFIED;		if(0x01==reg99RGNDRange)		{			TX_DEBUG_PRINT(("MHL 2K\n"));      mhl_cable_status =MHL_TV_OFF_CABLE_CONNECT;      printk(KERN_ERR "MHL Connection Fail Power off ###\n");			MHL_On(0);	        #if defined(CONFIG_S5PC110_DEMPSEY_BOARD)        FSA9480_MhlTvOff();      #endif      return ;		}		else if(0x02==reg99RGNDRange)		{			TX_DEBUG_PRINT(("MHL 1K\n"));	DelayMS(T_SRC_VBUS_CBUS_TO_STABLE);	I2C_WriteByte(SA_TX_Page0_Primary, 0x90, 0x25);	CbusWakeUpPulseGenerator();}	}}void	SwitchToD0( void ){	WriteInitialRegisterValues();#if 0		UNMASK_INT4_INTERRUPTS;#else		MASK_INTR_1_INTERRUPTS;#endif	I2C_WriteByte(SA_TX_Page0_Primary, 0x90, 0x25);	fwPowerState = TX_POWER_STATE_D0_NO_MHL;  	mhl_cable_status =MHL_POWER_ON;}void	SwitchToD3( void ){    ReadModifyWriteTPI(0x93, BIT_7 | BIT_6 | BIT_5 | BIT_4, 0);		ReadModifyWriteTPI(0x94, BIT_1 | BIT_0, 0);        ReleaseUsbIdSwitchOpen();        printk(KERN_ERR "POWER_STATE_D3\n");	I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x01, 0x03);	CLR_BIT(SA_TX_Page1_Primary, 0x3D, 0);	fwPowerState = TX_POWER_STATE_D3;}static void For_check_resen_int (void) {	I2C_WriteByte(SA_TX_Page1_Primary, 0x3D, 0x3F);				I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x11, 0x01);				I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x12, 0x15);				I2C_WriteByte(SA_TX_Page0_Primary, 0x08, 0x35);				I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x17, 0x03);				I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x1A, 0x20);				I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x22, 0x8A);				I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x23, 0x6A);				I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x24, 0xAA);				I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x25, 0xCA);				I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x26, 0xEA);				I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x4C, 0xA0);				I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x4D, 0x00);				I2C_WriteByte(SA_TX_Page0_Primary, 0x80, 0x24);				I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x45, 0x44);				I2C_WriteByte(SA_TX_HDMI_RX_Primary, 0x31, 0x0A);				I2C_WriteByte(SA_TX_Page0_Primary, 0xA0, 0xD0);	I2C_WriteByte(SA_TX_Page0_Primary, 0xA1, 0xFC);			#ifdef CONFIG_TARGET_LOCALE_KOR	I2C_WriteByte(SA_TX_Page0_Primary, 0xA3, 0xED);#else	I2C_WriteByte(SA_TX_Page0_Primary, 0xA3, 0xEB);#endif	I2C_WriteByte(SA_TX_Page0_Primary, 0xA6, 0x0C);	I2C_WriteByte(SA_TX_Page0_Primary, 0x2B, 0x01);				ReadModifyWriteTPI(0x90, BIT_3 | BIT_2, BIT_3);		I2C_WriteByte(SA_TX_Page0_Primary, 0x91, 0xA5);		I2C_WriteByte(SA_TX_Page0_Primary, 0x94, 0x66);				I2C_WriteByte(SA_TX_CBUS_Primary, 0x31, I2C_ReadByte(SA_TX_CBUS_Primary, 0x31) | 0x0c);	I2C_WriteByte(SA_TX_Page0_Primary, 0xA5, 0xAC);				I2C_WriteByte(SA_TX_Page0_Primary, 0x95, 0x31);				I2C_WriteByte(SA_TX_Page0_Primary, 0x96, 0x22);				ReadModifyWriteTPI(0x95, BIT_6, BIT_6);			WriteByteTPI(0x92, 0x86);					WriteByteTPI(0x93, 0xCC);					DelayMS(25);	ReadModifyWriteTPI(0x95, BIT_6, 0x00);		  ReadModifyWriteTPI(0x79, BIT_1 | BIT_2, 0);   I2C_WriteByte(SA_TX_Page0_Primary, 0x90, 0x27);				I2C_WriteByte(SA_TX_Page0_Primary, 0x05, 0x08);	DelayMS(2);	I2C_WriteByte(SA_TX_Page0_Primary, 0x05, 0x00);  I2C_WriteByte(SA_TX_CBUS_Primary, 0x1F, 0x02); 			  I2C_WriteByte(SA_TX_CBUS_Primary, 0x07, DDC_XLTN_TIMEOUT_MAX_VAL | 0x06); 			  I2C_WriteByte(SA_TX_CBUS_Primary, 0x40, 0x03); 			  I2C_WriteByte(SA_TX_CBUS_Primary, 0x42, 0x06); 			  I2C_WriteByte(SA_TX_CBUS_Primary, 0x36, 0x0C);  I2C_WriteByte(SA_TX_CBUS_Primary, 0x3D, 0xFD);	  I2C_WriteByte(SA_TX_CBUS_Primary, 0x1C, 0x00);  I2C_WriteByte(SA_TX_CBUS_Primary, 0x44, 0x02);	I2C_WriteByte(SA_TX_Page0_Primary, 0x05, 0x04); 			I2C_WriteByte(SA_TX_Page0_Primary, 0x0D, 0x1C); 			UNMASK_INTR_4_INTERRUPTS;  SiI9244_startTPI();WriteByteTPI(TPI_INTERRUPT_ENABLE_REG, 0x02);    }static	void	Int4Isr( void ){	byte		reg74;	reg74 = I2C_ReadByte(SA_TX_Page0_Primary, (0x74));		printk(KERN_ERR "[MHL] Int4Isr : REG74 : %x\n",(int)reg74);	if(0xFF == reg74)	{		printk(KERN_ERR "RETURN (0xFF == reg74)\n");		return;	}	if(reg74 & BIT_2) 	{		if((I2C_ReadByte(SA_TX_Page0_Primary, 0x09) & BIT_2) == 0x00) {			printk(KERN_ERR "[MHL] RSEN is low - status incorrect\n");			MHL_On(0);			return;		}    	        MASK_CBUS1_INTERRUPTS;     	        MASK_CBUS2_INTERRUPTS;		MhlTxDrvProcessConnection(); 	}	else if(reg74 & BIT_3) 	{    if(mhl_cable_status == (MHL_1K_IMPEDANCE_VERIFIED|MHL_POWER_ON))    {      mhl_cable_status =MHL_TV_OFF_CABLE_CONNECT;      printk(KERN_ERR "MHL Connection Fail Power off ###\n");	MHL_On(0);      #if defined(CONFIG_S5PC110_DEMPSEY_BOARD)        FSA9480_MhlTvOff();      #endif    }    else    {		MhlTxDrvProcessDisconnection();    }		return;	}	if((TX_POWER_STATE_D3 == fwPowerState) && (reg74 & BIT_6))	{		SwitchToD0();		ProcessRgnd();	}	if (reg74 & BIT_4)	{		TX_DEBUG_PRINT(("Drv: CBus Lockout\n"));		ForceUsbIdSwitchOpen();		ReleaseUsbIdSwitchOpen();	}	I2C_WriteByte(SA_TX_Page0_Primary, (0x74), reg74);	}void MhlTxDrvProcessConnection ( void ){	bool	mhlConnected = TRUE;	TX_DEBUG_PRINT (("Drv: MHL Cable Connected. CBUS:0x0A = %02X\n", (int) ReadByteCBUS(0x0a)));	if( TX_POWER_STATE_D0_MHL == fwPowerState )	{		TX_DEBUG_PRINT(("POWER_STATE_D0_MHL == fwPowerState\n"));		return;	}	I2C_WriteByte(SA_TX_Page0_Primary, 0xA0, 0x10);	fwPowerState = TX_POWER_STATE_D0_MHL;	WriteByteCBUS(0x07, 0x32);	SET_BIT(SA_TX_CBUS_Primary, 0x44, 1);	CLR_BIT(SA_TX_Page0_Primary, 0x79, 4);	SiiMhlTxDrvTmdsControl( TRUE );	ENABLE_DISCOVERY;	SiiMhlTxNotifyConnection(mhlConnected = TRUE);}void MhlTxDrvProcessDisconnection ( void ){	bool	mhlConnected = FALSE;	TX_DEBUG_PRINT (("Drv: MhlTxDrvProcessDisconnection\n"));	I2C_WriteByte(SA_TX_Page0_Primary, (0x74), I2C_ReadByte(SA_TX_Page0_Primary, (0x74)));	I2C_WriteByte(SA_TX_Page0_Primary, 0xA0, 0xD0);	CbusReset();	SiiMhlTxDrvTmdsControl( FALSE );	if( TX_POWER_STATE_D0_MHL == fwPowerState )	{				SiiMhlTxNotifyConnection(mhlConnected = FALSE);	}	SwitchToD3();}void	CbusReset(){	SET_BIT(SA_TX_Page0_Primary, 0x05, 3);	DelayMS(2);	CLR_BIT(SA_TX_Page0_Primary, 0x05, 3);	mscCmdInProgress = FALSE;	UNMASK_CBUS1_INTERRUPTS;	UNMASK_CBUS2_INTERRUPTS;}static byte CBusProcessErrors( byte intStatus ){	byte result          = 0;	byte mscAbortReason  = 0;	byte ddcAbortReason  = 0;	intStatus &=  (BIT_MSC_ABORT | BIT_MSC_XFR_ABORT);	if ( intStatus )	{		if( intStatus & BIT_DDC_ABORT )		{			result = ddcAbortReason = ReadByteCBUS((byte) REG_DDC_ABORT_REASON );			TX_DEBUG_PRINT( ("CBUS DDC ABORT happened, reason:: %02X\n", (int)(ddcAbortReason)));		}		if ( intStatus & BIT_MSC_XFR_ABORT )		{			result = mscAbortReason = ReadByteCBUS((byte) REG_PRI_XFR_ABORT_REASON );			TX_DEBUG_PRINT( ("CBUS:: MSC Transfer ABORTED. Clearing 0x0D\n"));			WriteByteCBUS((byte) REG_PRI_XFR_ABORT_REASON, 0xFF );		}		if ( intStatus & BIT_MSC_ABORT )		{			TX_DEBUG_PRINT( ("CBUS:: MSC Peer sent an ABORT. Clearing 0x0E\n"));			WriteByteCBUS((byte) REG_CBUS_PRI_FWR_ABORT_REASON, 0xFF );		}		if ( mscAbortReason != 0 )		{			TX_DEBUG_PRINT( ("CBUS:: Reason for ABORT is ....0x%02X = ", (int)mscAbortReason ));			if ( mscAbortReason & CBUSABORT_BIT_REQ_MAXFAIL)			{				TX_DEBUG_PRINT( ("Requestor MAXFAIL - retry threshold exceeded\n"));			}			if ( mscAbortReason & CBUSABORT_BIT_PROTOCOL_ERROR)			{				TX_DEBUG_PRINT( ("Protocol Error\n"));			}			if ( mscAbortReason & CBUSABORT_BIT_REQ_TIMEOUT)			{				TX_DEBUG_PRINT( ("Requestor translation layer timeout\n"));			}			if ( mscAbortReason & CBUSABORT_BIT_PEER_ABORTED)			{				TX_DEBUG_PRINT( ("Peer sent an abort\n"));			}			if ( mscAbortReason & CBUSABORT_BIT_UNDEFINED_OPCODE)			{				TX_DEBUG_PRINT( ("Undefined opcode\n"));			}		}	}	return( result );}static void MhlCbusIsr( void ){	byte		cbusInt;	byte     gotData[4];		byte		i;	cbusInt = ReadByteCBUS(0x08);	if(cbusInt == 0xFF)	{		return;	}	if( cbusInt )	{		TX_DEBUG_PRINT(("Drv: CBUS INTR_1: %d\n", (int) cbusInt));	}	if (cbusInt & BIT_2)	{		ApplyDdcAbortSafety();	}		if((cbusInt & BIT_3))	{		TX_DEBUG_PRINT(("Drv: MSC_MSG Received: %02X\n", (int) cbusInt));		SiiMhlTxGotMhlMscMsg( ReadByteCBUS( 0x18 ), ReadByteCBUS( 0x19 ) );	}		if(cbusInt & BIT_4)	{		TX_DEBUG_PRINT(("Drv: MSC_REQ_DONE: %02X\n", (int) cbusInt));		mscCmdInProgress = FALSE;		SiiMhlTxMscCommandDone( ReadByteCBUS( 0x16 ) );	}	if((cbusInt & BIT_5) || (cbusInt & BIT_6))		{		gotData[0] = CBusProcessErrors(cbusInt);	}	if(cbusInt)	{		WriteByteCBUS(0x08, cbusInt);		TX_DEBUG_PRINT(("Drv: Clear CBUS INTR_1: %02X\n", (int) cbusInt));	}	cbusInt = ReadByteCBUS(0x1E);	if( cbusInt )	{		TX_DEBUG_PRINT(("Drv: CBUS INTR_2: %x\n", (int) cbusInt));	}	if(cbusInt & BIT_2)	{		TX_DEBUG_PRINT(("Drv: INT Received: %x\n", (int) cbusInt));		SiiMhlTxGotMhlIntr( ReadByteCBUS( 0xA0 ), ReadByteCBUS( 0xA1) );		for(i = 0; i < 4; i++)		{						WriteByteCBUS( (0xA0 + i), ReadByteCBUS( 0xA0 + i ));		}	}	if(cbusInt & BIT_3)	{		TX_DEBUG_PRINT(("Drv: STATUS Received: %x\n", (int) cbusInt));		SiiMhlTxGotMhlStatus( ReadByteCBUS( 0xB0 ), ReadByteCBUS( 0xB1) );		for(i = 0; i < 4; i++)		{						WriteByteCBUS( (0xB0 + i), ReadByteCBUS( 0xB0 + i ));		}	}	if(cbusInt)	{		WriteByteCBUS(0x1E, cbusInt);		TX_DEBUG_PRINT(("Drv: Clear CBUS INTR_2: %02X\n", (int) cbusInt));	}#if 0	cbusInt = ReadByteCBUS(0x0D);	if((BIT_6 & cbusInt) != dsHpdStatus)	{				SiiMhlTxNotifyDsHpdChange( cbusInt );		TX_DEBUG_PRINT(("Drv: Downstream HPD changed to: %02X\n", (int) cbusInt));		dsHpdStatus = (BIT_6 & cbusInt);	}#endif}void sii_mhl_tx_init( void ){	TX_DEBUG_PRINT( ("MhlTx: sii_mhl_tx_init\n") );	MhlTxResetStates( );	SiiMhlTxChipInitialize ();	mhl_cable_status =MHL_POWER_ON;			}void SiiMhlTxGetEvents( byte *event, byte *eventParameter ){	SiiMhlTxDeviceIsr();	if(mhl_cable_status == MHL_TV_OFF_CABLE_CONNECT)	{		return ;	}	MhlTxDriveStates( );	*event = MHL_TX_EVENT_NONE;	*eventParameter = 0;	if( mhlTxConfig.mhlConnectionEvent )	{		TX_DEBUG_PRINT( ("MhlTx: SiiMhlTxGetEvents mhlConnectionEvent\n") );		mhlTxConfig.mhlConnectionEvent = FALSE;		*event          = mhlTxConfig.mhlConnected;		*eventParameter	= mhlTxConfig.mscFeatureFlag;		if(MHL_TX_EVENT_DISCONNECTION == mhlTxConfig.mhlConnected)		{			MhlTxResetStates( );		}	}	else if( mhlTxConfig.mscMsgArrived )	{		TX_DEBUG_PRINT( ("MhlTx: SiiMhlTxGetEvents MSC MSG Arrived\n") );		mhlTxConfig.mscMsgArrived = FALSE;		switch(mhlTxConfig.mscMsgSubCommand)		{			case	MHL_MSC_MSG_RAP:				if( MHL_RAP_CONTENT_ON == mhlTxConfig.mscMsgData)				{					SiiMhlTxDrvTmdsControl( TRUE );				}				else if( MHL_RAP_CONTENT_OFF == mhlTxConfig.mscMsgData)				{					SiiMhlTxDrvTmdsControl( FALSE );				}								SiiMhlTxRapkSend( );				break;			case	MHL_MSC_MSG_RCP:				if(MHL_LOGICAL_DEVICE_MAP & rcpSupportTable [mhlTxConfig.mscMsgData] )				{				*event          = MHL_TX_EVENT_RCP_RECEIVED;				*eventParameter = mhlTxConfig.mscMsgData; #if 1					rcp_cbus_uevent(*eventParameter);	#endif				printk(KERN_ERR "Key Code:%x \n",(int)mhlTxConfig.mscMsgData);                                }else				{  				printk("Key Code Error:%x \n",(int)mhlTxConfig.mscMsgData);          				mhlTxConfig.mscSaveRcpKeyCode = mhlTxConfig.mscMsgData;					SiiMhlTxRcpeSend( 0x01 );				}				break;			case	MHL_MSC_MSG_RCPK:				*event = MHL_TX_EVENT_RCPK_RECEIVED;        *eventParameter = mhlTxConfig.mscMsgData; 				break;			case	MHL_MSC_MSG_RCPE:				*event = MHL_TX_EVENT_RCPE_RECEIVED;        *eventParameter = mhlTxConfig.mscMsgData; 				break;			case	MHL_MSC_MSG_RAPK:								break;			default:								break;		}	}}static	void	MhlTxDriveStates( void ){	switch( mhlTxConfig.mscState )	{		case MSC_STATE_BEGIN:			printk(KERN_ERR "MSC_STATE_BEGIN \n");			SiiMhlTxReadDevcap( MHL_DEV_CATEGORY_OFFSET );			break;		case MSC_STATE_POW_DONE:			printk(KERN_ERR "MSC_STATE_POW_DONE \n");			SiiMhlTxReadDevcap( MHL_DEV_FEATURE_FLAG_OFFSET );			break;		case MSC_STATE_IDLE:		case MSC_STATE_RCP_READY:			break;		default:			break;	}}void	SiiMhlTxMscCommandDone( byte data1 ){	TX_DEBUG_PRINT( ("MhlTx: SiiMhlTxMscCommandDone. data1 = %02X\n", (int) data1) );	if(( MHL_READ_DEVCAP == mhlTxConfig.mscLastCommand ) && 			(MHL_DEV_CATEGORY_OFFSET == mhlTxConfig.mscLastOffset))	{				mhlTxConfig.mscState	= MSC_STATE_POW_DONE;		AppVbusControl( (bool) ( data1 & MHL_DEV_CATEGORY_POW_BIT) );	}	else if((MHL_READ_DEVCAP == mhlTxConfig.mscLastCommand) &&			(MHL_DEV_FEATURE_FLAG_OFFSET == mhlTxConfig.mscLastOffset))	{				mhlTxConfig.mscState	= MSC_STATE_RCP_READY;		mhlTxConfig.mscFeatureFlag	= data1;		mhlTxConfig.mhlConnectionEvent = TRUE;		mhlTxConfig.mhlConnected = MHL_TX_EVENT_RCP_READY;		mhlTxConfig.mscLastCommand = 0;		mhlTxConfig.mscLastOffset  = 0;		TX_DEBUG_PRINT( ("MhlTx: Peer's Feature Flag = %02X\n\n", (int) data1) );	}	else if(MHL_MSC_MSG_RCPE == mhlTxConfig.mscMsgLastCommand)	{		if( SiiMhlTxRcpkSend( mhlTxConfig.mscSaveRcpKeyCode ) )		{						mhlTxConfig.mscMsgLastCommand = 0;			mhlTxConfig.mscMsgLastData    = 0;		}}}void	SiiMhlTxGotMhlMscMsg( byte subCommand, byte cmdData ){		mhlTxConfig.mscMsgArrived		= TRUE;	mhlTxConfig.mscMsgSubCommand	= subCommand;	mhlTxConfig.mscMsgData			= cmdData;}void	SiiMhlTxGotMhlIntr( byte intr_0, byte intr_1 ){	TX_DEBUG_PRINT( ("MhlTx: INTERRUPT Arrived. %02X, %02X\n", (int) intr_0, (int) intr_1) );	if(MHL_INT_DCAP_CHG & intr_0)	{		SiiMhlTxReadDevcap( MHL_DEV_CATEGORY_OFFSET );			}	else if(MHL_INT_EDID_CHG & intr_1)	{		SiiMhlTxDrvNotifyEdidChange ( );	}}void	SiiMhlTxGotMhlStatus( byte status_0, byte status_1 ){	TX_DEBUG_PRINT( ("MhlTx: STATUS Arrived. %02X, %02X\n", (int) status_0, (int) status_1) );	if(MHL_STATUS_DCAP_RDY & status_0)	{    mhlTxConfig.mscState	 = MSC_STATE_BEGIN;	}	mhlTxConfig.status_0 = status_0;	mhlTxConfig.status_1 = status_1;}bool SiiMhlTxRcpSend( byte rcpKeyCode ){	if((0 == (MHL_FEATURE_RCP_SUPPORT & mhlTxConfig.mscFeatureFlag)) ||			(MSC_STATE_RCP_READY != mhlTxConfig.mscState))	{		return	FALSE;	}	return	( MhlTxSendMscMsg ( MHL_MSC_MSG_RCP, rcpKeyCode ) );}bool SiiMhlTxRcpkSend( byte rcpKeyCode ){	return	( MhlTxSendMscMsg ( MHL_MSC_MSG_RCPK, rcpKeyCode ) );}static	bool SiiMhlTxRapkSend( void ){	return	( MhlTxSendMscMsg ( MHL_MSC_MSG_RAPK, 0 ) );}bool SiiMhlTxRcpeSend( byte rcpeErrorCode ){	return( MhlTxSendMscMsg ( MHL_MSC_MSG_RCPE, rcpeErrorCode ) );}bool SiiMhlTxReadDevcap( byte offset ){	cbus_req_t	req;	req.command     = mhlTxConfig.mscLastCommand = MHL_READ_DEVCAP;	req.offsetData  = mhlTxConfig.mscLastOffset  = offset;	return(SiiMhlTxDrvSendCbusCommand( &req  ));}static bool MhlTxSendMscMsg ( byte command, byte cmdData ){	cbus_req_t	req;	byte		ccode;	req.command     = MHL_MSC_MSG;	req.msgData[0]  = mhlTxConfig.mscMsgLastCommand = command;	req.msgData[1]  = mhlTxConfig.mscMsgLastData    = cmdData;	ccode = SiiMhlTxDrvSendCbusCommand( &req  );	return( (bool) ccode );}void	SiiMhlTxNotifyConnection( bool mhlConnected ){	mhlTxConfig.mhlConnectionEvent = TRUE;  mhlTxConfig.mscState	 = MSC_STATE_IDLE;	if(mhlConnected)	{		mhlTxConfig.mhlConnected = MHL_TX_EVENT_CONNECTION;	}	else	{		mhlTxConfig.mhlConnected = MHL_TX_EVENT_DISCONNECTION;	}}void	SiiMhlTxNotifyDsHpdChange( byte dsHpdStatus ){	if( 0 == dsHpdStatus )	{		TX_DEBUG_PRINT(("MhlTx: Disable TMDS\n"));		SiiMhlTxDrvTmdsControl( FALSE );	}	else	{		TX_DEBUG_PRINT(("MhlTx: Enable TMDS\n"));		SiiMhlTxDrvTmdsControl( TRUE );	}}static void	MhlTxResetStates( void ){	mhlTxConfig.mhlConnectionEvent	= FALSE;	mhlTxConfig.mhlConnected		= MHL_TX_EVENT_DISCONNECTION;	mhlTxConfig.mscMsgArrived		= FALSE;	mhlTxConfig.mscState			= MSC_STATE_IDLE;}#define	APP_DEMO_RCP_SEND_KEY_CODE 0x44void	AppRcpDemo( byte event, byte eventParameter){	byte		rcpKeyCode;	switch( event )	{		case	MHL_TX_EVENT_DISCONNECTION:			printk(KERN_ERR "App: Got event = MHL_TX_EVENT_DISCONNECTION\n");			break;		case	MHL_TX_EVENT_CONNECTION:			printk(KERN_ERR "App: Got event = MHL_TX_EVENT_CONNECTION\n");			break;		case	MHL_TX_EVENT_RCP_READY:			rcpKeyCode = APP_DEMO_RCP_SEND_KEY_CODE;			printk(KERN_ERR "App: Got event = MHL_TX_EVENT_RCP_READY...Sending RCP (%02X)\n", (int) rcpKeyCode);#if 0			if( (0 == (MHL_FEATURE_RCP_SUPPORT & eventParameter)) )			{				printk(KERN_ERR  "App: Peer does NOT support RCP\n" );			}			if( (0 == (MHL_FEATURE_RAP_SUPPORT & eventParameter)) )			{				printk(KERN_ERR  "App: Peer does NOT support RAP\n" );			}			if( (0 == (MHL_FEATURE_SP_SUPPORT & eventParameter)) )			{				printk(KERN_ERR  "App: Peer does NOT support WRITE_BURST\n" );			}			if( SiiMhlTxRcpSend( rcpKeyCode ))			{				printk(KERN_ERR "App: SiiMhlTxRcpSend (%02X)\n", (int) rcpKeyCode);			}			else			{				printk(KERN_ERR "App: SiiMhlTxRcpSend (%02X) Returned Failure.\n", (int) rcpKeyCode);			}#endif			break;		case	MHL_TX_EVENT_RCP_RECEIVED:			printk(KERN_ERR "App: Received an RCP key code = %02X\n", eventParameter );			switch(eventParameter)			{				case MHD_RCP_CMD_SELECT:					TX_DEBUG_PRINT(( "\nSelect received = %02x\n\n", (int)eventParameter ));					break;				case MHD_RCP_CMD_UP:					TX_DEBUG_PRINT(( "\nUp received = %02x\n\n", (int)eventParameter ));					break;				case MHD_RCP_CMD_DOWN:					TX_DEBUG_PRINT(( "\nDown received = %02x\n\n", (int)eventParameter ));					break;				case MHD_RCP_CMD_LEFT:					TX_DEBUG_PRINT(( "\nLeft received = %02x\n\n", (int)eventParameter ));					break;				case MHD_RCP_CMD_RIGHT:					TX_DEBUG_PRINT(( "\nRight received = %02x\n\n", (int)eventParameter ));					break;				case MHD_RCP_CMD_RIGHT_UP:					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_RIGHT_UP = %02x\n\n", (int)eventParameter ));					break;				case MHD_RCP_CMD_RIGHT_DOWN:					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_RIGHT_DOWN = %02x\n\n", (int)eventParameter ));					break;				case MHD_RCP_CMD_LEFT_UP:					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_LEFT_UP = %02x\n\n", (int)eventParameter ));					break;				case MHD_RCP_CMD_LEFT_DOWN:					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_LEFT_DOWN\n\n", (int)eventParameter ));					break;      				case MHD_RCP_CMD_ROOT_MENU:					TX_DEBUG_PRINT(( "\nRoot Menu received\n\n", (int)eventParameter ));					break;				case MHD_RCP_CMD_SETUP_MENU:					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_SETUP_MENU\n\n", (int)eventParameter ));					break;      				case MHD_RCP_CMD_CONTENTS_MENU:					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_CONTENTS_MENU\n\n", (int)eventParameter ));					break;      				case MHD_RCP_CMD_FAVORITE_MENU:					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_FAVORITE_MENU\n\n", (int)eventParameter ));					break;            				case MHD_RCP_CMD_EXIT:					TX_DEBUG_PRINT(( "\nExit received\n\n", (int)eventParameter ));					break;				case MHD_RCP_CMD_NUM_0:					TX_DEBUG_PRINT(( "\nNumber 0 received\n\n", (int)eventParameter ));					break;				case MHD_RCP_CMD_NUM_1:					TX_DEBUG_PRINT(( "\nNumber 1 received\n\n", (int)eventParameter ));					break;				case MHD_RCP_CMD_NUM_2:					TX_DEBUG_PRINT(( "\nNumber 2 received\n\n", (int)eventParameter ));					break;				case MHD_RCP_CMD_NUM_3:					TX_DEBUG_PRINT(( "\nNumber 3 received\n\n", (int)eventParameter ));					break;				case MHD_RCP_CMD_NUM_4:					TX_DEBUG_PRINT(( "\nNumber 4 received\n\n", (int)eventParameter ));					break;				case MHD_RCP_CMD_NUM_5:					TX_DEBUG_PRINT(( "\nNumber 5 received\n\n", (int)eventParameter ));					break;				case MHD_RCP_CMD_NUM_6:					TX_DEBUG_PRINT(( "\nNumber 6 received\n\n", (int)eventParameter ));					break;				case MHD_RCP_CMD_NUM_7:					TX_DEBUG_PRINT(( "\nNumber 7 received\n\n", (int)eventParameter ));					break;				case MHD_RCP_CMD_NUM_8:					TX_DEBUG_PRINT(( "\nNumber 8 received\n\n", (int)eventParameter ));					break;				case MHD_RCP_CMD_NUM_9:					TX_DEBUG_PRINT(( "\nNumber 9 received\n\n", (int)eventParameter ));					break;				case MHD_RCP_CMD_DOT:					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_DOT\n\n", (int)eventParameter ));					break;          				case MHD_RCP_CMD_ENTER:					TX_DEBUG_PRINT(( "\nEnter received\n\n", (int)eventParameter ));					break;				case MHD_RCP_CMD_CLEAR:					TX_DEBUG_PRINT(( "\nClear received\n\n", (int)eventParameter ));					break;				case MHD_RCP_CMD_CH_UP:					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_CH_UP\n\n", (int)eventParameter ));					break; 				case MHD_RCP_CMD_CH_DOWN:					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_CH_DOWN\n\n", (int)eventParameter ));					break;       				case MHD_RCP_CMD_PRE_CH:					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_PRE_CH\n\n", (int)eventParameter ));					break;           				case MHD_RCP_CMD_SOUND_SELECT:					TX_DEBUG_PRINT(( "\nSound Select received\n\n", (int)eventParameter ));					break;				case MHD_RCP_CMD_INPUT_SELECT:					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_INPUT_SELECT\n\n", (int)eventParameter ));					break;    				case MHD_RCP_CMD_SHOW_INFO:					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_SHOW_INFO\n\n", (int)eventParameter ));					break;     				case MHD_RCP_CMD_HELP:					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_HELP\n\n", (int)eventParameter ));					break;   				case MHD_RCP_CMD_PAGE_UP:					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_PAGE_UP\n\n", (int)eventParameter ));					break;  				case MHD_RCP_CMD_PAGE_DOWN:					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_PAGE_DOWN\n\n", (int)eventParameter ));					break;             				case MHD_RCP_CMD_VOL_UP:					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_VOL_UP\n\n", (int)eventParameter ));					break;             				case MHD_RCP_CMD_VOL_DOWN:					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_VOL_DOWN\n\n", (int)eventParameter ));					break;             				case MHD_RCP_CMD_MUTE:					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_MUTE\n\n", (int)eventParameter ));					break;             				case MHD_RCP_CMD_PLAY:					TX_DEBUG_PRINT(( "\nPlay received\n\n", (int)eventParameter ));					break;				case MHD_RCP_CMD_STOP:					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_STOP\n\n", (int)eventParameter ));					break;   				case MHD_RCP_CMD_PAUSE:					TX_DEBUG_PRINT(( "\nPause received\n\n", (int)eventParameter ));					break;				case MHD_RCP_CMD_RECORD:					TX_DEBUG_PRINT(( "\n MHD_RCP_CMD_RECORD\n\n", (int)eventParameter ));					break;   				case MHD_RCP_CMD_FAST_FWD:					TX_DEBUG_PRINT(( "\nFastfwd received\n\n", (int)eventParameter ));					break;				case MHD_RCP_CMD_REWIND:					TX_DEBUG_PRINT(( "\nRewind received\n\n", (int)eventParameter ));					break;				case MHD_RCP_CMD_EJECT:					TX_DEBUG_PRINT(( "\nEject received\n\n", (int)eventParameter ));					break;				case MHD_RCP_CMD_FWD:					TX_DEBUG_PRINT(( "\nForward received\n\n", (int)eventParameter ));					break;				case MHD_RCP_CMD_BKWD:					TX_DEBUG_PRINT(( "\nBackward received\n\n", (int)eventParameter ));					break;				case MHD_RCP_CMD_PLAY_FUNC:					TX_DEBUG_PRINT(( "\nPlay Function received\n\n", (int)eventParameter ));					break;				case MHD_RCP_CMD_PAUSE_PLAY_FUNC:					TX_DEBUG_PRINT(( "\nPause_Play Function received\n\n", (int)eventParameter ));					break;				case MHD_RCP_CMD_STOP_FUNC:					TX_DEBUG_PRINT(( "\nStop Function received\n\n", (int)eventParameter ));					break;				default:					break;			}      rcpKeyCode = eventParameter;			SiiMhlTxRcpkSend(rcpKeyCode);			break;		case	MHL_TX_EVENT_RCPK_RECEIVED:			printk(KERN_ERR "App: Received an RCPK = \n");			break;		case	MHL_TX_EVENT_RCPE_RECEIVED:			printk(KERN_ERR "App: Received an RCPE = \n");			break;		default:			break;	}}void	AppVbusControl( bool powerOn ){	if( powerOn )	{		printk(KERN_ERR "App: Peer's POW bit is set. Turn the VBUS power OFF here.\n");	}	else	{		printk(KERN_ERR "App: Peer's POW bit is cleared. Turn the VBUS power ON here.\n");	}}void sii9244_interrupt_event(void){	byte	event;	byte	eventParameter;	byte	flag;	do {		flag = 0;		SiiMhlTxGetEvents( &event, &eventParameter );		if( MHL_TX_EVENT_NONE != event )		{			AppRcpDemo( event, eventParameter);		}    	if(mhl_cable_status == MHL_TV_OFF_CABLE_CONNECT)		{			byte tmp;    		tmp = I2C_ReadByte(SA_TX_Page0_Primary, (0x74));       		I2C_WriteByte(SA_TX_Page0_Primary, (0x74), tmp);       		tmp = I2C_ReadByte(SA_TX_Page0_Primary, 0x71);    		I2C_WriteByte(SA_TX_Page0_Primary, 0x71, tmp);    		tmp = ReadByteCBUS(0x08);    		WriteByteCBUS(0x08, tmp);      		tmp = ReadByteCBUS(0x1E);    		WriteByteCBUS(0x1E, tmp);    		TX_DEBUG_PRINT(("mhl_cable_status == MHL_TV_OFF_CABLE_CONNECT\n"));    		return ;    	}    	else if(((fwPowerState == TX_POWER_STATE_D0_MHL)||(fwPowerState == TX_POWER_STATE_D0_NO_MHL))&&         mhl_cable_status)       {          byte tmp;          tmp = I2C_ReadByte(SA_TX_Page0_Primary, (0x74));   	        flag |= (tmp&INTR_4_DESIRED_MASK);	            printk("#1 (0x74) flag: %x\n",(int) flag );                    tmp = I2C_ReadByte(SA_TX_Page0_Primary, 0x71);                    flag |= (tmp&INTR_1_DESIRED_MASK);          printk("#1 (0x71) flag: %x\n",(int) flag );          if(mhlTxConfig.mhlConnected == MHL_TX_EVENT_DISCONNECTION)          {            tmp = ReadByteCBUS(0x08);            printk("#2 (ReadByteCBUS(0x08)) Temp: %x\n",(int) tmp );            WriteByteCBUS(0x08, tmp);              tmp = ReadByteCBUS(0x1E);            printk("#2 (ReadByteCBUS(0x1E)) Temp: %x\n",(int) tmp );            WriteByteCBUS(0x1E, tmp);              }          else          {			tmp = ReadByteCBUS(0x08);            flag |= (tmp&INTR_CBUS1_DESIRED_MASK);            printk("#1 (ReadByteCBUS(0x08)) Temp: %x\n",(int) flag );			tmp = ReadByteCBUS(0x1E);            flag |= (tmp&INTR_CBUS2_DESIRED_MASK);            printk("#1 (ReadByteCBUS(0x1E)) Temp: %x\n",(int) flag );                        }			if((flag == 0xFA)||(flag == 0xFF))				flag = 0;		}	}while(flag);	printk(KERN_ERR "[MHL]sii9244_interrupt_event :: flag: %x\n",(int) flag );}EXPORT_SYMBOL(sii9244_interrupt_event);