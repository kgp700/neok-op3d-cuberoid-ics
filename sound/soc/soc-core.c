#include <linux/module.h>#include <linux/moduleparam.h>#include <linux/init.h>#include <linux/delay.h>#include <linux/pm.h>#include <linux/bitops.h>#include <linux/debugfs.h>#include <linux/platform_device.h>#include <linux/slab.h>#include <sound/ac97_codec.h>#include <sound/core.h>#include <sound/pcm.h>#include <sound/pcm_params.h>#include <sound/soc.h>#include <sound/soc-dapm.h>#include <sound/initval.h>#define NAME_SIZE	32static DECLARE_WAIT_QUEUE_HEAD(soc_pm_waitq);#ifdef CONFIG_DEBUG_FSstatic struct dentry *debugfs_root;#endifstatic DEFINE_MUTEX(client_mutex);static LIST_HEAD(card_list);static LIST_HEAD(dai_list);static LIST_HEAD(platform_list);static LIST_HEAD(codec_list);static int snd_soc_register_card(struct snd_soc_card *card);static int snd_soc_unregister_card(struct snd_soc_card *card);static int soc_new_pcm(struct snd_soc_pcm_runtime *rtd, int num);static int s_bsuspend = 0;static int s_partial_suspend = 0;	static int pmdown_time = 5000;module_param(pmdown_time, int, 0);MODULE_PARM_DESC(pmdown_time, "DAPM stream powerdown time (msecs)");static const struct snd_pcm_hardware no_host_hardware = {	.info			= SNDRV_PCM_INFO_MMAP |				  SNDRV_PCM_INFO_MMAP_VALID |				  SNDRV_PCM_INFO_INTERLEAVED |				  SNDRV_PCM_INFO_PAUSE |				  SNDRV_PCM_INFO_RESUME,	.formats		= SNDRV_PCM_FMTBIT_S16_LE |				  SNDRV_PCM_FMTBIT_S32_LE,	.period_bytes_min	= PAGE_SIZE >> 2,	.period_bytes_max	= PAGE_SIZE >> 1,	.periods_min		= 2,	.periods_max		= 4,	.buffer_bytes_max	= PAGE_SIZE,};static int run_delayed_work(struct delayed_work *dwork){	int ret;	ret = cancel_delayed_work(dwork);	if (ret) {		schedule_delayed_work(dwork, 0);		flush_scheduled_work();	}	return ret;}static ssize_t soc_codec_reg_show(struct snd_soc_codec *codec, char *buf){	int ret, i, step = 1, count = 0;	if (!codec->driver->reg_cache_size)		return 0;	if (codec->driver->reg_cache_step)		step = codec->driver->reg_cache_step;	count += sprintf(buf, "%s registers\n", codec->name);	for (i = 0; i < codec->driver->reg_cache_size; i += step) {		if (codec->driver->readable_register && !codec->driver->readable_register(i))			continue;		count += sprintf(buf + count, "%2x: ", i);		if (count >= PAGE_SIZE - 1)			break;		if (codec->driver->display_register) {			count += codec->driver->display_register(codec, buf + count,							 PAGE_SIZE - count, i);		} else {			ret = codec->driver->read(codec, i);			if (ret >= 0)				count += snprintf(buf + count,						  PAGE_SIZE - count,						  "%4x", ret);			else				count += snprintf(buf + count,						  PAGE_SIZE - count,						  "<no data: %d>", ret);		}		if (count >= PAGE_SIZE - 1)			break;		count += snprintf(buf + count, PAGE_SIZE - count, "\n");		if (count >= PAGE_SIZE - 1)			break;	}	if (count >= PAGE_SIZE)		count = PAGE_SIZE - 1;	return count;}static ssize_t codec_reg_show(struct device *dev,	struct device_attribute *attr, char *buf){	struct snd_soc_pcm_runtime *rtd =			container_of(dev, struct snd_soc_pcm_runtime, dev);	return soc_codec_reg_show(rtd->codec, buf);}#if defined(CONFIG_MACH_LGE_COSMOPOLITAN) ssize_t codec_reg_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count){	int reg, data;	char *r, *d;	struct snd_soc_pcm_runtime *rtd =			container_of(dev, struct snd_soc_pcm_runtime, dev);	r= &buf[0];	d= &buf[5];	reg = simple_strtoul(r, NULL, 16);	data = simple_strtoul(d, NULL, 16);	snd_soc_write(rtd->codec, reg, data);	return count;}static DEVICE_ATTR(codec_reg, 0664, codec_reg_show, codec_reg_store);#elsestatic DEVICE_ATTR(codec_reg, 0444, codec_reg_show, NULL);#endif static ssize_t pmdown_time_show(struct device *dev,				struct device_attribute *attr, char *buf){	struct snd_soc_pcm_runtime *rtd =			container_of(dev, struct snd_soc_pcm_runtime, dev);	return sprintf(buf, "%ld\n", rtd->pmdown_time);}static ssize_t pmdown_time_set(struct device *dev,			       struct device_attribute *attr,			       const char *buf, size_t count){	struct snd_soc_pcm_runtime *rtd =			container_of(dev, struct snd_soc_pcm_runtime, dev);	strict_strtol(buf, 10, &rtd->pmdown_time);	return count;}static DEVICE_ATTR(pmdown_time, 0644, pmdown_time_show, pmdown_time_set);#ifdef CONFIG_DEBUG_FSstatic int codec_reg_open_file(struct inode *inode, struct file *file){	file->private_data = inode->i_private;	return 0;}static ssize_t codec_reg_read_file(struct file *file, char __user *user_buf,			       size_t count, loff_t *ppos){	ssize_t ret;	struct snd_soc_codec *codec = file->private_data;	char *buf = kmalloc(PAGE_SIZE, GFP_KERNEL);	if (!buf)		return -ENOMEM;	ret = soc_codec_reg_show(codec, buf);	if (ret >= 0)		ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);	kfree(buf);	return ret;}static ssize_t codec_reg_write_file(struct file *file,		const char __user *user_buf, size_t count, loff_t *ppos){	char buf[32];	int buf_size;	char *start = buf;	unsigned long reg, value;	int step = 1;	struct snd_soc_codec *codec = file->private_data;	buf_size = min(count, (sizeof(buf)-1));	if (copy_from_user(buf, user_buf, buf_size))		return -EFAULT;	buf[buf_size] = 0;	if (codec->driver->reg_cache_step)		step = codec->driver->reg_cache_step;	while (*start == ' ')		start++;	reg = simple_strtoul(start, &start, 16);	if ((reg >= codec->driver->reg_cache_size) || (reg % step))		return -EINVAL;	while (*start == ' ')		start++;	if (strict_strtoul(start, 16, &value))		return -EINVAL;	codec->driver->write(codec, reg, value);	return buf_size;}static const struct file_operations codec_reg_fops = {	.open = codec_reg_open_file,	.read = codec_reg_read_file,	.write = codec_reg_write_file,};static void soc_init_codec_debugfs(struct snd_soc_codec *codec){	codec->debugfs_codec_root = debugfs_create_dir(codec->name ,						       debugfs_root);	if (!codec->debugfs_codec_root) {		printk(KERN_WARNING		       "ASoC: Failed to create codec debugfs directory\n");		return;	}	codec->debugfs_reg = debugfs_create_file("codec_reg", 0644,						 codec->debugfs_codec_root,						 codec, &codec_reg_fops);	if (!codec->debugfs_reg)		printk(KERN_WARNING		       "ASoC: Failed to create codec register debugfs file\n");	codec->debugfs_pop_time = debugfs_create_u32("dapm_pop_time", 0744,						     codec->debugfs_codec_root,						     &codec->dapm->pop_time);	if (!codec->debugfs_pop_time)		printk(KERN_WARNING		       "Failed to create pop time debugfs file\n");	codec->dapm->debugfs_dapm = debugfs_create_dir("dapm",						 codec->debugfs_codec_root);	if (!codec->dapm->debugfs_dapm)		printk(KERN_WARNING		       "Failed to create DAPM debugfs directory\n");	snd_soc_dapm_debugfs_init(codec->dapm);}static void soc_cleanup_codec_debugfs(struct snd_soc_codec *codec){	debugfs_remove_recursive(codec->debugfs_codec_root);}static void soc_init_platform_debugfs(struct snd_soc_platform *platform){	char platform_root[128];	snprintf(platform_root, sizeof(platform_root),			"%s", dev_name(platform->dev));	platform->debugfs_platform_root = debugfs_create_dir(platform_root,						       debugfs_root);	if (!platform->debugfs_platform_root) {		printk(KERN_WARNING		       "ASoC: Failed to create platform debugfs directory\n");		return;	}	platform->dapm->debugfs_dapm = debugfs_create_dir("dapm",						 platform->debugfs_platform_root);	if (!platform->dapm->debugfs_dapm)		printk(KERN_WARNING		       "Failed to create DAPM debugfs directory\n");	snd_soc_dapm_debugfs_init(platform->dapm);}static void soc_cleanup_platform_debugfs(struct snd_soc_platform *platform){	debugfs_remove_recursive(platform->debugfs_platform_root);}#elsestatic inline void soc_init_codec_debugfs(struct snd_soc_codec *codec){}static inline void soc_cleanup_codec_debugfs(struct snd_soc_codec *codec){}static inline void soc_init_platform_debugfs(struct snd_soc_platform *platform){}static inline void soc_cleanup_platform_debugfs(struct snd_soc_platform *platform){}#endif#ifdef CONFIG_SND_SOC_AC97_BUSstatic int soc_ac97_dev_unregister(struct snd_soc_codec *codec){	if (codec->ac97->dev.bus)		device_unregister(&codec->ac97->dev);	return 0;}static void soc_ac97_device_release(struct device *dev){}static int soc_ac97_dev_register(struct snd_soc_codec *codec){	int err;	codec->ac97->dev.bus = &ac97_bus_type;	codec->ac97->dev.parent = codec->card->dev;	codec->ac97->dev.release = soc_ac97_device_release;	dev_set_name(&codec->ac97->dev, "%d-%d:%s",		     codec->ac97->bus->card->number, 0, codec->name);	err = device_register(&codec->ac97->dev);	if (err < 0) {		snd_printk(KERN_ERR "Can't register ac97 bus\n");		codec->ac97->dev.bus = NULL;		return err;	}	return 0;}#endifstatic int soc_pcm_apply_symmetry(struct snd_pcm_substream *substream){	struct snd_soc_pcm_runtime *rtd = substream->private_data;	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;	struct snd_soc_dai *codec_dai = rtd->codec_dai;	int ret;	if (codec_dai->driver->symmetric_rates || cpu_dai->driver->symmetric_rates ||			rtd->dai_link->symmetric_rates) {		dev_dbg(&rtd->dev, "Symmetry forces %dHz rate\n",				rtd->rate);		ret = snd_pcm_hw_constraint_minmax(substream->runtime,						   SNDRV_PCM_HW_PARAM_RATE,						   rtd->rate,						   rtd->rate);		if (ret < 0) {			dev_err(&rtd->dev,				"Unable to apply rate symmetry constraint: %d\n", ret);			return ret;		}	}	return 0;}static int is_be_supported(struct snd_soc_pcm_runtime *rtd, const char *link){	int i;	for (i= 0; i < rtd->dai_link->num_be; i++) {		if(!strcmp(rtd->dai_link->supported_be[i], link))			return 1;	}	return 0;}int snd_soc_get_backend_dais(struct snd_pcm_substream *substream){	struct snd_soc_pcm_runtime *rtd = substream->private_data;	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;	struct snd_soc_card *card = rtd->card;	int i, num;	const char *fe_aif = NULL, *be_aif;	enum snd_soc_dapm_type fe_type, be_type;	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {		fe_type = snd_soc_dapm_aif_in;		be_type = snd_soc_dapm_aif_out;	} else {		fe_type = snd_soc_dapm_aif_out;		be_type = snd_soc_dapm_aif_in;	}	for (i = 0; i < card->num_links; i++) {		if (card->rtd[i].dai_link->dynamic)			continue;		fe_aif = snd_soc_dapm_get_aif(card->rtd[i].platform->dapm,				cpu_dai->driver->name, fe_type);	}	if (fe_aif == NULL) {		dev_err(&rtd->dev, "no frontend widgets for stream %s\n",						cpu_dai->driver->name);		return 0;	} else		dev_dbg(&rtd->dev, "got fe %s\n", fe_aif);	for (i = 0; i < card->num_links; i++) {		if (card->rtd[i].dai_link->dynamic)			continue;		if (card->rtd[i].dai_link->no_pcm) {			if (!is_be_supported(rtd, card->rtd[i].dai_link->name))				continue;			be_aif = snd_soc_dapm_get_aif(card->rtd[i].platform->dapm,					card->rtd[i].dai_link->stream_name, be_type);			if (be_aif == NULL) {				dev_dbg(&rtd->dev, "no backend widget for stream %s\n",						card->rtd[i].dai_link->stream_name);				continue;			}			dev_dbg(&rtd->dev, "got be %s for stream %s\n", be_aif,					card->rtd[i].dai_link->stream_name);			num = snd_soc_scenario_set_path(card->rtd[i].platform->dapm,						fe_aif, be_aif, substream->stream);			if (num > 0) {				if (rtd->num_be[substream->stream] == SND_SOC_MAX_BE)					dev_dbg(&rtd->dev, "no more backends permitted\n");				else {					dev_dbg(&rtd->dev, "** active path for %s to %s\n", fe_aif, be_aif);					rtd->be_rtd[rtd->num_be[substream->stream]++][substream->stream] = &card->rtd[i];					card->rtd[i].fe_clients++;				}			}		}	}	return rtd->num_be[substream->stream] ? rtd->num_be[substream->stream] : -EINVAL;}EXPORT_SYMBOL_GPL(snd_soc_get_backend_dais);void snd_soc_put_backend_dais(struct snd_pcm_substream *substream){	struct snd_soc_pcm_runtime *rtd = substream->private_data;	int i;	for (i = 0; i < rtd->num_be[substream->stream]; i++) {		rtd->be_rtd[i][substream->stream]->fe_clients--;		rtd->be_rtd[i][substream->stream] = NULL;	}	rtd->num_be[substream->stream] = 0;}EXPORT_SYMBOL_GPL(snd_soc_put_backend_dais);int snd_soc_pcm_open(struct snd_pcm_substream *substream){	struct snd_soc_pcm_runtime *rtd = substream->private_data;	struct snd_pcm_runtime *runtime = substream->runtime;	struct snd_soc_platform *platform = rtd->platform;	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;	struct snd_soc_dai *codec_dai = rtd->codec_dai;	struct snd_soc_dai_driver *cpu_dai_drv = cpu_dai->driver;	struct snd_soc_dai_driver *codec_dai_drv = codec_dai->driver;	int ret = 0;	mutex_lock(&rtd->pcm_mutex);	if (rtd->dai_link->dynamic) {		ret = snd_soc_get_backend_dais(substream);		if (ret < 0) {			printk(KERN_ERR "asoc: no valid backend routes for PCM: %s\n",					dev_name(&rtd->dev));			goto out;		}	}	if (rtd->dai_link->no_pcm) {		if (rtd->fe_clients == 0) {			dev_err(&rtd->dev, "operations not permitted on backend DAI\n");			ret = -ENODEV;			goto out;		}		if (rtd->be_active++)			goto no_pcm;	}	if (rtd->dai_link->no_host_mode == SND_SOC_DAI_LINK_NO_HOST)		snd_soc_set_runtime_hwparams(substream, &no_host_hardware);	if (cpu_dai->driver->ops->startup) {		ret = cpu_dai->driver->ops->startup(substream, cpu_dai);		if (ret < 0) {			printk(KERN_ERR "asoc: can't open interface %s\n",				cpu_dai->name);			goto out;		}	}	if (platform->driver->ops->open) {		ret = platform->driver->ops->open(substream);		if (ret < 0) {			printk(KERN_ERR "asoc: can't open platform %s\n", platform->name);			goto platform_err;		}	}	if (codec_dai->driver->ops->startup) {		ret = codec_dai->driver->ops->startup(substream, codec_dai);		if (ret < 0) {			printk(KERN_ERR "asoc: can't open codec %s\n",				codec_dai->name);			goto codec_dai_err;		}	}	if (rtd->dai_link->ops && rtd->dai_link->ops->startup) {		ret = rtd->dai_link->ops->startup(substream);		if (ret < 0) {			printk(KERN_ERR "asoc: %s startup failed\n", rtd->dai_link->name);			goto machine_err;		}	}	if (rtd->dai_link->no_pcm)		goto no_pcm;	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {		runtime->hw.rate_min =			max(codec_dai_drv->playback.rate_min,			    cpu_dai_drv->playback.rate_min);		runtime->hw.rate_max =			min(codec_dai_drv->playback.rate_max,			    cpu_dai_drv->playback.rate_max);		runtime->hw.channels_min =			max(codec_dai_drv->playback.channels_min,				cpu_dai_drv->playback.channels_min);		runtime->hw.channels_max =			min(codec_dai_drv->playback.channels_max,				cpu_dai_drv->playback.channels_max);		runtime->hw.formats =			codec_dai_drv->playback.formats & cpu_dai_drv->playback.formats;		runtime->hw.rates =			codec_dai_drv->playback.rates & cpu_dai_drv->playback.rates;		if (codec_dai_drv->playback.rates			   & (SNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_CONTINUOUS))			runtime->hw.rates |= cpu_dai_drv->playback.rates;		if (cpu_dai_drv->playback.rates			   & (SNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_CONTINUOUS))			runtime->hw.rates |= codec_dai_drv->playback.rates;	} else {		runtime->hw.rate_min =			max(codec_dai_drv->capture.rate_min,			    cpu_dai_drv->capture.rate_min);		runtime->hw.rate_max =			min(codec_dai_drv->capture.rate_max,			    cpu_dai_drv->capture.rate_max);		runtime->hw.channels_min =			max(codec_dai_drv->capture.channels_min,				cpu_dai_drv->capture.channels_min);		runtime->hw.channels_max =			min(codec_dai_drv->capture.channels_max,				cpu_dai_drv->capture.channels_max);		runtime->hw.formats =			codec_dai_drv->capture.formats & cpu_dai_drv->capture.formats;		runtime->hw.rates =			codec_dai_drv->capture.rates & cpu_dai_drv->capture.rates;		if (codec_dai_drv->capture.rates			   & (SNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_CONTINUOUS))			runtime->hw.rates |= cpu_dai_drv->capture.rates;		if (cpu_dai_drv->capture.rates			   & (SNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_CONTINUOUS))			runtime->hw.rates |= codec_dai_drv->capture.rates;	}	snd_pcm_limit_hw_rates(runtime);	if (!runtime->hw.rates) {		printk(KERN_ERR "asoc: %s <-> %s No matching rates\n",			codec_dai->name, cpu_dai->name);		goto config_err;	}	if (!runtime->hw.formats) {		printk(KERN_ERR "asoc: %s <-> %s No matching formats\n",			codec_dai->name, cpu_dai->name);		goto config_err;	}	if (!runtime->hw.channels_min || !runtime->hw.channels_max) {		printk(KERN_ERR "asoc: %s <-> %s No matching channels\n",				codec_dai->name, cpu_dai->name);		goto config_err;	}	if (cpu_dai->active || codec_dai->active) {		ret = soc_pcm_apply_symmetry(substream);		if (ret != 0)			goto config_err;	}	pr_debug("asoc: %s <-> %s info:\n",			codec_dai->name, cpu_dai->name);	pr_debug("asoc: rate mask 0x%x\n", runtime->hw.rates);	pr_debug("asoc: min ch %d max ch %d\n", runtime->hw.channels_min,		 runtime->hw.channels_max);	pr_debug("asoc: min rate %d max rate %d\n", runtime->hw.rate_min,		 runtime->hw.rate_max);no_pcm:	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {		cpu_dai->playback_active++;		codec_dai->playback_active++;	} else {		cpu_dai->capture_active++;		codec_dai->capture_active++;	}	cpu_dai->active++;	codec_dai->active++;	rtd->codec->active++;	mutex_unlock(&rtd->pcm_mutex);	return 0;config_err:	if (rtd->dai_link->ops && rtd->dai_link->ops->shutdown)		rtd->dai_link->ops->shutdown(substream);machine_err:	if (codec_dai->driver->ops->shutdown)		codec_dai->driver->ops->shutdown(substream, codec_dai);codec_dai_err:	if (platform->driver->ops->close)		platform->driver->ops->close(substream);platform_err:	if (cpu_dai->driver->ops->shutdown)		cpu_dai->driver->ops->shutdown(substream, cpu_dai);out:	if (rtd->dai_link->dynamic)		snd_soc_put_backend_dais(substream);	mutex_unlock(&rtd->pcm_mutex);	return ret;}EXPORT_SYMBOL_GPL(snd_soc_pcm_open);static void close_delayed_work(struct work_struct *work){	struct snd_soc_pcm_runtime *rtd =			container_of(work, struct snd_soc_pcm_runtime, delayed_work.work);	struct snd_soc_dai *codec_dai = rtd->codec_dai;	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;	mutex_lock(&rtd->pcm_mutex);	pr_debug("pop wq checking: %s status: %s waiting: %s\n",		 codec_dai->driver->playback.stream_name,		 codec_dai->playback_active ? "active" : "inactive",		 codec_dai->pop_wait ? "yes" : "no");	if (codec_dai->pop_wait == 1) {		codec_dai->pop_wait = 0;		if (rtd->dai_link->dynamic)			snd_soc_dapm_stream_event(rtd, SNDRV_PCM_STREAM_PLAYBACK,					cpu_dai->driver->playback.stream_name,					SND_SOC_DAPM_STREAM_STOP);		else			snd_soc_dapm_stream_event(rtd, SNDRV_PCM_STREAM_PLAYBACK,					codec_dai->driver->playback.stream_name,					SND_SOC_DAPM_STREAM_STOP);	}	mutex_unlock(&rtd->pcm_mutex);}int snd_soc_pcm_close(struct snd_pcm_substream *substream){	struct snd_soc_pcm_runtime *rtd = substream->private_data;	struct snd_soc_platform *platform = rtd->platform;	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;	struct snd_soc_dai *codec_dai = rtd->codec_dai;	struct snd_soc_codec *codec = rtd->codec;	mutex_lock(&rtd->pcm_mutex);	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {		cpu_dai->playback_active--;		codec_dai->playback_active--;	} else {		cpu_dai->capture_active--;		codec_dai->capture_active--;	}	cpu_dai->active--;	codec_dai->active--;	codec->active--;	#if 0	if (rtd->dai_link->no_pcm)	{		rtd->be_active--;		if( rtd->be_active )				goto out;	}#endif		if (rtd->dai_link->no_pcm) {		if (--rtd->be_active)			goto no_pcm;	}	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)		snd_soc_dai_digital_mute(codec_dai, 1);	if (cpu_dai->driver->ops->shutdown)		cpu_dai->driver->ops->shutdown(substream, cpu_dai);	if (codec_dai->driver->ops->shutdown)		codec_dai->driver->ops->shutdown(substream, codec_dai);	if (rtd->dai_link->ops && rtd->dai_link->ops->shutdown)		rtd->dai_link->ops->shutdown(substream);	if (platform->driver->ops->close)		platform->driver->ops->close(substream);	cpu_dai->runtime = NULL;	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {		if (rtd->dai_link->dynamic)			snd_soc_dapm_stream_event(rtd, SNDRV_PCM_STREAM_PLAYBACK,					cpu_dai->driver->playback.stream_name,					SND_SOC_DAPM_STREAM_STOP);		codec_dai->pop_wait = 1;		schedule_delayed_work(&rtd->delayed_work,			msecs_to_jiffies(rtd->pmdown_time));	} else {				if (rtd->dai_link->dynamic)			snd_soc_dapm_stream_event(rtd, SNDRV_PCM_STREAM_CAPTURE,					cpu_dai->driver->capture.stream_name,					SND_SOC_DAPM_STREAM_STOP);		else			snd_soc_dapm_stream_event(rtd, SNDRV_PCM_STREAM_CAPTURE,					codec_dai->driver->capture.stream_name,					SND_SOC_DAPM_STREAM_STOP);	}	if (rtd->dai_link->dynamic)		snd_soc_put_backend_dais(substream);no_pcm:	mutex_unlock(&rtd->pcm_mutex);	return 0;}EXPORT_SYMBOL_GPL(snd_soc_pcm_close);int snd_soc_pcm_prepare(struct snd_pcm_substream *substream){	struct snd_soc_pcm_runtime *rtd = substream->private_data;	struct snd_soc_platform *platform = rtd->platform;	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;	struct snd_soc_dai *codec_dai = rtd->codec_dai;	int ret = 0;	mutex_lock(&rtd->pcm_mutex);	if (rtd->dai_link->ops && rtd->dai_link->ops->prepare) {		ret = rtd->dai_link->ops->prepare(substream);		if (ret < 0) {			printk(KERN_ERR "asoc: machine prepare error\n");			goto out;		}	}	if (platform->driver->ops->prepare) {		ret = platform->driver->ops->prepare(substream);		if (ret < 0) {			printk(KERN_ERR "asoc: platform prepare error\n");			goto out;		}	}	if (codec_dai->driver->ops->prepare) {		ret = codec_dai->driver->ops->prepare(substream, codec_dai);		if (ret < 0) {			printk(KERN_ERR "asoc: codec DAI prepare error\n");			goto out;		}	}	if (cpu_dai->driver->ops->prepare) {		ret = cpu_dai->driver->ops->prepare(substream, cpu_dai);		if (ret < 0) {			printk(KERN_ERR "asoc: cpu DAI prepare error\n");			goto out;		}	}	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&	    codec_dai->pop_wait) {		codec_dai->pop_wait = 0;		cancel_delayed_work(&rtd->delayed_work);	}	if (rtd->dai_link->dynamic) {		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)			snd_soc_dapm_stream_event(rtd, SNDRV_PCM_STREAM_PLAYBACK,					  cpu_dai->driver->playback.stream_name,					  SND_SOC_DAPM_STREAM_START);		else			snd_soc_dapm_stream_event(rtd, SNDRV_PCM_STREAM_CAPTURE,					  cpu_dai->driver->capture.stream_name,					  SND_SOC_DAPM_STREAM_START);	} else {		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)			snd_soc_dapm_stream_event(rtd, SNDRV_PCM_STREAM_PLAYBACK,					  codec_dai->driver->playback.stream_name,					  SND_SOC_DAPM_STREAM_START);		else			snd_soc_dapm_stream_event(rtd, SNDRV_PCM_STREAM_CAPTURE,					  codec_dai->driver->capture.stream_name,					  SND_SOC_DAPM_STREAM_START);	}	snd_soc_dai_digital_mute(codec_dai, 0);out:	mutex_unlock(&rtd->pcm_mutex);	return ret;}EXPORT_SYMBOL_GPL(snd_soc_pcm_prepare);int snd_soc_pcm_hw_params(struct snd_pcm_substream *substream,				struct snd_pcm_hw_params *params){	struct snd_soc_pcm_runtime *rtd = substream->private_data;	struct snd_soc_platform *platform = rtd->platform;	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;	struct snd_soc_dai *codec_dai = rtd->codec_dai;	int ret = 0;	mutex_lock(&rtd->pcm_mutex);	if (rtd->dai_link->ops && rtd->dai_link->ops->hw_params) {		ret = rtd->dai_link->ops->hw_params(substream, params);		if (ret < 0) {			printk(KERN_ERR "asoc: machine hw_params failed\n");			goto out;		}	}	if (codec_dai->driver->ops->hw_params) {		ret = codec_dai->driver->ops->hw_params(substream, params, codec_dai);		if (ret < 0) {			printk(KERN_ERR "asoc: can't set codec %s hw params\n",				codec_dai->name);			goto codec_err;		}	}	if (cpu_dai->driver->ops->hw_params) {		ret = cpu_dai->driver->ops->hw_params(substream, params, cpu_dai);		if (ret < 0) {			printk(KERN_ERR "asoc: interface %s hw params failed\n",				cpu_dai->name);			goto interface_err;		}	}	if (platform->driver->ops->hw_params) {		ret = platform->driver->ops->hw_params(substream, params);		if (ret < 0) {			printk(KERN_ERR "asoc: platform %s hw params failed\n",				platform->name);			goto platform_err;		}	}	rtd->rate = params_rate(params);	if (rtd->dai_link->no_host_mode == SND_SOC_DAI_LINK_NO_HOST) {		substream->dma_buffer.dev.type = SNDRV_DMA_TYPE_DEV;		substream->dma_buffer.dev.dev = &rtd->dev;		substream->dma_buffer.private_data = NULL;		ret = snd_pcm_lib_malloc_pages(substream, PAGE_SIZE);		if (ret < 0)			goto platform_err;	}out:	mutex_unlock(&rtd->pcm_mutex);	return ret;platform_err:	if (cpu_dai->driver->ops->hw_free)		cpu_dai->driver->ops->hw_free(substream, cpu_dai);interface_err:	if (codec_dai->driver->ops->hw_free)		codec_dai->driver->ops->hw_free(substream, codec_dai);codec_err:	if (rtd->dai_link->ops && rtd->dai_link->ops->hw_free)		rtd->dai_link->ops->hw_free(substream);	mutex_unlock(&rtd->pcm_mutex);	return ret;}EXPORT_SYMBOL_GPL(snd_soc_pcm_hw_params);int snd_soc_pcm_hw_free(struct snd_pcm_substream *substream){	struct snd_soc_pcm_runtime *rtd = substream->private_data;	struct snd_soc_platform *platform = rtd->platform;	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;	struct snd_soc_dai *codec_dai = rtd->codec_dai;	struct snd_soc_codec *codec = rtd->codec;	mutex_lock(&rtd->pcm_mutex);	if (!codec->active)		snd_soc_dai_digital_mute(codec_dai, 1);	if (rtd->dai_link->ops && rtd->dai_link->ops->hw_free)		rtd->dai_link->ops->hw_free(substream);	if (platform->driver->ops->hw_free)		platform->driver->ops->hw_free(substream);	if (codec_dai->driver->ops->hw_free)		codec_dai->driver->ops->hw_free(substream, codec_dai);	if (cpu_dai->driver->ops->hw_free)		cpu_dai->driver->ops->hw_free(substream, cpu_dai);	if (rtd->dai_link->no_host_mode == SND_SOC_DAI_LINK_NO_HOST)		snd_pcm_lib_free_pages(substream);	mutex_unlock(&rtd->pcm_mutex);	return 0;}EXPORT_SYMBOL_GPL(snd_soc_pcm_hw_free);int snd_soc_pcm_trigger(struct snd_pcm_substream *substream, int cmd){	struct snd_soc_pcm_runtime *rtd = substream->private_data;	struct snd_soc_platform *platform = rtd->platform;	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;	struct snd_soc_dai *codec_dai = rtd->codec_dai;	int ret;	if (codec_dai->driver->ops->trigger) {		ret = codec_dai->driver->ops->trigger(substream, cmd, codec_dai);		if (ret < 0)			return ret;	}	if (platform->driver->ops->trigger) {		ret = platform->driver->ops->trigger(substream, cmd);		if (ret < 0)			return ret;	}	if (cpu_dai->driver->ops->trigger) {		ret = cpu_dai->driver->ops->trigger(substream, cmd, cpu_dai);		if (ret < 0)			return ret;	}	return 0;}EXPORT_SYMBOL_GPL(snd_soc_pcm_trigger);snd_pcm_uframes_t snd_soc_pcm_pointer(struct snd_pcm_substream *substream){	struct snd_soc_pcm_runtime *rtd = substream->private_data;	struct snd_soc_platform *platform = rtd->platform;	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;	struct snd_soc_dai *codec_dai = rtd->codec_dai;	struct snd_pcm_runtime *runtime = substream->runtime;	snd_pcm_uframes_t offset = 0;	snd_pcm_sframes_t delay = 0;	if (platform->driver->ops->pointer)		offset = platform->driver->ops->pointer(substream);	if (cpu_dai->driver->ops->delay)		delay += cpu_dai->driver->ops->delay(substream, cpu_dai);	if (codec_dai->driver->ops->delay)		delay += codec_dai->driver->ops->delay(substream, codec_dai);	if (platform->driver->delay)		delay += platform->driver->delay(substream, codec_dai);	runtime->delay = delay;	return offset;}EXPORT_SYMBOL_GPL(snd_soc_pcm_pointer);int snd_soc_pcm_ioctl(struct snd_pcm_substream *substream,		     unsigned int cmd, void *arg){	struct snd_soc_pcm_runtime *rtd = substream->private_data;	struct snd_soc_platform *platform = rtd->platform;	if (platform->driver->ops->ioctl)		return platform->driver->ops->ioctl(substream, cmd, arg);	return snd_pcm_lib_ioctl(substream, cmd, arg);}struct snd_pcm_substream *snd_soc_get_dai_substream(struct snd_soc_card *card,		const char *dai_link, int stream){	int i;	for (i = 0; i < card->num_links; i++) {		if (card->rtd[i].dai_link->no_pcm &&			!strcmp(card->rtd[i].dai_link->name, dai_link))			return card->rtd[i].pcm->streams[stream].substream;	}	dev_dbg(card->dev, "failed to find dai link %s\n", dai_link);	return NULL;}EXPORT_SYMBOL_GPL(snd_soc_get_dai_substream);struct snd_soc_pcm_runtime *snd_soc_get_pcm_runtime(struct snd_soc_card *card,		const char *dai_link){	int i;	for (i = 0; i < card->num_links; i++) {		if (!strcmp(card->rtd[i].dai_link->name, dai_link))			return &card->rtd[i];	}	dev_dbg(card->dev, "failed to find rtd %s\n", dai_link);	return NULL;}EXPORT_SYMBOL_GPL(snd_soc_get_pcm_runtime);#ifdef CONFIG_PMstatic int soc_suspend(struct device *dev){	struct platform_device *pdev = to_platform_device(dev);	struct snd_soc_card *card = platform_get_drvdata(pdev);	int i;	struct snd_pcm_substream *playback_modem = snd_soc_get_dai_substream(card, "(Backend) MODEM-EXT", 0);	struct snd_soc_pcm_runtime *modem_rtd = (playback_modem ? playback_modem->private_data : 0);	s_bsuspend = 0;		if( 1		&& modem_rtd 		&& (modem_rtd->cpu_dai->capture_active || modem_rtd->cpu_dai->playback_active)	)	{		s_bsuspend = 1;		return 0;	}#if 1	for (i = 0; i < card->num_rtd; i++) {		struct snd_soc_dai *dai = card->rtd[i].codec_dai;		struct snd_soc_dai_driver *drv = dai->driver;		if( card->rtd[i].dai_link->name && strcmp(card->rtd[i].dai_link->name, "SDP4430 Media Capture") == 0 ){			struct snd_soc_pcm_runtime *rtd;			int idx = 0;			for( idx = 0 ; idx < card->rtd[i].num_be[SNDRV_PCM_STREAM_CAPTURE] ; idx++ ){				rtd = card->rtd[i].be_rtd[idx][SNDRV_PCM_STREAM_CAPTURE];				if( rtd->codec_dai && rtd->codec_dai->capture_active ){					s_partial_suspend = 1;					break;				}			}		}	}#endif	if (list_empty(&card->codec_dev_list))		return 0;	snd_power_lock(card->snd_card);	snd_power_wait(card->snd_card, SNDRV_CTL_POWER_D0);	snd_power_unlock(card->snd_card);	snd_power_change_state(card->snd_card, SNDRV_CTL_POWER_D3hot);	for (i = 0; i < card->num_rtd; i++) {		struct snd_soc_dai *dai = card->rtd[i].codec_dai;		struct snd_soc_dai_driver *drv = dai->driver;		if (card->rtd[i].dai_link->ignore_suspend)			continue;		if (drv->ops->digital_mute && dai->playback_active)			drv->ops->digital_mute(dai, 1);	}	for (i = 0; i < card->num_rtd; i++) {		if (card->rtd[i].dai_link->ignore_suspend)			continue;		snd_pcm_suspend_all(card->rtd[i].pcm);	}	if(s_partial_suspend==0){			if (card->suspend_pre)			card->suspend_pre(pdev, PMSG_SUSPEND);		for (i = 0; i < card->num_rtd; i++) {			struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;			struct snd_soc_platform *platform = card->rtd[i].platform;			if (card->rtd[i].dai_link->ignore_suspend)				continue;			if (cpu_dai->driver->suspend && !cpu_dai->driver->ac97_control){				cpu_dai->driver->suspend(cpu_dai);			}						if (platform->driver->suspend && !platform->suspended) {				platform->driver->suspend(cpu_dai);				platform->suspended = 1;			}		}		for (i = 0; i < card->num_rtd; i++) {			run_delayed_work(&card->rtd[i].delayed_work);			card->rtd[i].codec->dapm->suspend_bias_level = card->rtd[i].codec->dapm->bias_level;		}		for (i = 0; i < card->num_rtd; i++) {			struct snd_soc_dai_driver *driver = card->rtd[i].codec_dai->driver;			if (card->rtd[i].dai_link->ignore_suspend)				continue;			if (driver->playback.stream_name != NULL)				snd_soc_dapm_stream_event(&card->rtd[i], SNDRV_PCM_STREAM_PLAYBACK,					driver->playback.stream_name, SND_SOC_DAPM_STREAM_SUSPEND);			if (driver->capture.stream_name != NULL)				snd_soc_dapm_stream_event(&card->rtd[i], SNDRV_PCM_STREAM_CAPTURE,					driver->capture.stream_name, SND_SOC_DAPM_STREAM_SUSPEND);		}		for (i = 0; i < card->num_rtd; i++) {			struct snd_soc_codec *codec = card->rtd[i].codec;			if (!codec->suspended && codec->driver->suspend) {				switch (codec->dapm->bias_level) {				case SND_SOC_BIAS_STANDBY:				case SND_SOC_BIAS_OFF:					codec->driver->suspend(codec, PMSG_SUSPEND);					codec->suspended = 1;					break;				default:					dev_dbg(codec->dev, "CODEC is on over suspend\n");					break;				}			}		}		for (i = 0; i < card->num_rtd; i++) {			struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;			if (card->rtd[i].dai_link->ignore_suspend)				continue;			if (cpu_dai->driver->suspend && cpu_dai->driver->ac97_control){				cpu_dai->driver->suspend(cpu_dai);			}		}		if (card->suspend_post)			card->suspend_post(pdev, PMSG_SUSPEND);	}		return 0;}static void soc_resume_deferred(struct work_struct *work){	struct snd_soc_card *card =			container_of(work, struct snd_soc_card, deferred_resume_work);	struct platform_device *pdev = to_platform_device(card->dev);	int i;	dev_dbg(card->dev, "starting resume work\n");	snd_power_change_state(card->snd_card, SNDRV_CTL_POWER_D2);	if( s_partial_suspend == 0 ){			if (card->resume_pre)			card->resume_pre(pdev);		for (i = 0; i < card->num_rtd; i++) {			struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;			if (card->rtd[i].dai_link->ignore_suspend)				continue;			if (cpu_dai->driver->resume && cpu_dai->driver->ac97_control)				cpu_dai->driver->resume(cpu_dai);		}		for (i = 0; i < card->num_rtd; i++) {			struct snd_soc_codec *codec = card->rtd[i].codec;			if (codec->driver->resume && codec->suspended) {				switch (codec->dapm->bias_level) {				case SND_SOC_BIAS_STANDBY:				case SND_SOC_BIAS_OFF:					codec->driver->resume(codec);					codec->suspended = 0;					break;				default:					dev_dbg(codec->dev, "CODEC was on over suspend\n");					break;				}			}		}		for (i = 0; i < card->num_rtd; i++) {			struct snd_soc_dai_driver *driver = card->rtd[i].codec_dai->driver;			if (card->rtd[i].dai_link->ignore_suspend)				continue;			if (driver->playback.stream_name != NULL)				snd_soc_dapm_stream_event(&card->rtd[i], SNDRV_PCM_STREAM_PLAYBACK,					driver->playback.stream_name, SND_SOC_DAPM_STREAM_RESUME);			if (driver->capture.stream_name != NULL)				snd_soc_dapm_stream_event(&card->rtd[i], SNDRV_PCM_STREAM_CAPTURE,					driver->capture.stream_name, SND_SOC_DAPM_STREAM_RESUME);		}		for (i = 0; i < card->num_rtd; i++) {			struct snd_soc_dai *dai = card->rtd[i].codec_dai;			struct snd_soc_dai_driver *drv = dai->driver;			if (card->rtd[i].dai_link->ignore_suspend)				continue;			if (drv->ops->digital_mute && dai->playback_active)				drv->ops->digital_mute(dai, 0);		}		for (i = 0; i < card->num_rtd; i++) {			struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;			struct snd_soc_platform *platform = card->rtd[i].platform;			if (card->rtd[i].dai_link->ignore_suspend)				continue;			if (cpu_dai->driver->resume && !cpu_dai->driver->ac97_control)				cpu_dai->driver->resume(cpu_dai);			if (platform->driver->resume && platform->suspended) {				platform->driver->resume(cpu_dai);				platform->suspended = 0;			}		}		if (card->resume_post)			card->resume_post(pdev);	}	else{		s_partial_suspend = 0;	}		dev_dbg(card->dev, "resume work completed\n");	snd_power_change_state(card->snd_card, SNDRV_CTL_POWER_D0);	for (i = 0; i < card->num_rtd; i++) {		if (card->rtd[i].dai_link->ignore_suspend)			continue;		snd_pcm_resume_all(card->rtd[i].pcm);	}}static int soc_resume(struct device *dev){	struct platform_device *pdev = to_platform_device(dev);	struct snd_soc_card *card = platform_get_drvdata(pdev);	int i;	if( s_bsuspend == 1 ) return 0;	for (i = 0; i < card->num_rtd; i++) {		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;		if (cpu_dai->driver->ac97_control) {			dev_dbg(dev, "Resuming AC97 immediately\n");			soc_resume_deferred(&card->deferred_resume_work);			return 0;		}	}	dev_dbg(dev, "Scheduling resume work\n");	if (!schedule_work(&card->deferred_resume_work))		dev_err(dev, "resume work item may be lost\n");	return 0;}#else#define soc_suspend	NULL#define soc_resume	NULL#endif#define NULL_FORMATS \	(SNDRV_PCM_FMTBIT_S16 | SNDRV_PCM_FMTBIT_U16 |\	SNDRV_PCM_FMTBIT_S24 | SNDRV_PCM_FMTBIT_U24 |\	SNDRV_PCM_FMTBIT_S32 | SNDRV_PCM_FMTBIT_U32)static struct snd_soc_dai_ops null_dai_ops = {};static struct snd_soc_dai_driver null_codec_dai_drv = {		.name = "null-codec-dai",		.ops = &null_dai_ops,		.capture = {			.channels_min = 1 ,			.channels_max = 16,			.rates = SNDRV_PCM_RATE_CONTINUOUS,			.formats = NULL_FORMATS,		},		.playback = {			.channels_min = 1 ,			.channels_max = 16,			.rates = SNDRV_PCM_RATE_CONTINUOUS,			.formats = NULL_FORMATS,		},};static struct snd_soc_codec_driver null_codec_drv = {};static int soc_bind_dai_link(struct snd_soc_card *card, int num){	struct snd_soc_dai_link *dai_link = &card->dai_link[num];	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];	struct snd_soc_codec *codec;	struct snd_soc_platform *platform;	struct snd_soc_dai *codec_dai, *cpu_dai;	if (rtd->complete)		return 1;	dev_dbg(card->dev, "binding %s at idx %d\n", dai_link->name, num);	if (rtd->cpu_dai) {		goto find_codec;	}		list_for_each_entry(cpu_dai, &dai_list, list) {		if (!strcmp(cpu_dai->name, dai_link->cpu_dai_name)) {			if (!try_module_get(cpu_dai->dev->driver->owner))				return -ENODEV;			rtd->cpu_dai = cpu_dai;			goto find_codec;		}	}	dev_dbg(card->dev, "CPU DAI %s not registered\n",			dai_link->cpu_dai_name);find_codec:		if (rtd->codec) {		goto find_platform;	}	list_for_each_entry(codec, &codec_list, list) {		if (!strcmp(codec->name, dai_link->codec_name)) {			rtd->codec = codec;			if (!try_module_get(codec->dev->driver->owner))				return -ENODEV;			list_for_each_entry(codec_dai, &dai_list, list) {				if ((codec->dev == codec_dai->dev || codec->driver == &null_codec_drv) &&						!strcmp(codec_dai->name, dai_link->codec_dai_name)) {					rtd->codec_dai = codec_dai;					goto find_platform;				}			}			dev_dbg(card->dev, "CODEC DAI %s not registered\n",					dai_link->codec_dai_name);			goto find_platform;		}	}	dev_dbg(card->dev, "CODEC %s not registered\n",			dai_link->codec_name);find_platform:		if (rtd->platform) {		goto out;	}		list_for_each_entry(platform, &platform_list, list) {		if (!strcmp(platform->name, dai_link->platform_name)) {			if (!try_module_get(platform->dev->driver->owner))				return -ENODEV;			rtd->platform = platform;			goto out;		}	}	dev_dbg(card->dev, "platform %s not registered\n",			dai_link->platform_name);	return 0;out:		if (rtd->codec && rtd->codec_dai && rtd->platform && rtd->cpu_dai) {		rtd->complete = 1;		card->num_rtd++;	}	return 1;}static void soc_remove_dai_link(struct snd_soc_card *card, int num){	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];	struct snd_soc_codec *codec = rtd->codec;	struct snd_soc_platform *platform = rtd->platform;	struct snd_soc_dai *codec_dai = rtd->codec_dai, *cpu_dai = rtd->cpu_dai;	int err;	if (rtd->dev_registered) {		device_remove_file(&rtd->dev, &dev_attr_pmdown_time);		device_unregister(&rtd->dev);		rtd->dev_registered = 0;	}	if (codec_dai && codec_dai->probed) {		if (codec_dai->driver->remove) {			err = codec_dai->driver->remove(codec_dai);			if (err < 0)				printk(KERN_ERR "asoc: failed to remove %s\n", codec_dai->name);		}		codec_dai->probed = 0;		list_del(&codec_dai->card_list);	}	if (platform && platform->probed) {		if (platform->driver->remove) {			err = platform->driver->remove(platform);			if (err < 0)				printk(KERN_ERR "asoc: failed to remove %s\n", platform->name);		}		snd_soc_dapm_free(platform->dapm);		soc_cleanup_platform_debugfs(platform);		platform->probed = 0;		list_del(&platform->card_list);		module_put(platform->dev->driver->owner);	}	if (codec && codec->probed) {		if (codec->driver->remove) {			err = codec->driver->remove(codec);			if (err < 0)				printk(KERN_ERR "asoc: failed to remove %s\n", codec->name);		}		snd_soc_dapm_free(codec->dapm);		soc_cleanup_codec_debugfs(codec);		device_remove_file(&rtd->dev, &dev_attr_codec_reg);		codec->probed = 0;		list_del(&codec->card_list);		module_put(codec->dev->driver->owner);	}	if (cpu_dai && cpu_dai->probed) {		if (cpu_dai->driver->remove) {			err = cpu_dai->driver->remove(cpu_dai);			if (err < 0)				printk(KERN_ERR "asoc: failed to remove %s\n", cpu_dai->name);		}		cpu_dai->probed = 0;		list_del(&cpu_dai->card_list);		module_put(cpu_dai->dev->driver->owner);	}}static void rtd_release(struct device *dev) {}static int soc_probe_dai_link(struct snd_soc_card *card, int num){	struct snd_soc_dai_link *dai_link = &card->dai_link[num];	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];	struct snd_soc_codec *codec = rtd->codec;	struct snd_soc_platform *platform = rtd->platform;	struct snd_soc_dai *codec_dai = rtd->codec_dai, *cpu_dai = rtd->cpu_dai;	int ret;	dev_dbg(card->dev, "probe %s dai link %d\n", card->name, num);	platform->snd_card = codec->snd_card = card->snd_card;	codec_dai->codec = codec;	codec->card = card;	platform->card = card;	cpu_dai->platform = platform;	rtd->card = card;	rtd->dev.parent = card->dev;	codec_dai->card = card;	cpu_dai->card = card;	rtd->pmdown_time = pmdown_time;	if (!cpu_dai->probed) {		if (cpu_dai->driver->probe) {			ret = cpu_dai->driver->probe(cpu_dai);			if (ret < 0) {				printk(KERN_ERR "asoc: failed to probe CPU DAI %s\n",						cpu_dai->name);				return ret;			}		}				snd_soc_dapm_new_widgets(platform->dapm);		cpu_dai->probed = 1;				list_add(&cpu_dai->card_list, &card->dai_dev_list);	}	if (!codec->probed) {		if (codec->driver->probe) {			ret = codec->driver->probe(codec);			if (ret < 0) {				printk(KERN_ERR "asoc: failed to probe CODEC %s\n",						codec->name);				return ret;			}		}		soc_init_codec_debugfs(codec);		codec->probed = 1;		list_add(&codec->card_list, &card->codec_dev_list);	}	if (!platform->probed) {		if (platform->driver->probe) {			ret = platform->driver->probe(platform);			if (ret < 0) {				printk(KERN_ERR "asoc: failed to probe platform %s\n",						platform->name);				return ret;			}		}		soc_init_platform_debugfs(platform);		platform->probed = 1;		list_add(&platform->card_list, &card->platform_dev_list);	}	if (!codec_dai->probed) {		if (codec_dai->driver->probe) {			ret = codec_dai->driver->probe(codec_dai);			if (ret < 0) {				printk(KERN_ERR "asoc: failed to probe CODEC DAI %s\n",						codec_dai->name);				return ret;			}		}		codec_dai->probed = 1;		list_add(&codec_dai->card_list, &card->dai_dev_list);	}	INIT_DELAYED_WORK(&rtd->delayed_work, close_delayed_work);	mutex_init(&rtd->pcm_mutex);	if (dai_link->init) {		ret = dai_link->init(rtd);		if (ret < 0) {			printk(KERN_ERR "asoc: failed to init %s\n", dai_link->stream_name);			return ret;		}	}	snd_soc_dapm_new_widgets(codec->dapm);	snd_soc_dapm_sync(codec->dapm);	rtd->dev.init_name = rtd->dai_link->stream_name;	rtd->dev.release = rtd_release;	rtd->dev.init_name = dai_link->name;	ret = device_register(&rtd->dev);	if (ret < 0) {		printk(KERN_ERR "asoc: failed to register DAI runtime device %d\n", ret);		return ret;	}	rtd->dev_registered = 1;	ret = device_create_file(&rtd->dev, &dev_attr_pmdown_time);	if (ret < 0)		printk(KERN_WARNING "asoc: failed to add pmdown_time sysfs\n");	ret = snd_soc_dapm_sys_add(&rtd->dev);	if (ret < 0)		printk(KERN_WARNING "asoc: failed to add codec dapm sysfs entries\n");	ret = device_create_file(&rtd->dev, &dev_attr_codec_reg);	if (ret < 0)		printk(KERN_WARNING "asoc: failed to add codec sysfs files\n");	ret = soc_new_pcm(rtd, num);	if (ret < 0) {		printk(KERN_ERR "asoc: can't create pcm %s\n", dai_link->stream_name);		return ret;	}	if (rtd->codec_dai->driver->ac97_control)		snd_ac97_dev_add_pdata(codec->ac97, rtd->cpu_dai->ac97_pdata);	return 0;}#ifdef CONFIG_SND_SOC_AC97_BUSstatic int soc_register_ac97_dai_link(struct snd_soc_pcm_runtime *rtd){	int ret;	if (rtd->codec_dai->driver->ac97_control && !rtd->codec->ac97_registered) {		ret = soc_ac97_dev_register(rtd->codec);		if (ret < 0) {			printk(KERN_ERR "asoc: AC97 device register failed\n");			return ret;		}		rtd->codec->ac97_registered = 1;	}	return 0;}static void soc_unregister_ac97_dai_link(struct snd_soc_codec *codec){	if (codec->ac97_registered) {		soc_ac97_dev_unregister(codec);		codec->ac97_registered = 0;	}}#endifstatic void snd_soc_instantiate_card(struct snd_soc_card *card){	struct platform_device *pdev = to_platform_device(card->dev);	int ret, i;	mutex_lock(&card->mutex);	if (card->instantiated) {		mutex_unlock(&card->mutex);		return;	}	for (i = 0; i < card->num_links; i++)		soc_bind_dai_link(card, i);	if (card->num_rtd != card->num_links) {		mutex_unlock(&card->mutex);		return;	}	ret = snd_card_create(SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,			card->owner, 0, &card->snd_card);	if (ret < 0) {		printk(KERN_ERR "asoc: can't create sound card for card %s\n",			card->name);		mutex_unlock(&card->mutex);		return;	}	card->snd_card->dev = card->dev;#ifdef CONFIG_PM		INIT_WORK(&card->deferred_resume_work, soc_resume_deferred);#endif	if (card->probe) {		ret = card->probe(pdev);		if (ret < 0)			goto card_probe_error;	}	for (i = 0; i < card->num_links; i++) {		ret = soc_probe_dai_link(card, i);		if (ret < 0) {			printk(KERN_ERR "asoc: failed to instanciate card %s\n", card->name);			goto probe_dai_err;		}	}	snprintf(card->snd_card->shortname, sizeof(card->snd_card->shortname),		 "%s", card->name);	snprintf(card->snd_card->longname, sizeof(card->snd_card->longname),		 "%s", card->long_name);	snprintf(card->snd_card->driver, sizeof(card->snd_card->driver),		 "%s", card->name);	ret = snd_card_register(card->snd_card);	if (ret < 0) {		printk(KERN_ERR "asoc: failed to register soundcard for %s\n", card->name);		goto probe_dai_err;	}#ifdef CONFIG_SND_SOC_AC97_BUS		for (i = 0; i < card->num_rtd; i++) {			ret = soc_register_ac97_dai_link(&card->rtd[i]);			if (ret < 0) {				printk(KERN_ERR "asoc: failed to register AC97 %s\n", card->name);				goto probe_dai_err;			}		}#endif	card->instantiated = 1;	mutex_unlock(&card->mutex);	return;probe_dai_err:	for (i = 0; i < card->num_links; i++)		soc_remove_dai_link(card, i);card_probe_error:	if (card->remove)		card->remove(pdev);	snd_card_free(card->snd_card);	mutex_unlock(&card->mutex);}static void snd_soc_instantiate_cards(void){	struct snd_soc_card *card;	list_for_each_entry(card, &card_list, list)		snd_soc_instantiate_card(card);}static int soc_probe(struct platform_device *pdev){	struct snd_soc_card *card = platform_get_drvdata(pdev);	int ret = 0;	card->dev = &pdev->dev;	INIT_LIST_HEAD(&card->dai_dev_list);	INIT_LIST_HEAD(&card->codec_dev_list);	INIT_LIST_HEAD(&card->platform_dev_list);	ret = snd_soc_register_card(card);	if (ret != 0) {		dev_err(&pdev->dev, "Failed to register card\n");		return ret;	}	return 0;}static int soc_remove(struct platform_device *pdev){	struct snd_soc_card *card = platform_get_drvdata(pdev);	int i;		if (card->instantiated) {		for (i = 0; i < card->num_rtd; i++) {			struct snd_soc_pcm_runtime *rtd = &card->rtd[i];			run_delayed_work(&rtd->delayed_work);		}		for (i = 0; i < card->num_rtd; i++)			soc_remove_dai_link(card, i);		if (card->remove)			card->remove(pdev);		kfree(card->rtd);		snd_card_free(card->snd_card);	}	snd_soc_unregister_card(card);	return 0;}static int soc_poweroff(struct device *dev){	struct platform_device *pdev = to_platform_device(dev);	struct snd_soc_card *card = platform_get_drvdata(pdev);	int i;	if (!card->instantiated)		return 0;	for (i = 0; i < card->num_rtd; i++) {		struct snd_soc_pcm_runtime *rtd = &card->rtd[i];		run_delayed_work(&rtd->delayed_work);	}	snd_soc_dapm_shutdown(card);	return 0;}static const struct dev_pm_ops soc_pm_ops = {	.suspend = soc_suspend,	.resume = soc_resume,	.poweroff = soc_poweroff,};static struct platform_driver soc_driver = {	.driver		= {		.name		= "soc-audio",		.owner		= THIS_MODULE,		.pm		= &soc_pm_ops,	},	.probe		= soc_probe,	.remove		= soc_remove,};static int soc_new_pcm(struct snd_soc_pcm_runtime *rtd, int num){	struct snd_soc_codec *codec = rtd->codec;	struct snd_soc_platform *platform = rtd->platform;	struct snd_soc_dai *codec_dai = rtd->codec_dai;	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;	struct snd_pcm_substream *substream[2];	struct snd_pcm *pcm;	char new_name[64];	int ret = 0, playback = 0, capture = 0;	snprintf(new_name, sizeof(new_name), "%s %s-%d",			rtd->dai_link->stream_name, codec_dai->name, num);	if (rtd->dai_link->dynamic) {		if (rtd->dai_link->fe_playback_channels)			playback = 1;		if (rtd->dai_link->fe_capture_channels)			capture = 1;	} else {		if (codec_dai->driver->playback.channels_min)			playback = 1;		if (codec_dai->driver->capture.channels_min)			capture = 1;	}	dev_dbg(rtd->card->dev, "registered pcm #%d %s\n",num,new_name);	ret = snd_pcm_new(rtd->card->snd_card, new_name,			num, playback, capture, &pcm);	if (ret < 0) {		printk(KERN_ERR "asoc: can't create pcm for codec %s\n", codec->name);		return ret;	}	rtd->pcm = pcm;	pcm->private_data = rtd;	substream[SNDRV_PCM_STREAM_PLAYBACK] =			pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream;	substream[SNDRV_PCM_STREAM_CAPTURE] =			pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream;	if (rtd->dai_link->no_pcm) {		if (playback)			substream[SNDRV_PCM_STREAM_PLAYBACK]->private_data = rtd;		if (capture)			substream[SNDRV_PCM_STREAM_CAPTURE]->private_data = rtd;		goto out;	}	if (rtd->dai_link->no_host_mode) {		if (substream[SNDRV_PCM_STREAM_PLAYBACK]) {			substream[SNDRV_PCM_STREAM_PLAYBACK]->hw_no_buffer = 1;			snd_soc_set_runtime_hwparams(substream[SNDRV_PCM_STREAM_PLAYBACK],				&no_host_hardware);		}		if (substream[SNDRV_PCM_STREAM_CAPTURE]) {			substream[SNDRV_PCM_STREAM_CAPTURE]->hw_no_buffer = 1;			snd_soc_set_runtime_hwparams(substream[SNDRV_PCM_STREAM_CAPTURE],				&no_host_hardware);		}	}	rtd->ops.open 		= snd_soc_pcm_open;	rtd->ops.hw_params 	= snd_soc_pcm_hw_params;	rtd->ops.prepare 	= snd_soc_pcm_prepare;	rtd->ops.trigger 	= snd_soc_pcm_trigger;	rtd->ops.hw_free 	= snd_soc_pcm_hw_free;	rtd->ops.close 		= snd_soc_pcm_close;	rtd->ops.pointer 	= snd_soc_pcm_pointer;	rtd->ops.ioctl 		= snd_soc_pcm_ioctl;	rtd->ops.ack 		= platform->driver->ops->ack;	rtd->ops.copy		= platform->driver->ops->copy;	rtd->ops.silence	= platform->driver->ops->silence;	rtd->ops.page		= platform->driver->ops->page;	rtd->ops.mmap		= platform->driver->ops->mmap;	if (playback)		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &rtd->ops);	if (capture)		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &rtd->ops);	if (!platform->driver->pcm_new)		goto out;	ret = platform->driver->pcm_new(rtd);	if (ret < 0) {		printk(KERN_ERR "asoc: platform pcm constructor failed\n");		return ret;	}out:	pcm->private_free = platform->driver->pcm_free;	printk(KERN_INFO "asoc: %s <-> %s mapping ok\n", codec_dai->name,		cpu_dai->name);	return ret;}int snd_soc_codec_volatile_register(struct snd_soc_codec *codec, int reg){	if (codec->driver->volatile_register)		return codec->driver->volatile_register(reg);	else		return 0;}EXPORT_SYMBOL_GPL(snd_soc_codec_volatile_register);int snd_soc_new_ac97_codec(struct snd_soc_codec *codec,	struct snd_ac97_bus_ops *ops, int num){	mutex_lock(&codec->mutex);	codec->ac97 = kzalloc(sizeof(struct snd_ac97), GFP_KERNEL);	if (codec->ac97 == NULL) {		mutex_unlock(&codec->mutex);		return -ENOMEM;	}	codec->ac97->bus = kzalloc(sizeof(struct snd_ac97_bus), GFP_KERNEL);	if (codec->ac97->bus == NULL) {		kfree(codec->ac97);		codec->ac97 = NULL;		mutex_unlock(&codec->mutex);		return -ENOMEM;	}	codec->ac97->bus->ops = ops;	codec->ac97->num = num;	mutex_unlock(&codec->mutex);	return 0;}EXPORT_SYMBOL_GPL(snd_soc_new_ac97_codec);void snd_soc_free_ac97_codec(struct snd_soc_codec *codec){	mutex_lock(&codec->mutex);#ifdef CONFIG_SND_SOC_AC97_BUS	soc_unregister_ac97_dai_link(codec);#endif	kfree(codec->ac97->bus);	kfree(codec->ac97);	codec->ac97 = NULL;	mutex_unlock(&codec->mutex);}EXPORT_SYMBOL_GPL(snd_soc_free_ac97_codec);int snd_soc_update_bits(struct snd_soc_codec *codec, unsigned short reg,				unsigned int mask, unsigned int value){	int change;	unsigned int old, new;	old = snd_soc_read(codec, reg);	new = (old & ~mask) | value;	change = old != new;	if (change)		snd_soc_write(codec, reg, new);	return change;}EXPORT_SYMBOL_GPL(snd_soc_update_bits);int snd_soc_update_bits_locked(struct snd_soc_codec *codec,			       unsigned short reg, unsigned int mask,			       unsigned int value){	int change;	mutex_lock(&codec->mutex);	change = snd_soc_update_bits(codec, reg, mask, value);	mutex_unlock(&codec->mutex);	return change;}EXPORT_SYMBOL_GPL(snd_soc_update_bits_locked);int snd_soc_test_bits(struct snd_soc_codec *codec, unsigned short reg,				unsigned int mask, unsigned int value){	int change;	unsigned int old, new;	old = snd_soc_read(codec, reg);	new = (old & ~mask) | value;	change = old != new;	return change;}EXPORT_SYMBOL_GPL(snd_soc_test_bits);int snd_soc_set_runtime_hwparams(struct snd_pcm_substream *substream,	const struct snd_pcm_hardware *hw){	struct snd_pcm_runtime *runtime = substream->runtime;	if (!runtime)		return 0;	runtime->hw.info = hw->info;	runtime->hw.formats = hw->formats;	runtime->hw.period_bytes_min = hw->period_bytes_min;	runtime->hw.period_bytes_max = hw->period_bytes_max;	runtime->hw.periods_min = hw->periods_min;	runtime->hw.periods_max = hw->periods_max;	runtime->hw.buffer_bytes_max = hw->buffer_bytes_max;	runtime->hw.fifo_size = hw->fifo_size;	return 0;}EXPORT_SYMBOL_GPL(snd_soc_set_runtime_hwparams);struct snd_kcontrol *snd_soc_cnew(const struct snd_kcontrol_new *_template,	void *data, char *long_name){	struct snd_kcontrol_new template;	memcpy(&template, _template, sizeof(template));	if (long_name)		template.name = long_name;	template.index = 0;	return snd_ctl_new1(&template, data);}EXPORT_SYMBOL_GPL(snd_soc_cnew);int snd_soc_add_controls(struct snd_soc_codec *codec,	const struct snd_kcontrol_new *controls, int num_controls){	struct snd_card *card = codec->snd_card;	int err, i;	for (i = 0; i < num_controls; i++) {		const struct snd_kcontrol_new *control = &controls[i];		err = snd_ctl_add(card, snd_soc_cnew(control, codec, NULL));		if (err < 0) {			dev_err(codec->dev, "%s: Failed to add %s\n",				codec->name, control->name);			return err;		}	}	return 0;}EXPORT_SYMBOL_GPL(snd_soc_add_controls);int snd_soc_add_platform_controls(struct snd_soc_platform *platform,	const struct snd_kcontrol_new *controls, int num_controls){	struct snd_card *card = platform->snd_card;	int err, i;	for (i = 0; i < num_controls; i++) {		const struct snd_kcontrol_new *control = &controls[i];		err = snd_ctl_add(card, snd_soc_cnew(control, platform, NULL));		if (err < 0) {			dev_err(platform->dev, "Failed to add %s %d\n",control->name, err);			return err;		}	}	return 0;}EXPORT_SYMBOL_GPL(snd_soc_add_platform_controls);int snd_soc_info_enum_double(struct snd_kcontrol *kcontrol,	struct snd_ctl_elem_info *uinfo){	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;	int target_size = sizeof(uinfo->value.enumerated.name);	int src_size = 0;	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;	uinfo->count = e->shift_l == e->shift_r ? 1 : 2;	uinfo->value.enumerated.items = e->max;	if (uinfo->value.enumerated.item > e->max - 1)		uinfo->value.enumerated.item = e->max - 1;	src_size = e->texts[uinfo->value.enumerated.item] ? strlen(e->texts[uinfo->value.enumerated.item]) : 0; 	if( target_size > src_size )		strcpy(uinfo->value.enumerated.name,			e->texts[uinfo->value.enumerated.item]);	return 0;}EXPORT_SYMBOL_GPL(snd_soc_info_enum_double);int snd_soc_get_enum_double(struct snd_kcontrol *kcontrol,	struct snd_ctl_elem_value *ucontrol){	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;	unsigned int val, bitmask;	for (bitmask = 1; bitmask < e->max; bitmask <<= 1)		;	val = snd_soc_read(codec, e->reg);	ucontrol->value.enumerated.item[0]		= (val >> e->shift_l) & (bitmask - 1);	if (e->shift_l != e->shift_r)		ucontrol->value.enumerated.item[1] =			(val >> e->shift_r) & (bitmask - 1);	return 0;}EXPORT_SYMBOL_GPL(snd_soc_get_enum_double);int snd_soc_put_enum_double(struct snd_kcontrol *kcontrol,	struct snd_ctl_elem_value *ucontrol){	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;	unsigned int val;	unsigned int mask, bitmask;	for (bitmask = 1; bitmask < e->max; bitmask <<= 1)		;	if (ucontrol->value.enumerated.item[0] > e->max - 1)		return -EINVAL;	val = ucontrol->value.enumerated.item[0] << e->shift_l;	mask = (bitmask - 1) << e->shift_l;	if (e->shift_l != e->shift_r) {		if (ucontrol->value.enumerated.item[1] > e->max - 1)			return -EINVAL;		val |= ucontrol->value.enumerated.item[1] << e->shift_r;		mask |= (bitmask - 1) << e->shift_r;	}	return snd_soc_update_bits_locked(codec, e->reg, mask, val);}EXPORT_SYMBOL_GPL(snd_soc_put_enum_double);int snd_soc_get_value_enum_double(struct snd_kcontrol *kcontrol,	struct snd_ctl_elem_value *ucontrol){	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;	unsigned int reg_val, val, mux;	reg_val = snd_soc_read(codec, e->reg);	val = (reg_val >> e->shift_l) & e->mask;	for (mux = 0; mux < e->max; mux++) {		if (val == e->values[mux])			break;	}	ucontrol->value.enumerated.item[0] = mux;	if (e->shift_l != e->shift_r) {		val = (reg_val >> e->shift_r) & e->mask;		for (mux = 0; mux < e->max; mux++) {			if (val == e->values[mux])				break;		}		ucontrol->value.enumerated.item[1] = mux;	}	return 0;}EXPORT_SYMBOL_GPL(snd_soc_get_value_enum_double);int snd_soc_put_value_enum_double(struct snd_kcontrol *kcontrol,	struct snd_ctl_elem_value *ucontrol){	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;	unsigned int val;	unsigned int mask;	if (ucontrol->value.enumerated.item[0] > e->max - 1)		return -EINVAL;	val = e->values[ucontrol->value.enumerated.item[0]] << e->shift_l;	mask = e->mask << e->shift_l;	if (e->shift_l != e->shift_r) {		if (ucontrol->value.enumerated.item[1] > e->max - 1)			return -EINVAL;		val |= e->values[ucontrol->value.enumerated.item[1]] << e->shift_r;		mask |= e->mask << e->shift_r;	}	return snd_soc_update_bits_locked(codec, e->reg, mask, val);}EXPORT_SYMBOL_GPL(snd_soc_put_value_enum_double);int snd_soc_info_enum_ext(struct snd_kcontrol *kcontrol,	struct snd_ctl_elem_info *uinfo){	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;	int target_size = sizeof(uinfo->value.enumerated.name);	int src_size = 0;		uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;	uinfo->count = 1;	uinfo->value.enumerated.items = e->max;	if (uinfo->value.enumerated.item > e->max - 1)		uinfo->value.enumerated.item = e->max - 1;	src_size = e->texts[uinfo->value.enumerated.item] ? strlen(e->texts[uinfo->value.enumerated.item]) : 0; 	if( target_size > src_size )		strcpy(uinfo->value.enumerated.name,			e->texts[uinfo->value.enumerated.item]);		return 0;}EXPORT_SYMBOL_GPL(snd_soc_info_enum_ext);int snd_soc_info_volsw_ext(struct snd_kcontrol *kcontrol,	struct snd_ctl_elem_info *uinfo){	int max = kcontrol->private_value;	if (max == 1 && !strstr(kcontrol->id.name, " Volume"))		uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;	else		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;	uinfo->count = 1;	uinfo->value.integer.min = 0;	uinfo->value.integer.max = max;	return 0;}EXPORT_SYMBOL_GPL(snd_soc_info_volsw_ext);int snd_soc_info_volsw(struct snd_kcontrol *kcontrol,	struct snd_ctl_elem_info *uinfo){	struct soc_mixer_control *mc =		(struct soc_mixer_control *)kcontrol->private_value;	int platform_max;	unsigned int shift = mc->shift;	unsigned int rshift = mc->rshift;	if (!mc->platform_max)		mc->platform_max = mc->max;	platform_max = mc->platform_max;	if (platform_max == 1 && !strstr(kcontrol->id.name, " Volume"))		uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;	else		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;	uinfo->count = shift == rshift ? 1 : 2;	uinfo->value.integer.min = 0;	uinfo->value.integer.max = platform_max;	return 0;}EXPORT_SYMBOL_GPL(snd_soc_info_volsw);int snd_soc_get_volsw(struct snd_kcontrol *kcontrol,	struct snd_ctl_elem_value *ucontrol){	struct soc_mixer_control *mc =		(struct soc_mixer_control *)kcontrol->private_value;	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);	unsigned int reg = mc->reg;	unsigned int shift = mc->shift;	unsigned int rshift = mc->rshift;	int max = mc->max;	unsigned int mask = (1 << fls(max)) - 1;	unsigned int invert = mc->invert;	ucontrol->value.integer.value[0] =		(snd_soc_read(codec, reg) >> shift) & mask;	if (shift != rshift)		ucontrol->value.integer.value[1] =			(snd_soc_read(codec, reg) >> rshift) & mask;	if (invert) {		ucontrol->value.integer.value[0] =			max - ucontrol->value.integer.value[0];		if (shift != rshift)			ucontrol->value.integer.value[1] =				max - ucontrol->value.integer.value[1];	}	return 0;}EXPORT_SYMBOL_GPL(snd_soc_get_volsw);int snd_soc_put_volsw(struct snd_kcontrol *kcontrol,	struct snd_ctl_elem_value *ucontrol){	struct soc_mixer_control *mc =		(struct soc_mixer_control *)kcontrol->private_value;	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);	unsigned int reg = mc->reg;	unsigned int shift = mc->shift;	unsigned int rshift = mc->rshift;	int max = mc->max;	unsigned int mask = (1 << fls(max)) - 1;	unsigned int invert = mc->invert;	unsigned int val, val2, val_mask;	val = (ucontrol->value.integer.value[0] & mask);	if (invert)		val = max - val;	val_mask = mask << shift;	val = val << shift;	if (shift != rshift) {		val2 = (ucontrol->value.integer.value[1] & mask);		if (invert)			val2 = max - val2;		val_mask |= mask << rshift;		val |= val2 << rshift;	}	return snd_soc_update_bits_locked(codec, reg, val_mask, val);}EXPORT_SYMBOL_GPL(snd_soc_put_volsw);int snd_soc_info_volsw_2r(struct snd_kcontrol *kcontrol,	struct snd_ctl_elem_info *uinfo){	struct soc_mixer_control *mc =		(struct soc_mixer_control *)kcontrol->private_value;	int platform_max;	if (!mc->platform_max)		mc->platform_max = mc->max;	platform_max = mc->platform_max;	if (platform_max == 1 && !strstr(kcontrol->id.name, " Volume"))		uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;	else		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;	uinfo->count = 2;	uinfo->value.integer.min = 0;	uinfo->value.integer.max = platform_max;	return 0;}EXPORT_SYMBOL_GPL(snd_soc_info_volsw_2r);int snd_soc_get_volsw_2r(struct snd_kcontrol *kcontrol,	struct snd_ctl_elem_value *ucontrol){	struct soc_mixer_control *mc =		(struct soc_mixer_control *)kcontrol->private_value;	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);	unsigned int reg = mc->reg;	unsigned int reg2 = mc->rreg;	unsigned int shift = mc->shift;	int max = mc->max;	unsigned int mask = (1 << fls(max)) - 1;	unsigned int invert = mc->invert;	ucontrol->value.integer.value[0] =		(snd_soc_read(codec, reg) >> shift) & mask;	ucontrol->value.integer.value[1] =		(snd_soc_read(codec, reg2) >> shift) & mask;	if (invert) {		ucontrol->value.integer.value[0] =			max - ucontrol->value.integer.value[0];		ucontrol->value.integer.value[1] =			max - ucontrol->value.integer.value[1];	}	return 0;}EXPORT_SYMBOL_GPL(snd_soc_get_volsw_2r);int snd_soc_put_volsw_2r(struct snd_kcontrol *kcontrol,	struct snd_ctl_elem_value *ucontrol){	struct soc_mixer_control *mc =		(struct soc_mixer_control *)kcontrol->private_value;	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);	unsigned int reg = mc->reg;	unsigned int reg2 = mc->rreg;	unsigned int shift = mc->shift;	int max = mc->max;	unsigned int mask = (1 << fls(max)) - 1;	unsigned int invert = mc->invert;	int err;	unsigned int val, val2, val_mask;	val_mask = mask << shift;	val = (ucontrol->value.integer.value[0] & mask);	val2 = (ucontrol->value.integer.value[1] & mask);	if (invert) {		val = max - val;		val2 = max - val2;	}	val = val << shift;	val2 = val2 << shift;	err = snd_soc_update_bits_locked(codec, reg, val_mask, val);	if (err < 0)		return err;	err = snd_soc_update_bits_locked(codec, reg2, val_mask, val2);	return err;}EXPORT_SYMBOL_GPL(snd_soc_put_volsw_2r);int snd_soc_info_volsw_s8(struct snd_kcontrol *kcontrol,	struct snd_ctl_elem_info *uinfo){	struct soc_mixer_control *mc =		(struct soc_mixer_control *)kcontrol->private_value;	int platform_max;	int min = mc->min;	if (!mc->platform_max)		mc->platform_max = mc->max;	platform_max = mc->platform_max;	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;	uinfo->count = 2;	uinfo->value.integer.min = 0;	uinfo->value.integer.max = platform_max - min;	return 0;}EXPORT_SYMBOL_GPL(snd_soc_info_volsw_s8);int snd_soc_get_volsw_s8(struct snd_kcontrol *kcontrol,	struct snd_ctl_elem_value *ucontrol){	struct soc_mixer_control *mc =		(struct soc_mixer_control *)kcontrol->private_value;	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);	unsigned int reg = mc->reg;	int min = mc->min;	int val = snd_soc_read(codec, reg);	ucontrol->value.integer.value[0] =		((signed char)(val & 0xff))-min;	ucontrol->value.integer.value[1] =		((signed char)((val >> 8) & 0xff))-min;	return 0;}EXPORT_SYMBOL_GPL(snd_soc_get_volsw_s8);int snd_soc_put_volsw_s8(struct snd_kcontrol *kcontrol,	struct snd_ctl_elem_value *ucontrol){	struct soc_mixer_control *mc =		(struct soc_mixer_control *)kcontrol->private_value;	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);	unsigned int reg = mc->reg;	int min = mc->min;	unsigned int val;	val = (ucontrol->value.integer.value[0]+min) & 0xff;	val |= ((ucontrol->value.integer.value[1]+min) & 0xff) << 8;	return snd_soc_update_bits_locked(codec, reg, 0xffff, val);}EXPORT_SYMBOL_GPL(snd_soc_put_volsw_s8);int snd_soc_limit_volume(struct snd_soc_codec *codec,	const char *name, int max){	struct snd_card *card = codec->snd_card;	struct snd_kcontrol *kctl;	struct soc_mixer_control *mc;	int found = 0;	int ret = -EINVAL;	if (unlikely(!name || max <= 0))		return -EINVAL;	list_for_each_entry(kctl, &card->controls, list) {		if (!strncmp(kctl->id.name, name, sizeof(kctl->id.name))) {			found = 1;			break;		}	}	if (found) {		mc = (struct soc_mixer_control *)kctl->private_value;		if (max <= mc->max) {			mc->platform_max = max;			ret = 0;		}	}	return ret;}EXPORT_SYMBOL_GPL(snd_soc_limit_volume);int snd_soc_info_volsw_2r_sx(struct snd_kcontrol *kcontrol,			struct snd_ctl_elem_info *uinfo){	struct soc_mixer_control *mc =		(struct soc_mixer_control *)kcontrol->private_value;	int max = mc->max;	int min = mc->min;	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;	uinfo->count = 2;	uinfo->value.integer.min = 0;	uinfo->value.integer.max = max-min;	return 0;}EXPORT_SYMBOL_GPL(snd_soc_info_volsw_2r_sx);int snd_soc_get_volsw_2r_sx(struct snd_kcontrol *kcontrol,			struct snd_ctl_elem_value *ucontrol){	struct soc_mixer_control *mc =		(struct soc_mixer_control *)kcontrol->private_value;	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);	unsigned int mask = (1<<mc->shift)-1;	int min = mc->min;	int val = snd_soc_read(codec, mc->reg) & mask;	int valr = snd_soc_read(codec, mc->rreg) & mask;	ucontrol->value.integer.value[0] = ((val & 0xff)-min) & mask;	ucontrol->value.integer.value[1] = ((valr & 0xff)-min) & mask;	return 0;}EXPORT_SYMBOL_GPL(snd_soc_get_volsw_2r_sx);int snd_soc_put_volsw_2r_sx(struct snd_kcontrol *kcontrol,			struct snd_ctl_elem_value *ucontrol){	struct soc_mixer_control *mc =		(struct soc_mixer_control *)kcontrol->private_value;	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);	unsigned int mask = (1<<mc->shift)-1;	int min = mc->min;	int ret;	unsigned int val, valr, oval, ovalr;	val = ((ucontrol->value.integer.value[0]+min) & 0xff);	val &= mask;	valr = ((ucontrol->value.integer.value[1]+min) & 0xff);	valr &= mask;	oval = snd_soc_read(codec, mc->reg) & mask;	ovalr = snd_soc_read(codec, mc->rreg) & mask;	ret = 0;	if (oval != val) {		ret = snd_soc_write(codec, mc->reg, val);		if (ret < 0)			return ret;	}	if (ovalr != valr) {		ret = snd_soc_write(codec, mc->rreg, valr);		if (ret < 0)			return ret;	}	return 0;}EXPORT_SYMBOL_GPL(snd_soc_put_volsw_2r_sx);int snd_soc_dai_set_sysclk(struct snd_soc_dai *dai, int clk_id,	unsigned int freq, int dir){	if (dai->driver && dai->driver->ops->set_sysclk)		return dai->driver->ops->set_sysclk(dai, clk_id, freq, dir);	else		return -EINVAL;}EXPORT_SYMBOL_GPL(snd_soc_dai_set_sysclk);int snd_soc_dai_set_clkdiv(struct snd_soc_dai *dai,	int div_id, int div){	if (dai->driver && dai->driver->ops->set_clkdiv)		return dai->driver->ops->set_clkdiv(dai, div_id, div);	else		return -EINVAL;}EXPORT_SYMBOL_GPL(snd_soc_dai_set_clkdiv);int snd_soc_dai_set_pll(struct snd_soc_dai *dai, int pll_id, int source,	unsigned int freq_in, unsigned int freq_out){	if (dai->driver && dai->driver->ops->set_pll)		return dai->driver->ops->set_pll(dai, pll_id, source,					 freq_in, freq_out);	else		return -EINVAL;}EXPORT_SYMBOL_GPL(snd_soc_dai_set_pll);int snd_soc_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt){	if (dai->driver && dai->driver->ops->set_fmt)		return dai->driver->ops->set_fmt(dai, fmt);	else		return -EINVAL;}EXPORT_SYMBOL_GPL(snd_soc_dai_set_fmt);int snd_soc_dai_set_tdm_slot(struct snd_soc_dai *dai,	unsigned int tx_mask, unsigned int rx_mask, int slots, int slot_width){	if (dai->driver && dai->driver->ops->set_tdm_slot)		return dai->driver->ops->set_tdm_slot(dai, tx_mask, rx_mask,				slots, slot_width);	else		return -EINVAL;}EXPORT_SYMBOL_GPL(snd_soc_dai_set_tdm_slot);int snd_soc_dai_set_channel_map(struct snd_soc_dai *dai,	unsigned int tx_num, unsigned int *tx_slot,	unsigned int rx_num, unsigned int *rx_slot){	if (dai->driver && dai->driver->ops->set_channel_map)		return dai->driver->ops->set_channel_map(dai, tx_num, tx_slot,			rx_num, rx_slot);	else		return -EINVAL;}EXPORT_SYMBOL_GPL(snd_soc_dai_set_channel_map);int snd_soc_dai_set_tristate(struct snd_soc_dai *dai, int tristate){	if (dai->driver && dai->driver->ops->set_tristate)		return dai->driver->ops->set_tristate(dai, tristate);	else		return -EINVAL;}EXPORT_SYMBOL_GPL(snd_soc_dai_set_tristate);int snd_soc_dai_digital_mute(struct snd_soc_dai *dai, int mute){	if (dai->driver && dai->driver->ops->digital_mute)		return dai->driver->ops->digital_mute(dai, mute);	else		return -EINVAL;}EXPORT_SYMBOL_GPL(snd_soc_dai_digital_mute);static int snd_soc_register_card(struct snd_soc_card *card){	int i, ret = 0;	if (!card->name || !card->dev)		return -EINVAL;	card->rtd = kzalloc(sizeof(struct snd_soc_pcm_runtime) * card->num_links,			GFP_KERNEL);	if (card->rtd == NULL)		return -ENOMEM;	for (i = 0; i < card->num_links; i++) {				dev_dbg(card->dev, "DAI create runtime %s\n", card->dai_link[i].name);		card->rtd[i].dai_link = &card->dai_link[i];		if (card->rtd[i].dai_link->dynamic) {			card->rtd[i].dai_link->codec_name = "null-codec";			card->rtd[i].dai_link->codec_dai_name = "null-codec-dai";			ret = snd_soc_register_codec(card->dev, &null_codec_drv,					&null_codec_dai_drv, 1);			if (ret < 0) {				printk(KERN_ERR "%s: failed to register dynamic DAI link %d\n",						__func__, ret);				goto out;			}			continue;		}		if (card->rtd[i].dai_link->no_codec) {			card->rtd[i].dai_link->codec_name = "null-codec";			ret = snd_soc_register_codec(card->dev, &null_codec_drv,					&null_codec_dai_drv, 1);			if (ret < 0) {				printk(KERN_ERR "%s: failed to register dynamic DAI link %d\n",						__func__, ret);				goto out;			}			continue;		}	}	INIT_LIST_HEAD(&card->list);	card->instantiated = 0;	mutex_init(&card->mutex);	mutex_init(&card->dapm_mutex);	mutex_lock(&client_mutex);	list_add(&card->list, &card_list);	snd_soc_instantiate_cards();	mutex_unlock(&client_mutex);	dev_dbg(card->dev, "Registered card '%s'\n", card->name);out:	return ret;}static int snd_soc_unregister_card(struct snd_soc_card *card){	mutex_lock(&client_mutex);	list_del(&card->list);	mutex_unlock(&client_mutex);	dev_dbg(card->dev, "Unregistered card '%s'\n", card->name);	return 0;}static inline char *fmt_single_name(struct device *dev, int *id){	char *found, name[NAME_SIZE+1];	int id1, id2;	if (dev_name(dev) == NULL)		return NULL;	memset(name, 0, NAME_SIZE+1);		strncpy(name, dev_name(dev), NAME_SIZE);	found = strstr(name, dev->driver->name);	if (found) {				if (sscanf(&found[strlen(dev->driver->name)], ".%d", id) == 1) {			if (*id == -1)				found[strlen(dev->driver->name)] = '\0';		}	} else {				if (sscanf(name, "%x-%x", &id1, &id2) == 2) {			char tmp[NAME_SIZE];			*id = ((id1 && 0xffff) << 16) + id2;			snprintf(tmp, NAME_SIZE, "%s.%s", dev->driver->name, name);			strncpy(name, tmp, NAME_SIZE);		} else			*id = 0;	}	return kstrdup(name, GFP_KERNEL);}static inline char *fmt_multiple_name(struct device *dev,		struct snd_soc_dai_driver *dai_drv){	if (dai_drv->name == NULL) {		printk(KERN_ERR "asoc: error - multiple DAI %s registered with no name\n",				dev_name(dev));		return NULL;	}	return kstrdup(dai_drv->name, GFP_KERNEL);}static struct snd_soc_dapm_context *soc_new_dapm_context(struct device *dev){	struct snd_soc_dapm_context *dapm;	dapm = kzalloc(sizeof(struct snd_soc_dapm_context), GFP_KERNEL);	if (dapm) {			INIT_LIST_HEAD(&dapm->widgets);			INIT_LIST_HEAD(&dapm->paths);			dapm->bias_level = SND_SOC_BIAS_OFF;			dapm->dev = dev;	}	return dapm;}int snd_soc_register_dai(struct device *dev,		struct snd_soc_dai_driver *dai_drv){	struct snd_soc_dai *dai;	dev_dbg(dev, "dai register %s\n", dev_name(dev));	dai = kzalloc(sizeof(struct snd_soc_dai), GFP_KERNEL);	if (dai == NULL)			return -ENOMEM;	dai->name = fmt_single_name(dev, &dai->id);	if (dai->name == NULL) {		kfree(dai);		return -ENOMEM;	}	dai->dev = dev;	dai->driver = dai_drv;	if (!dai->driver->ops)		dai->driver->ops = &null_dai_ops;	mutex_lock(&client_mutex);	list_add(&dai->list, &dai_list);	snd_soc_instantiate_cards();	mutex_unlock(&client_mutex);	pr_debug("Registered DAI '%s'\n", dai->name);	return 0;}EXPORT_SYMBOL_GPL(snd_soc_register_dai);void snd_soc_unregister_dai(struct device *dev){	struct snd_soc_dai *dai;	list_for_each_entry(dai, &dai_list, list) {		if (dev == dai->dev)			goto found;	}	return;found:	mutex_lock(&client_mutex);	list_del(&dai->list);	mutex_unlock(&client_mutex);	pr_debug("Unregistered DAI '%s'\n", dai->name);	kfree(dai->name);	kfree(dai);}EXPORT_SYMBOL_GPL(snd_soc_unregister_dai);int snd_soc_register_dais(struct device *dev,		struct snd_soc_dai_driver *dai_drv, size_t count){	struct snd_soc_dai *dai;	int i, ret = 0;	dev_dbg(dev, "dai register %s #%d\n", dev_name(dev), count);	for (i = 0; i < count; i++) {		dai = kzalloc(sizeof(struct snd_soc_dai), GFP_KERNEL);		if (dai == NULL)			return -ENOMEM;		dai->name = fmt_multiple_name(dev, &dai_drv[i]);		if (dai->name == NULL) {			kfree(dai);			ret = -EINVAL;			goto err;		}		dai->dev = dev;		dai->id = i;		dai->driver = &dai_drv[i];		if (!dai->driver->ops)			dai->driver->ops = &null_dai_ops;		mutex_lock(&client_mutex);		list_add(&dai->list, &dai_list);		mutex_unlock(&client_mutex);		pr_debug("Registered DAI '%s'\n", dai->name);	}	snd_soc_instantiate_cards();	return 0;err:	for (i--; i >= 0; i--)		snd_soc_unregister_dai(dev);	return ret;}EXPORT_SYMBOL_GPL(snd_soc_register_dais);void snd_soc_unregister_dais(struct device *dev, size_t count){	int i;	for (i = 0; i < count; i++)		snd_soc_unregister_dai(dev);}EXPORT_SYMBOL_GPL(snd_soc_unregister_dais);int snd_soc_register_platform(struct device *dev,		struct snd_soc_platform_driver *platform_drv){	struct snd_soc_platform *platform;	dev_dbg(dev, "platform register %s\n", dev_name(dev));	platform = kzalloc(sizeof(struct snd_soc_platform), GFP_KERNEL);	if (platform == NULL)			return -ENOMEM;	platform->name = fmt_single_name(dev, &platform->id);	if (platform->name == NULL) {		kfree(platform);		return -ENOMEM;	}	platform->dapm = soc_new_dapm_context(dev);	if (platform->dapm == NULL) {		kfree(platform->name);		kfree(platform);		return -ENOMEM;	}	platform->dapm->platform = platform;	platform->dapm->stream_event = platform_drv->stream_event;	platform->dev = dev;	platform->driver = platform_drv;	mutex_lock(&client_mutex);	list_add(&platform->list, &platform_list);	snd_soc_instantiate_cards();	mutex_unlock(&client_mutex);	pr_debug("Registered platform '%s'\n", platform->name);	return 0;}EXPORT_SYMBOL_GPL(snd_soc_register_platform);void snd_soc_unregister_platform(struct device *dev){	struct snd_soc_platform *platform;	list_for_each_entry(platform, &platform_list, list) {		if (dev == platform->dev)			goto found;	}	return;found:	mutex_lock(&client_mutex);	list_del(&platform->list);	mutex_unlock(&client_mutex);	pr_debug("Unregistered platform '%s'\n", platform->name);	kfree(platform->name);	kfree(platform->dapm);	kfree(platform);}EXPORT_SYMBOL_GPL(snd_soc_unregister_platform);static u64 codec_format_map[] = {	SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S16_BE,	SNDRV_PCM_FMTBIT_U16_LE | SNDRV_PCM_FMTBIT_U16_BE,	SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S24_BE,	SNDRV_PCM_FMTBIT_U24_LE | SNDRV_PCM_FMTBIT_U24_BE,	SNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_S32_BE,	SNDRV_PCM_FMTBIT_U32_LE | SNDRV_PCM_FMTBIT_U32_BE,	SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_U24_3BE,	SNDRV_PCM_FMTBIT_U24_3LE | SNDRV_PCM_FMTBIT_U24_3BE,	SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S20_3BE,	SNDRV_PCM_FMTBIT_U20_3LE | SNDRV_PCM_FMTBIT_U20_3BE,	SNDRV_PCM_FMTBIT_S18_3LE | SNDRV_PCM_FMTBIT_S18_3BE,	SNDRV_PCM_FMTBIT_U18_3LE | SNDRV_PCM_FMTBIT_U18_3BE,	SNDRV_PCM_FMTBIT_FLOAT_LE | SNDRV_PCM_FMTBIT_FLOAT_BE,	SNDRV_PCM_FMTBIT_FLOAT64_LE | SNDRV_PCM_FMTBIT_FLOAT64_BE,	SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE	| SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_BE,};static void fixup_codec_formats(struct snd_soc_pcm_stream *stream){	int i;	for (i = 0; i < ARRAY_SIZE(codec_format_map); i++)		if (stream->formats & codec_format_map[i])			stream->formats |= codec_format_map[i];}int snd_soc_register_codec(struct device *dev,		struct snd_soc_codec_driver *codec_drv,		struct snd_soc_dai_driver *dai_drv, int num_dai){	struct snd_soc_codec *codec;	int ret, i;	dev_dbg(dev, "codec register %s\n", dev_name(dev));	codec = kzalloc(sizeof(struct snd_soc_codec), GFP_KERNEL);	if (codec == NULL)		return -ENOMEM;	if (codec_drv == &null_codec_drv)		codec->name = kstrdup("null-codec", GFP_KERNEL);	else		codec->name = fmt_single_name(dev, &codec->id);	if (codec->name == NULL) {		kfree(codec);		return -ENOMEM;	}	codec->dapm = soc_new_dapm_context(dev);	if (codec->dapm == NULL) {		kfree(codec->name);		kfree(codec);		return -ENOMEM;	}	codec->dapm->codec = codec;	codec->dapm->stream_event = codec_drv->stream_event;	if (codec_drv->reg_cache_size && codec_drv->reg_word_size) {		if (codec_drv->reg_cache_default)			codec->reg_cache = kmemdup(codec_drv->reg_cache_default,				codec_drv->reg_cache_size * codec_drv->reg_word_size, GFP_KERNEL);		else			codec->reg_cache = kzalloc(codec_drv->reg_cache_size *				codec_drv->reg_word_size, GFP_KERNEL);		if (codec->reg_cache == NULL) {			kfree(codec->name);			kfree(codec->dapm);			kfree(codec);			return -ENOMEM;		}	}	codec->dev = dev;	codec->driver = codec_drv;	codec->num_dai = num_dai;	mutex_init(&codec->mutex);	for (i = 0; i < num_dai; i++) {		fixup_codec_formats(&dai_drv[i].playback);		fixup_codec_formats(&dai_drv[i].capture);	}	ret = snd_soc_register_dais(dev, dai_drv, num_dai);	if (ret < 0)			goto error;	mutex_lock(&client_mutex);	list_add(&codec->list, &codec_list);	snd_soc_instantiate_cards();	mutex_unlock(&client_mutex);	pr_debug("Registered codec '%s'\n", codec->name);	return 0;error:	for (i--; i >= 0; i--)		snd_soc_unregister_dai(dev);	if (codec->reg_cache)		kfree(codec->reg_cache);	kfree(codec->name);	kfree(codec->dapm);	kfree(codec);	return ret;}EXPORT_SYMBOL_GPL(snd_soc_register_codec);void snd_soc_unregister_codec(struct device *dev){	struct snd_soc_codec *codec;	int i;	list_for_each_entry(codec, &codec_list, list) {		if (dev == codec->dev)			goto found;	}	return;found:	for (i = 0; i < codec->num_dai; i++)		snd_soc_unregister_dai(dev);	mutex_lock(&client_mutex);	list_del(&codec->list);	mutex_unlock(&client_mutex);	pr_debug("Unregistered codec '%s'\n", codec->name);	if (codec->reg_cache)		kfree(codec->reg_cache);	kfree(codec->name);	kfree(codec->dapm);	kfree(codec);}EXPORT_SYMBOL_GPL(snd_soc_unregister_codec);static int __init snd_soc_init(void){#ifdef CONFIG_DEBUG_FS	debugfs_root = debugfs_create_dir("asoc", NULL);	if (IS_ERR(debugfs_root) || !debugfs_root) {		printk(KERN_WARNING		       "ASoC: Failed to create debugfs directory\n");		debugfs_root = NULL;	}#endif	return platform_driver_register(&soc_driver);}static void __exit snd_soc_exit(void){#ifdef CONFIG_DEBUG_FS	debugfs_remove_recursive(debugfs_root);#endif	platform_driver_unregister(&soc_driver);}module_init(snd_soc_init);module_exit(snd_soc_exit);MODULE_AUTHOR("Liam Girdwood, lrg@slimlogic.co.uk");MODULE_DESCRIPTION("ALSA SoC Core");MODULE_LICENSE("GPL");MODULE_ALIAS("platform:soc-audio");