#include <linux/module.h>#include <linux/moduleparam.h>#include <linux/init.h>#include <linux/delay.h>#include <linux/pm.h>#include <linux/i2c.h>#include <linux/gpio.h>#include <linux/platform_device.h>#include <linux/workqueue.h>#include <linux/clk.h>#include <linux/err.h>#include <linux/slab.h>#include <linux/pm_runtime.h>#include "abe_main.h"#include "abe_ref.h"#include "abe_typedef.h"#include "abe_initxxx_labels.h"#include "abe_dbg.h"int abe_reset_hal(void){	u32 i;	_log(id_reset_hal, 0, 0, 0);	abe->dbg_output = TERMINAL_OUTPUT;	abe->dbg_activity_log_write_pointer = 0;		abe->irq_dbg_read_ptr = 0;		abe->pdm_dl1_status = 0;	abe->pdm_dl2_status = 0;	abe->pdm_vib_status = 0;		abe_use_compensated_gain(0);		for (i = 0; i < MAX_NBGAIN_CMEM; i++) {		abe->muted_gains_indicator[i] = 0;		abe->desired_gains_decibel[i] = (u32) GAIN_MUTE;		abe->desired_gains_linear[i] = 0;		abe->desired_ramp_delay_ms[i] = 0;		abe->muted_gains_decibel[i] = (u32) GAIN_TOOLOW;	}		abe->dbg_mask = (abe_dbg_t) (0);	abe_hw_configuration();	return 0;}EXPORT_SYMBOL(abe_reset_hal);int abe_load_fw_param(u32 *ABE_FW){	u32 pmem_size, dmem_size, smem_size, cmem_size;	u32 *pmem_ptr, *dmem_ptr, *smem_ptr, *cmem_ptr, *fw_ptr;	_log(id_load_fw_param, 0, 0, 0);#define ABE_FW_OFFSET 5	fw_ptr = ABE_FW;	abe->firmware_version_number = *fw_ptr++;	pmem_size = *fw_ptr++;	cmem_size = *fw_ptr++;	dmem_size = *fw_ptr++;	smem_size = *fw_ptr++;	pmem_ptr = fw_ptr;	cmem_ptr = pmem_ptr + (pmem_size >> 2);	dmem_ptr = cmem_ptr + (cmem_size >> 2);	smem_ptr = dmem_ptr + (dmem_size >> 2);	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_PMEM, 0,		       pmem_ptr, pmem_size);	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_CMEM, 0,		       cmem_ptr, cmem_size);	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_SMEM, 0,		       smem_ptr, smem_size);	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM, 0,		       dmem_ptr, dmem_size);	return 0;}EXPORT_SYMBOL(abe_load_fw_param);int abe_reload_fw(void){	abe_load_fw_param((u32 *) abe_firmware_array);	abe_build_scheduler_table();		abe->dbg_activity_log_write_pointer = 0;	abe->irq_dbg_read_ptr = 0;	return 0;}EXPORT_SYMBOL(abe_reload_fw);int abe_load_fw(void){	_log(id_load_fw, 0, 0, 0);	abe_load_fw_param((u32 *) abe_firmware_array);	abe_reset_all_ports();	abe_build_scheduler_table();	abe_reset_all_sequence();	abe_select_main_port(PDM_DL_PORT);	return 0;}EXPORT_SYMBOL(abe_load_fw);int abe_read_hardware_configuration(u32 *u, u32 *o,					      abe_hw_config_init_t *hw){	_log(id_read_hardware_configuration, (u32) u,	     (u32) u >> 8, (u32) u >> 16);	abe_read_use_case_opp(u, o);		hw->MCPDM_CTRL__DIV_SEL = 0;	hw->MCPDM_CTRL__CMD_INT = 1;		hw->MCPDM_CTRL__PDMOUTFORMAT = 0;	hw->MCPDM_CTRL__PDM_DN5_EN = 1;	hw->MCPDM_CTRL__PDM_DN4_EN = 1;	hw->MCPDM_CTRL__PDM_DN3_EN = 1;	hw->MCPDM_CTRL__PDM_DN2_EN = 1;	hw->MCPDM_CTRL__PDM_DN1_EN = 1;	hw->MCPDM_CTRL__PDM_UP3_EN = 0;	hw->MCPDM_CTRL__PDM_UP2_EN = 1;	hw->MCPDM_CTRL__PDM_UP1_EN = 1;		hw->MCPDM_FIFO_CTRL_DN__DN_TRESH = MCPDM_DL_ITER / 6;	hw->MCPDM_FIFO_CTRL_UP__UP_TRESH = MCPDM_UL_ITER / 2;		hw->DMIC_CTRL__DMIC_CLK_DIV = 0;		hw->DMIC_CTRL__DMICOUTFORMAT = 0;	hw->DMIC_CTRL__DMIC_UP3_EN = 1;	hw->DMIC_CTRL__DMIC_UP2_EN = 1;	hw->DMIC_CTRL__DMIC_UP1_EN = 1;		hw->DMIC_FIFO_CTRL__DMIC_TRESH = DMIC_ITER / 6;	hw->MCBSP_SPCR1_REG__RJUST = 2;		hw->MCBSP_THRSH2_REG_REG__XTHRESHOLD = 1;		hw->MCBSP_THRSH1_REG_REG__RTHRESHOLD = 1;		hw->SLIMBUS_DCT_FIFO_SETUP_REG__SB_THRESHOLD = 1;		hw->AESS_EVENT_GENERATOR_COUNTER__COUNTER_VALUE =		EVENT_GENERATOR_COUNTER_DEFAULT;		hw->AESS_EVENT_SOURCE_SELECTION__SELECTION = 1;		hw->AESS_AUDIO_ENGINE_SCHEDULER__DMA_REQ_SELECTION =		ABE_ATC_MCPDMDL_DMA_REQ;		hw->HAL_EVENT_SELECTION = EVENT_TIMER;	return 0;}EXPORT_SYMBOL(abe_read_hardware_configuration);int abe_irq_processing(void){	u32 abe_irq_dbg_write_ptr, i, cmem_src, sm_cm;	abe_irq_data_t IRQ_data;#define IrqFiFoMask ((D_McuIrqFifo_sizeof >> 2) - 1)	_log(id_irq_processing, 0, 0, 0);	cmem_src = MCU_IRQ_FIFO_ptr_labelID << 2;	abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_CMEM, cmem_src,		       &sm_cm, sizeof(abe_irq_dbg_write_ptr));		abe_irq_dbg_write_ptr = sm_cm >> 16;	abe_irq_dbg_write_ptr &= 0xFF;		for (i = 0; i < D_McuIrqFifo_sizeof; i++) {				if (abe_irq_dbg_write_ptr == abe->irq_dbg_read_ptr)			break;				abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM,			       (D_McuIrqFifo_ADDR +				(abe->irq_dbg_read_ptr << 2)),			       (u32 *) &IRQ_data, sizeof(IRQ_data));		abe->irq_dbg_read_ptr =			(abe->irq_dbg_read_ptr + 1) & IrqFiFoMask;				switch (IRQ_data.tag) {		case IRQtag_APS:			_log(id_irq_processing, IRQ_data.data, 0, 1);			abe_irq_aps(IRQ_data.data);			break;		case IRQtag_PP:			_log(id_irq_processing, 0, 0, 2);			abe_irq_ping_pong();			break;		case IRQtag_COUNT:			_log(id_irq_processing, IRQ_data.data, 0, 3);			abe_irq_check_for_sequences(IRQ_data.data);			break;		default:			break;		}	}	abe_monitoring();	return 0;}EXPORT_SYMBOL(abe_irq_processing);int abe_select_main_port(u32 id){	u32 selection;	_log(id_select_main_port, id, 0, 0);		selection = D_IOdescr_ADDR + id * sizeof(ABE_SIODescriptor) +		flow_counter_;	selection &= 0xFFFFL;	if (abe_port[id].protocol.direction == ABE_ATC_DIRECTION_IN)		selection |= 0x80000;	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM, D_Slot23_ctrl_ADDR,		       &selection, 4);	return 0;}int abe_read_use_case_opp(u32 *u, u32 *o){	u32 opp, i;	u32 *ptr = u;#define MAX_READ_USE_CASE_OPP 10#define OPP_25 1#define OPP_50 2#define OPP_100 4	_log(id_read_use_case_opp, (u32) u, (u32) u >> 8, (u32) u >> 16);	opp = i = 0;	do {				if (i > MAX_READ_USE_CASE_OPP) {			abe->dbg_param |= ERR_API;			abe_dbg_error_log(ABE_READ_USE_CASE_OPP_ERR);			break;		}				if (*ptr <= 0)			break;				switch (*ptr) {		case ABE_AUDIO_PLAYER_ON_HEADSET_OR_EARPHONE:			opp |= OPP_25;			break;		case ABE_DRIFT_MANAGEMENT_FOR_AUDIO_PLAYER:			opp |= OPP_100;			break;		case ABE_DRIFT_MANAGEMENT_FOR_VOICE_CALL:			opp |= OPP_100;			break;		case ABE_VOICE_CALL_ON_HEADSET_OR_EARPHONE_OR_BT:			opp |= OPP_50;			break;		case ABE_MULTIMEDIA_AUDIO_RECORDER:			opp |= OPP_50;			break;		case ABE_VIBRATOR_OR_HAPTICS:			opp |= OPP_100;			break;		case ABE_VOICE_CALL_ON_HANDS_FREE_SPEAKER:			opp |= OPP_100;			break;		case ABE_RINGER_TONES:			opp |= OPP_100;			break;		case ABE_VOICE_CALL_WITH_EARPHONE_ACTIVE_NOISE_CANCELLER:			opp |= OPP_100;			break;		default:			break;		}		i++;		ptr++;	} while (*ptr != 0);	if (opp & OPP_100)		*o = ABE_OPP100;	else if (opp & OPP_50)		*o = ABE_OPP50;	else		*o = ABE_OPP25;	return 0;}EXPORT_SYMBOL(abe_read_use_case_opp);int abe_set_opp_processing(u32 opp){	u32 dOppMode32, sio_desc_address;	ABE_SIODescriptor sio_desc;	_lock_enter;	_log(id_set_opp_processing, opp, 0, 0);	switch (opp) {	case ABE_OPP25:				dOppMode32 = DOPPMODE32_OPP25;		break;	case ABE_OPP50:				dOppMode32 = DOPPMODE32_OPP50;		break;	default:		abe->dbg_param |= ERR_API;		abe_dbg_error_log(ABE_BLOCK_COPY_ERR);	case ABE_OPP100:				dOppMode32 = DOPPMODE32_OPP100;		break;	}		abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM,		       D_maxTaskBytesInSlot_ADDR, &dOppMode32, sizeof(u32));	sio_desc_address = dmem_port_descriptors + (MM_EXT_IN_PORT *						    sizeof(ABE_SIODescriptor));	abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM, sio_desc_address,		       (u32 *) &sio_desc, sizeof(sio_desc));	if (dOppMode32 == DOPPMODE32_OPP100) {				sio_desc.smem_addr1 = smem_mm_ext_in_opp100;				abe_init_asrc_mm_ext_in(250);	} else {				sio_desc.smem_addr1 = smem_mm_ext_in_opp50;	}	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM, sio_desc_address,		       (u32 *) &sio_desc, sizeof(sio_desc));	sio_desc_address = dmem_port_descriptors + (BT_VX_UL_PORT *						    sizeof(ABE_SIODescriptor));	abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM, sio_desc_address,		       (u32 *) &sio_desc, sizeof(sio_desc));	if (abe_port[BT_VX_UL_PORT].format.f == 8000) {		if (dOppMode32 == DOPPMODE32_OPP100)				sio_desc.smem_addr1 = smem_bt_vx_ul_opp100;		else							sio_desc.smem_addr1 = BT_UL_8k_labelID;	} else {		if (dOppMode32 == DOPPMODE32_OPP100)						sio_desc.smem_addr1 = smem_bt_vx_ul_opp100;		else						sio_desc.smem_addr1 = BT_UL_16k_labelID;	}	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM, sio_desc_address,		       (u32 *) &sio_desc, sizeof(sio_desc));	sio_desc_address = dmem_port_descriptors + (BT_VX_DL_PORT *						    sizeof(ABE_SIODescriptor));	abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM, sio_desc_address,		       (u32 *) &sio_desc, sizeof(sio_desc));#define ABE_TASK_ID(ID) (D_tasksList_ADDR + sizeof(ABE_STask)*(ID))#define TASK_BT_DL_48_8_SLT 14#define TASK_BT_DL_48_8_IDX 4 	if (abe_port[BT_VX_DL_PORT].format.f == 8000) {	if (dOppMode32 == DOPPMODE32_OPP100) {			abe->MultiFrame[TASK_BT_DL_48_8_SLT][TASK_BT_DL_48_8_IDX] =				ABE_TASK_ID(C_ABE_FW_TASK_BT_DL_48_8_OPP100);			sio_desc.smem_addr1 = BT_DL_8k_opp100_labelID;	} else {			abe->MultiFrame[TASK_BT_DL_48_8_SLT][TASK_BT_DL_48_8_IDX] =				ABE_TASK_ID(C_ABE_FW_TASK_BT_DL_48_8);			sio_desc.smem_addr1 = BT_DL_8k_labelID;	}	} else {		if (dOppMode32 == DOPPMODE32_OPP100) {			abe->MultiFrame[TASK_BT_DL_48_8_SLT][TASK_BT_DL_48_8_IDX] =				ABE_TASK_ID(C_ABE_FW_TASK_BT_DL_48_16_OPP100);			sio_desc.smem_addr1 = BT_DL_16k_opp100_labelID;		} else {			abe->MultiFrame[TASK_BT_DL_48_8_SLT][TASK_BT_DL_48_8_IDX] =				ABE_TASK_ID(C_ABE_FW_TASK_BT_DL_48_16);			sio_desc.smem_addr1 = BT_DL_16k_labelID;		}	}	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM, D_multiFrame_ADDR,				(u32 *) abe->MultiFrame, sizeof(abe->MultiFrame));	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM, sio_desc_address,		       (u32 *) &sio_desc, sizeof(sio_desc));	if (dOppMode32 == DOPPMODE32_OPP100) {				abe_init_asrc_bt_ul(250);				abe_init_asrc_bt_dl(-250);	}	return 0;	}EXPORT_SYMBOL(abe_set_opp_processing);int abe_set_ping_pong_buffer(u32 port, u32 n_bytes){	u32 sio_pp_desc_address, struct_offset, n_samples, datasize,		base_and_size, *src;	ABE_SPingPongDescriptor desc_pp;	_log(id_set_ping_pong_buffer, port, n_bytes, n_bytes >> 8);		if (port != MM_DL_PORT) {		abe->dbg_param |= ERR_API;		abe_dbg_error_log(ABE_PARAMETER_ERROR);		return -EINVAL;	}	datasize = abe_dma_port_iter_factor(&((abe_port[port]).format));		datasize = datasize << 2;	n_samples = n_bytes / datasize;	abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM, D_PingPongDesc_ADDR,		       (u32 *) &desc_pp, sizeof(desc_pp));	if ((desc_pp.counter & 0x1) == 0) {		struct_offset = (u32) &(desc_pp.nextbuff0_BaseAddr) -			(u32) &(desc_pp);		base_and_size = desc_pp.nextbuff0_BaseAddr;	} else {		struct_offset = (u32) &(desc_pp.nextbuff1_BaseAddr) -			(u32) &(desc_pp);		base_and_size = desc_pp.nextbuff1_BaseAddr;	}	base_and_size = (base_and_size & 0xFFFFL) + (n_samples << 16);	sio_pp_desc_address = D_PingPongDesc_ADDR + struct_offset;	src = &base_and_size;	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM, sio_pp_desc_address,		       (u32 *) &base_and_size, sizeof(u32));	return 0;}EXPORT_SYMBOL(abe_set_ping_pong_buffer);int abe_read_next_ping_pong_buffer(u32 port, u32 *p, u32 *n){	u32 sio_pp_desc_address;	ABE_SPingPongDescriptor desc_pp;	_log(id_read_next_ping_pong_buffer, port, 0, 0);		if (port != MM_DL_PORT) {		abe->dbg_param |= ERR_API;		abe_dbg_error_log(ABE_PARAMETER_ERROR);		return -EINVAL;	}	sio_pp_desc_address = D_PingPongDesc_ADDR;	abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM, sio_pp_desc_address,		       (u32 *) &desc_pp, sizeof(ABE_SPingPongDescriptor));	if ((desc_pp.counter & 0x1) == 0) {		_log(id_read_next_ping_pong_buffer, port, 0, 0);		*p = desc_pp.nextbuff0_BaseAddr;	} else {		_log(id_read_next_ping_pong_buffer, port, 1, 0);		*p = desc_pp.nextbuff1_BaseAddr;	}		*n = abe_size_pingpong;	return 0;}EXPORT_SYMBOL(abe_read_next_ping_pong_buffer);int abe_init_ping_pong_buffer(u32 id, u32 size_bytes, u32 n_buffers,					u32 *p){	u32 i, dmem_addr;	_log(id_init_ping_pong_buffer, id, size_bytes, n_buffers);	if (id != MM_DL_PORT || n_buffers > MAX_PINGPONG_BUFFERS) {		abe->dbg_param |= ERR_API;		abe_dbg_error_log(ABE_PARAMETER_ERROR);		return -EINVAL;	}	for (i = 0; i < n_buffers; i++) {		dmem_addr = dmem_ping_pong_buffer + (i * size_bytes);				abe_base_address_pingpong[i] = dmem_addr;	}		abe_size_pingpong = size_bytes;	*p = (u32) dmem_ping_pong_buffer;	return 0;}EXPORT_SYMBOL(abe_init_ping_pong_buffer);int abe_read_offset_from_ping_buffer(u32 id, u32 *n){	u32 sio_pp_desc_address;	ABE_SPingPongDescriptor desc_pp;	if (MM_DL_PORT != id) {		abe->dbg_param |= ERR_API;		abe_dbg_error_log(ABE_PARAMETER_ERROR);		return -EINVAL;	} else {				sio_pp_desc_address = D_PingPongDesc_ADDR;		abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM,			       sio_pp_desc_address, (u32 *) &desc_pp,			       sizeof(ABE_SPingPongDescriptor));		if ((desc_pp.counter & 0x1) == 0) {						switch (abe_port[MM_DL_PORT].format.samp_format) {			case MONO_MSB:			case MONO_RSHIFTED_16:			case STEREO_16_16:				*n = abe_size_pingpong / 4 +					desc_pp.nextbuff1_Samples -					desc_pp.workbuff_Samples;				break;			case STEREO_MSB:			case STEREO_RSHIFTED_16:				*n = abe_size_pingpong / 8 +					desc_pp.nextbuff1_Samples -					desc_pp.workbuff_Samples;				break;			default:				abe->dbg_param |= ERR_API;				abe_dbg_error_log(ABE_PARAMETER_ERROR);				return -EINVAL;			}		} else {						*n = desc_pp.nextbuff0_Samples -				desc_pp.workbuff_Samples;		}	}	return 0;}EXPORT_SYMBOL(abe_read_offset_from_ping_buffer);int abe_plug_subroutine(u32 *id, abe_subroutine2 f, u32 n,				  u32 *params){	_log(id_plug_subroutine, (u32) (*id), (u32) f, n);		abe_add_subroutine(id, (abe_subroutine2) f, n, (u32 *) params);	return 0;}EXPORT_SYMBOL(abe_plug_subroutine);int abe_set_sequence_time_accuracy(u32 fast, u32 slow){	u32 data;	_log(id_set_sequence_time_accuracy, fast, slow, 0);	data = minimum(MAX_UINT16, fast / FW_SCHED_LOOP_FREQ_DIV1000);	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM, D_fastCounter_ADDR,		       &data, sizeof(data));	data = minimum(MAX_UINT16, slow / FW_SCHED_LOOP_FREQ_DIV1000);	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM, D_slowCounter_ADDR,		       &data, sizeof(data));	return 0;}EXPORT_SYMBOL(abe_set_sequence_time_accuracy);int abe_reset_port(u32 id){	_log(id_reset_port, id, 0, 0);	abe_port[id] = ((abe_port_t *) abe_port_init)[id];	return 0;}EXPORT_SYMBOL(abe_reset_port);int abe_read_remaining_data(u32 port, u32 *n){	u32 sio_pp_desc_address;	ABE_SPingPongDescriptor desc_pp;	_log(id_read_remaining_data, port, 0, 0);	sio_pp_desc_address = D_PingPongDesc_ADDR;	abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM, sio_pp_desc_address,		       (u32 *) &desc_pp, sizeof(ABE_SPingPongDescriptor));	*n = desc_pp.workbuff_Samples;	return 0;}EXPORT_SYMBOL(abe_read_remaining_data);int abe_disable_data_transfer(u32 id){	abe_port_protocol_t *protocol;	_log(id_disable_data_transfer, id, 0, 0);	if (id == PDM_DL1_PORT) {		abe->pdm_dl1_status = 0;		if (abe->pdm_dl2_status || abe->pdm_vib_status)			return 0;		id = PDM_DL_PORT;	}	if (id == PDM_DL2_PORT) {		abe->pdm_dl2_status = 0;		if (abe->pdm_dl1_status || abe->pdm_vib_status)			return 0;		id = PDM_DL_PORT;	}	if (id == PDM_VIB_PORT) {		abe->pdm_vib_status = 0;		if (abe->pdm_dl1_status || abe->pdm_dl2_status)			return 0;		id = PDM_DL_PORT;	}		if (id == MM_DL_PORT) {		protocol = &(abe_port[MM_DL_PORT].protocol);		if (protocol->protocol_switch == PINGPONG_PORT_PROT)			abe_disable_pp_io_task(MM_DL_PORT);	}		abe_port[id].status = OMAP_ABE_PORT_ACTIVITY_IDLE;		abe_disable_dma_request(id);		abe_init_atc(id);	abe_clean_temporary_buffers(id);		abe_decide_main_port();	return 0;}EXPORT_SYMBOL(abe_disable_data_transfer);int abe_enable_data_transfer(u32 id){	abe_port_protocol_t *protocol;	abe_data_format_t format;	_log(id_enable_data_transfer, id, 0, 0);	if (id == PDM_DL1_PORT) {		id = PDM_DL_PORT;		if (abe->pdm_dl1_status == 1)			return 0;		abe->pdm_dl1_status = 1;	}	if (id == PDM_DL2_PORT) {		id = PDM_DL_PORT;		if (abe->pdm_dl2_status == 1)			return 0;		abe->pdm_dl2_status = 1;	}	if (id == PDM_VIB_PORT) {		id = PDM_DL_PORT;		if (abe->pdm_vib_status == 1)			return 0;		abe->pdm_vib_status = 1;	}	abe_clean_temporary_buffers(id);	if (id == PDM_UL_PORT) {				protocol = &(abe_port[PDM_UL_PORT].protocol);		format = abe_port[PDM_UL_PORT].format;		abe_init_atc(PDM_UL_PORT);		abe_init_io_tasks(PDM_UL_PORT, &format, protocol);	}	if (id == PDM_DL_PORT) {				protocol = &(abe_port[PDM_DL_PORT].protocol);		format = abe_port[PDM_DL_PORT].format;		abe_init_atc(PDM_DL_PORT);		abe_init_io_tasks(PDM_DL_PORT, &format, protocol);	}		if (id == MM_DL_PORT) {		protocol = &(abe_port[MM_DL_PORT].protocol);		if (protocol->protocol_switch == PINGPONG_PORT_PROT)			abe_enable_pp_io_task(MM_DL_PORT);	}	if (id == DMIC_PORT) {		protocol = &(abe_port[DMIC_PORT].protocol);		format = abe_port[DMIC_PORT].format;		abe_init_atc(DMIC_PORT);		abe_init_io_tasks(DMIC_PORT, &format, protocol);	}	if (id == VX_UL_PORT) {		if (abe_port[VX_DL_PORT].status == OMAP_ABE_PORT_ACTIVITY_RUNNING) {		} else {						abe_init_asrc_vx_ul(-250);			abe_init_asrc_vx_dl(250);		}	}	if (id == VX_DL_PORT) {		if (abe_port[VX_UL_PORT].status == OMAP_ABE_PORT_ACTIVITY_RUNNING) {		} else {						abe_init_asrc_vx_ul(-250);		abe_init_asrc_vx_dl(250);	}	}		abe_port[id].status = OMAP_ABE_PORT_ACTIVITY_RUNNING;		abe_enable_dma_request(id);		abe_decide_main_port();	return 0;}EXPORT_SYMBOL(abe_enable_data_transfer);int abe_connect_cbpr_dmareq_port(u32 id, abe_data_format_t *f, u32 d,					   abe_dma_t *returned_dma_t){	_log(id_connect_cbpr_dmareq_port, id, f->f, f->samp_format);	abe_port[id] = ((abe_port_t *) abe_port_init)[id];	(abe_port[id]).format = (*f);	abe_port[id].protocol.protocol_switch = DMAREQ_PORT_PROT;	abe_port[id].protocol.p.prot_dmareq.iter = abe_dma_port_iteration(f);	abe_port[id].protocol.p.prot_dmareq.dma_addr = ABE_DMASTATUS_RAW;	abe_port[id].protocol.p.prot_dmareq.dma_data = (1 << d);		abe_init_dma_t(id, &((abe_port[id]).protocol));	abe_init_io_tasks(id, &((abe_port[id]).format),			  &((abe_port[id]).protocol));	abe_port[id].status = OMAP_ABE_PORT_INITIALIZED;	abe_init_atc(id);		abe_read_port_address(id, returned_dma_t);	return 0;}EXPORT_SYMBOL(abe_connect_cbpr_dmareq_port);int abe_connect_dmareq_ping_pong_port(u32 id, abe_data_format_t *f,						u32 d, u32 s,						abe_dma_t *returned_dma_t){	abe_dma_t dma1;	_log(id_connect_dmareq_ping_pong_port, id, f->f, f->samp_format);		if (id != MM_DL_PORT) {		abe->dbg_param |= ERR_API;		abe_dbg_error_log(ABE_PARAMETER_ERROR);		return -EINVAL;	}		abe_init_ping_pong_buffer(MM_DL_PORT, s, 2,				  (u32 *) &(returned_dma_t->data));	abe_port[id] = ((abe_port_t *) abe_port_init)[id];	(abe_port[id]).format = (*f);	(abe_port[id]).protocol.protocol_switch = PINGPONG_PORT_PROT;	(abe_port[id]).protocol.p.prot_pingpong.buf_addr =		dmem_ping_pong_buffer;	(abe_port[id]).protocol.p.prot_pingpong.buf_size = s;	(abe_port[id]).protocol.p.prot_pingpong.irq_addr = ABE_DMASTATUS_RAW;	(abe_port[id]).protocol.p.prot_pingpong.irq_data = (1 << d);	abe_port[id].status = OMAP_ABE_PORT_INITIALIZED;		abe_init_io_tasks(id, &((abe_port[id]).format),			  &((abe_port[id]).protocol));		abe_init_dma_t(id, &((abe_port[id]).protocol));	dma1.data = (u32 *) (abe_port[id].dma.data +		ABE_DEFAULT_BASE_ADDRESS_L3 + ABE_DMEM_BASE_OFFSET_MPU);	dma1.iter = abe_port[id].dma.iter;	*returned_dma_t = dma1;	return 0;}EXPORT_SYMBOL(abe_connect_dmareq_ping_pong_port);int abe_connect_irq_ping_pong_port(u32 id, abe_data_format_t *f,					     u32 subroutine_id, u32 size,					     u32 *sink, u32 dsp_mcu_flag){	_log(id_connect_irq_ping_pong_port, id, f->f, f->samp_format);		if (id != MM_DL_PORT) {		abe->dbg_param |= ERR_API;		abe_dbg_error_log(ABE_PARAMETER_ERROR);		return -EINVAL;	}	abe_port[id] = ((abe_port_t *) abe_port_init)[id];	(abe_port[id]).format = (*f);	(abe_port[id]).protocol.protocol_switch = PINGPONG_PORT_PROT;	(abe_port[id]).protocol.p.prot_pingpong.buf_addr =		dmem_ping_pong_buffer;	(abe_port[id]).protocol.p.prot_pingpong.buf_size = size;	(abe_port[id]).protocol.p.prot_pingpong.irq_data = (1);	abe_init_ping_pong_buffer(MM_DL_PORT, size, 2, sink);	if (dsp_mcu_flag == PING_PONG_WITH_MCU_IRQ)		(abe_port[id]).protocol.p.prot_pingpong.irq_addr =			ABE_MCU_IRQSTATUS_RAW;	if (dsp_mcu_flag == PING_PONG_WITH_DSP_IRQ)		(abe_port[id]).protocol.p.prot_pingpong.irq_addr =			ABE_DSP_IRQSTATUS_RAW;	abe_port[id].status = OMAP_ABE_PORT_INITIALIZED;		abe_init_io_tasks(id, &((abe_port[id]).format),			  &((abe_port[id]).protocol));		abe_init_atc(id);	*sink = (abe_port[id]).protocol.p.prot_pingpong.buf_addr;	return 0;}EXPORT_SYMBOL(abe_connect_irq_ping_pong_port);int abe_connect_serial_port(u32 id, abe_data_format_t *f,				      u32 mcbsp_id){	u32 UC_NULL[] = { 0 };	u32 OPP;	abe_hw_config_init_t CONFIG;	_log(id_connect_serial_port, id, f->samp_format, mcbsp_id);	abe_port[id] = ((abe_port_t *) abe_port_init)[id];	(abe_port[id]).format = (*f);	(abe_port[id]).protocol.protocol_switch = SERIAL_PORT_PROT;		(abe_port[id]).protocol.p.prot_serial.desc_addr = mcbsp_id*ATC_SIZE;		abe_read_hardware_configuration(UC_NULL, &OPP, &CONFIG);	(abe_port[id]).protocol.p.prot_serial.iter =		abe_dma_port_iter_factor(f);	abe_init_io_tasks(id, &((abe_port[id]).format),			  &((abe_port[id]).protocol));	abe_port[id].status = OMAP_ABE_PORT_INITIALIZED;		abe_init_atc(id);	return 0;}EXPORT_SYMBOL(abe_connect_serial_port);int abe_connect_slimbus_port(u32 id, abe_data_format_t *f,				       u32 sb_port1, u32 sb_port2){	u32 UC_NULL[] = { 0 };	u32 OPP;	abe_hw_config_init_t CONFIG;	u32 iter;	_log(id_connect_slimbus_port, id, f->samp_format, sb_port2);	abe_port[id] = ((abe_port_t *) abe_port_init)[id];	(abe_port[id]).format = (*f);	(abe_port[id]).protocol.protocol_switch = SLIMBUS_PORT_PROT;		(abe_port[id]).protocol.p.prot_slimbus.desc_addr1 = sb_port1*ATC_SIZE;		(abe_port[id]).protocol.p.prot_slimbus.desc_addr2 = sb_port2*ATC_SIZE;		abe_read_hardware_configuration(UC_NULL, &OPP, &CONFIG);	iter = CONFIG.SLIMBUS_DCT_FIFO_SETUP_REG__SB_THRESHOLD;		(abe_port[id]).protocol.p.prot_serial.iter = iter;	abe_port[id].status = OMAP_ABE_PORT_INITIALIZED;		abe_init_io_tasks(id, &((abe_port[id]).format),			  &((abe_port[id]).protocol));		abe_init_atc(id);	return 0;}EXPORT_SYMBOL(abe_connect_slimbus_port);int abe_connect_tdm_port(u32 id, abe_data_format_t *f, u32 mcbsp_id){	u32 UC_NULL[] = { 0 };	u32 OPP;	abe_hw_config_init_t CONFIG;	u32 iter;	_log(id_connect_tdm_port, id, f->samp_format, mcbsp_id);	abe_port[id] = ((abe_port_t *) abe_port_init)[id];	(abe_port[id]).format = (*f);	(abe_port[id]).protocol.protocol_switch = TDM_SERIAL_PORT_PROT;		(abe_port[id]).protocol.p.prot_serial.desc_addr = mcbsp_id*ATC_SIZE;		abe_read_hardware_configuration(UC_NULL, &OPP, &CONFIG);	if (abe_port[id].protocol.direction == ABE_ATC_DIRECTION_IN)		iter = CONFIG.MCBSP_THRSH1_REG_REG__RTHRESHOLD;	else		iter = CONFIG.MCBSP_THRSH2_REG_REG__XTHRESHOLD;		(abe_port[id]).protocol.p.prot_serial.iter = iter;	abe_port[id].status = OMAP_ABE_PORT_INITIALIZED;		abe_init_io_tasks(id, &((abe_port[id]).format),			  &((abe_port[id]).protocol));		abe_init_atc(id);	return 0;}EXPORT_SYMBOL(abe_connect_tdm_port);int abe_read_port_address(u32 port, abe_dma_t *dma2){	abe_dma_t_offset dma1;	u32 protocol_switch;	_log(id_read_port_address, port, 0, 0);	dma1 = (abe_port[port]).dma;	protocol_switch = abe_port[port].protocol.protocol_switch;	switch (protocol_switch) {	case PINGPONG_PORT_PROT:				(*dma2).data = (void *)(dma1.data +			ABE_DEFAULT_BASE_ADDRESS_L3 + ABE_DMEM_BASE_OFFSET_MPU);		(*dma2).l3_dmem = (void *)(dma1.data +			ABE_DEFAULT_BASE_ADDRESS_L3 + ABE_DMEM_BASE_OFFSET_MPU);		(*dma2).l4_dmem = (void *)(dma1.data +			ABE_DEFAULT_BASE_ADDRESS_L4 + ABE_DMEM_BASE_OFFSET_MPU);		break;	case DMAREQ_PORT_PROT:				(*dma2).data = (void *)(dma1.data +			ABE_DEFAULT_BASE_ADDRESS_L3 + ABE_ATC_BASE_OFFSET_MPU);		(*dma2).l3_dmem =			(void *)((abe_port[port]).protocol.p.prot_dmareq.buf_addr +			ABE_DEFAULT_BASE_ADDRESS_L3 + ABE_DMEM_BASE_OFFSET_MPU);		(*dma2).l4_dmem =			(void *)((abe_port[port]).protocol.p.prot_dmareq.buf_addr +			ABE_DEFAULT_BASE_ADDRESS_L4 + ABE_DMEM_BASE_OFFSET_MPU);		break;	default:		break;	}	(*dma2).iter = (dma1.iter);	return 0;}EXPORT_SYMBOL(abe_read_port_address);int abe_select_data_source(u32 port_id, u32 smem_source){	u32 sio_desc_address;	ABE_SIODescriptor sio_desc;	sio_desc_address = dmem_port_descriptors +		(port_id * sizeof(ABE_SIODescriptor));	abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM,		       sio_desc_address, (u32 *) &sio_desc, sizeof(sio_desc));	sio_desc.smem_addr1 = (u16) smem_source;	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM,		       sio_desc_address, (u32 *) &sio_desc, sizeof(sio_desc));	return 0;}EXPORT_SYMBOL(abe_select_data_source);int abe_write_equalizer(u32 id, abe_equ_t *param){	u32 eq_offset, length, *src, eq_mem, eq_mem_len;	_log(id_write_equalizer, id, 0, 0);	switch (id) {	default:	case EQ1:		eq_offset = C_DL1_Coefs_ADDR;		eq_mem = S_DL1_M_EQ_data_ADDR;		eq_mem_len = S_DL1_M_EQ_data_sizeof;		break;	case EQ2L:		eq_offset = C_DL2_L_Coefs_ADDR;		eq_mem = S_DL2_M_LR_EQ_data_ADDR;		eq_mem_len = S_DL2_M_LR_EQ_data_sizeof;		break;	case EQ2R:		eq_offset = C_DL2_R_Coefs_ADDR;		eq_mem = S_DL2_M_LR_EQ_data_ADDR;		eq_mem_len = S_DL2_M_LR_EQ_data_sizeof;		break;	case EQSDT:		eq_offset = C_SDT_Coefs_ADDR;		eq_mem = S_SDT_F_data_ADDR;		eq_mem_len = S_SDT_F_data_sizeof;		break;	case EQAMIC:		eq_offset = C_96_48_AMIC_Coefs_ADDR;		eq_mem = S_AMIC_96_48_data_ADDR;		eq_mem_len = S_AMIC_96_48_data_sizeof;		break;	case EQDMIC:		eq_offset = C_96_48_DMIC_Coefs_ADDR;		eq_mem = S_DMIC0_96_48_data_ADDR;		eq_mem_len = S_DMIC0_96_48_data_sizeof;				eq_mem_len *= 3;		break;	case APS1:		eq_offset = C_APS_DL1_coeffs1_ADDR;		eq_mem = S_APS_IIRmem1_ADDR;		eq_mem_len = S_APS_IIRmem1_sizeof;		break;	case APS2L:		eq_offset = C_APS_DL2_L_coeffs1_ADDR;		eq_mem = S_APS_M_IIRmem2_ADDR;		eq_mem_len = S_APS_M_IIRmem2_sizeof;		break;	case APS2R:		eq_offset = C_APS_DL2_R_coeffs1_ADDR;		eq_mem = S_APS_M_IIRmem2_ADDR;		eq_mem_len = S_APS_M_IIRmem2_sizeof;		break;	}	length = param->equ_length;	src = (u32 *) ((param->coef).type1);		eq_offset <<= 2;		abe_reset_mem(ABE_SMEM, eq_mem << 3, eq_mem_len << 3);		length <<= 2;	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_CMEM, eq_offset, src, length);		abe_reset_mem(ABE_SMEM, eq_mem << 3, eq_mem_len << 3);	return 0;}EXPORT_SYMBOL(abe_write_equalizer);int abe_write_asrc(u32 port, s32 dppm){	s32 dtempvalue, adppm, drift_sign, drift_sign_addr, alpha_params_addr;	s32 alpha_params[3];	_log(id_write_asrc, port, dppm, dppm >> 8);	if (dppm >= 0) {				drift_sign = 1;		adppm = dppm;	} else {				drift_sign = -1;		adppm = (-1 * dppm);	}	if (dppm == 0) {				alpha_params[0] = 0;				alpha_params[1] = 0;				alpha_params[2] = 0x003ffff0;	} else {		dtempvalue = (adppm << 4) + adppm - ((adppm * 3481L) / 15625L);				alpha_params[0] = dtempvalue << 2;				alpha_params[1] = (-dtempvalue) << 2;				alpha_params[2] = (0x00100000 - (dtempvalue / 2)) << 2;	}	switch (port) {			case VX_DL_PORT:		drift_sign_addr = D_AsrcVars_DL_VX_ADDR + (1 * sizeof(s32));		alpha_params_addr = D_AsrcVars_DL_VX_ADDR + (3 * sizeof(s32));		break;			case VX_UL_PORT:		drift_sign_addr = D_AsrcVars_UL_VX_ADDR + (1 * sizeof(s32));		alpha_params_addr = D_AsrcVars_UL_VX_ADDR + (3 * sizeof(s32));		break;			case BT_VX_UL_PORT:		drift_sign_addr = D_AsrcVars_BT_UL_ADDR + (1 * sizeof(s32));		alpha_params_addr = D_AsrcVars_BT_UL_ADDR + (3 * sizeof(s32));		break;			case BT_VX_DL_PORT:		drift_sign_addr = D_AsrcVars_BT_DL_ADDR + (1 * sizeof(s32));		alpha_params_addr = D_AsrcVars_BT_DL_ADDR + (3 * sizeof(s32));		break;	default:			case MM_EXT_IN_PORT:		drift_sign_addr = D_AsrcVars_MM_EXT_IN_ADDR + (1 * sizeof(s32));		alpha_params_addr =			D_AsrcVars_MM_EXT_IN_ADDR + (3 * sizeof(s32));		break;	}	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM, drift_sign_addr,		       (u32 *) &drift_sign, 4);	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM, alpha_params_addr,		       (u32 *) &alpha_params[0], 12);	return 0;}EXPORT_SYMBOL(abe_write_asrc);int abe_write_aps(u32 id, abe_aps_t *param){	_log(id_write_aps, id, 0, 0);	return 0;}EXPORT_SYMBOL(abe_write_aps);int abe_use_compensated_gain(u32 on_off){	abe->compensated_mixer_gain = on_off;	return 0;}EXPORT_SYMBOL(abe_use_compensated_gain);int abe_disable_gain(u32 id, u32 p){	u32 mixer_offset, f_g, ramp;	abe_gain_offset(id, &mixer_offset);	ramp = abe->desired_ramp_delay_ms[mixer_offset + p];	f_g = GAIN_MUTE;	if (!(abe->muted_gains_indicator[mixer_offset + p] & 0x02)) { 				if (!(abe->muted_gains_indicator[mixer_offset + p] & 0x01)) {			abe->muted_gains_decibel[mixer_offset + p] =				abe->desired_gains_decibel[mixer_offset + p];					abe_write_gain(id, f_g, ramp, p);		}		abe->muted_gains_indicator[mixer_offset + p] |= 0x02;	}	return 0;}EXPORT_SYMBOL(abe_disable_gain);int abe_enable_gain(u32 id, u32 p){	u32 mixer_offset, f_g, ramp;	abe_gain_offset(id, &mixer_offset);	if ((abe->muted_gains_indicator[mixer_offset + p] & 0x02)) {				f_g = abe->muted_gains_decibel[mixer_offset + p];		ramp = abe->desired_ramp_delay_ms[mixer_offset + p];		abe->muted_gains_indicator[mixer_offset + p] &= ~0x02;				abe_write_gain(id, f_g, ramp, p);	}	return 0;}EXPORT_SYMBOL(abe_enable_gain);int abe_mute_gain(u32 id, u32 p){	u32 mixer_offset, f_g, ramp;	abe_gain_offset(id, &mixer_offset);		ramp = abe->desired_ramp_delay_ms[mixer_offset + p];	f_g = GAIN_MUTE;	if (!abe->muted_gains_indicator[mixer_offset + p]) {		abe->muted_gains_decibel[mixer_offset + p] =			abe->desired_gains_decibel[mixer_offset + p];				abe_write_gain(id, f_g, ramp, p);	}	abe->muted_gains_indicator[mixer_offset + p] |= 0x01;	return 0;}EXPORT_SYMBOL(abe_mute_gain);int abe_unmute_gain(u32 id, u32 p){	u32 mixer_offset, f_g, ramp;	abe_gain_offset(id, &mixer_offset);	if ((abe->muted_gains_indicator[mixer_offset + p] & 0x01)) {				f_g = abe->muted_gains_decibel[mixer_offset + p];		ramp = abe->desired_ramp_delay_ms[mixer_offset + p];		abe->muted_gains_indicator[mixer_offset + p] &= ~0x01;				abe_write_gain(id, f_g, ramp, p);	}	return 0;}EXPORT_SYMBOL(abe_unmute_gain);int abe_write_gain(u32 id, s32 f_g, u32 ramp, u32 p){	u32 lin_g, sum_g, mixer_target, mixer_offset, i, mean_gain, mean_exp;	u32 new_gain_linear[4];	s32 gain_index;	u32 alpha, beta;	u32 ramp_index;	_log(id_write_gain, id, f_g, p);	gain_index = ((f_g - min_mdb) / 100);	gain_index = maximum(gain_index, 0);	gain_index = minimum(gain_index, sizeof_db2lin_table);	lin_g = abe_db2lin_table[gain_index];	abe_gain_offset(id, &mixer_offset);		abe->desired_gains_linear[mixer_offset + p] = lin_g;	abe->desired_gains_decibel[mixer_offset + p] = f_g;	abe->desired_ramp_delay_ms[mixer_offset + p] = ramp;		mixer_target = (S_GTarget1_ADDR << 1);	mixer_target += mixer_offset;	mixer_target += p;		mixer_target <<= 2;	if (abe->compensated_mixer_gain) {		switch (id) {		case MIXDL1:		case MIXDL2:		case MIXVXREC:		case MIXAUDUL:						for (sum_g = i = 0; i < 4; i++)				sum_g += abe->desired_gains_linear[						mixer_offset + i];						if (sum_g == 0)				break;			if (sum_g < 0x00040000) {					sum_g = 0x00040000;			}						abe_int_2_float16(sum_g, &mean_gain, &mean_exp);			mean_exp = 10 - mean_exp;			for (i = 0; i < 4; i++) {								new_gain_linear[i] =					(abe->desired_gains_linear					 [mixer_offset + i]					 << 8) / mean_gain;				new_gain_linear[i] = (mean_exp > 0) ?					new_gain_linear[i] << mean_exp :					new_gain_linear[i] >> mean_exp;			}						abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_SMEM,				       mixer_target - (p << 2),				       new_gain_linear, (4 * sizeof(lin_g)));			break;		default:						abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_SMEM,				       mixer_target,				       (u32 *) &lin_g, sizeof(lin_g));			break;		}	} else {		if (!abe->muted_gains_indicator[mixer_offset + p])						abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_SMEM,				       mixer_target, (u32 *) &lin_g,				       sizeof(lin_g));		else						abe->muted_gains_decibel[mixer_offset + p] = f_g;	}	ramp = maximum(minimum(RAMP_MAXLENGTH, ramp), RAMP_MINLENGTH);		ramp_index = 8;	if ((RAMP_5MS <= ramp) && (ramp < RAMP_50MS))		ramp_index = 24;	if ((RAMP_50MS <= ramp) && (ramp < RAMP_500MS))		ramp_index = 36;	if (ramp > RAMP_500MS)		ramp_index = 48;	beta = abe_alpha_iir[ramp_index];	alpha = abe_1_alpha_iir[ramp_index];		mixer_target = C_1_Alpha_ADDR;		mixer_target += (p + mixer_offset) >> 1;		mixer_target <<= 2;		abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_CMEM, mixer_target,		       (u32 *) &alpha, sizeof(alpha));		mixer_target = C_Alpha_ADDR;		mixer_target += (p + mixer_offset) >> 1;		mixer_target <<= 2;	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_CMEM, mixer_target,		       (u32 *) &beta, sizeof(beta));	return 0;}EXPORT_SYMBOL(abe_write_gain);int abe_write_mixer(u32 id, s32 f_g, u32 f_ramp, u32 p){	_log(id_write_mixer, id, f_ramp, p);	abe_write_gain(id, f_g, f_ramp, p);	return 0;}EXPORT_SYMBOL(abe_write_mixer);int abe_read_gain(u32 id, u32 *f_g, u32 p){	u32 mixer_target, mixer_offset, i;	_log(id_read_gain, id, (u32) f_g, p);		abe_gain_offset(id, &mixer_offset);		mixer_target = (S_GTarget1_ADDR << 1);	mixer_target += mixer_offset;	mixer_target += p;		mixer_target <<= 2;	if (!abe->muted_gains_indicator[mixer_offset + p]) {		abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_SMEM, mixer_target,		       (u32 *) f_g, sizeof(*f_g));	for (i = 0; i < sizeof_db2lin_table; i++) {		if (abe_db2lin_table[i] == *f_g)			goto found;	}	*f_g = 0;	return -1;      found:	*f_g = (i * 100) + min_mdb;	} else {				*f_g = abe->muted_gains_decibel[mixer_offset + p];	}	return 0;}EXPORT_SYMBOL(abe_read_gain);int abe_read_mixer(u32 id, u32 *f_g, u32 p){	_log(id_read_mixer, id, 0, p);	abe_read_gain(id, f_g, p);	return 0;}EXPORT_SYMBOL(abe_read_mixer);int abe_mono_mixer(u32 id, u32 on_off){#define ABE_TASK_ID(ID) (D_tasksList_ADDR + sizeof(ABE_STask)*(ID))#define TASK_DL2Mixer_SLT 1#define TASK_DL2Mixer_IDX 6#define TASK_DL1Mixer_SLT 2#define TASK_DL1Mixer_IDX 0	switch (id) {	case MIXDL1:		if (on_off)			abe->MultiFrame[TASK_DL1Mixer_SLT][TASK_DL1Mixer_IDX] =				ABE_TASK_ID(C_ABE_FW_TASK_DL1Mixer_dual_mono);		else			abe->MultiFrame[TASK_DL1Mixer_SLT][TASK_DL1Mixer_IDX] =				ABE_TASK_ID(C_ABE_FW_TASK_DL1Mixer);		break;	case MIXDL2:		if (on_off)			abe->MultiFrame[TASK_DL2Mixer_SLT][TASK_DL2Mixer_IDX] =				ABE_TASK_ID(C_ABE_FW_TASK_DL2Mixer_dual_mono);		else			abe->MultiFrame[TASK_DL2Mixer_SLT][TASK_DL2Mixer_IDX] =				ABE_TASK_ID(C_ABE_FW_TASK_DL2Mixer);		break;	default:		break;	}	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM, D_multiFrame_ADDR,				(u32 *) abe->MultiFrame, sizeof(abe->MultiFrame));	return 0;}EXPORT_SYMBOL(abe_mono_mixer);int abe_set_router_configuration(u32 id, u32 k, u32 *param){	_log(id_set_router_configuration, id, (u32) param, (u32) param >> 8);	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM,			       D_aUplinkRouting_ADDR,			       param, D_aUplinkRouting_sizeof);	return 0;}EXPORT_SYMBOL(abe_set_router_configuration);int abe_read_debug_trace(u32 *data, u32 *n){	_log(id_select_data_source, 0, 0, 0);	return 0;}EXPORT_SYMBOL(abe_read_debug_trace);int abe_connect_debug_trace(abe_dma_t *dma2){	_log(id_connect_debug_trace, 0, 0, 0);		(*dma2).data = (void *)(D_DEBUG_FIFO_ADDR +		ABE_DEFAULT_BASE_ADDRESS_L3 + ABE_DMEM_BASE_OFFSET_MPU);	(*dma2).l3_dmem = (void *)(D_DEBUG_FIFO_ADDR +		ABE_DEFAULT_BASE_ADDRESS_L3 + ABE_DMEM_BASE_OFFSET_MPU);	(*dma2).l4_dmem = (void *)(D_DEBUG_FIFO_ADDR +		ABE_DEFAULT_BASE_ADDRESS_L4 + ABE_DMEM_BASE_OFFSET_MPU);	(*dma2).iter = (D_DEBUG_FIFO_sizeof + D_DEBUG_FIFO_HAL_sizeof)>>2;	return 0;}EXPORT_SYMBOL(abe_connect_debug_trace);int abe_set_debug_trace(abe_dbg_t debug){	_log(id_set_debug_trace, 0, 0, 0);	abe->dbg_mask = debug;	return 0;}EXPORT_SYMBOL(abe_set_debug_trace);int abe_remote_debugger_interface(u32 n, u8 *p){	_log(id_remote_debugger_interface, n, 0, 0);	return 0;}EXPORT_SYMBOL(abe_remote_debugger_interface);int abe_enable_test_pattern(u32 smem_id, u32 on_off){	u16 dbg_on, dbg_off, idx_patch, task_patch, addr_patch;	u32 patch, task32;	_log(id_enable_test_pattern, on_off, smem_id, smem_id >> 8);	switch (smem_id) {	case DBG_PATCH_AMIC:		dbg_on = DBG_48K_PATTERN_labelID;		dbg_off = AMIC_labelID;		task_patch = C_ABE_FW_TASK_AMIC_SPLIT;		idx_patch = 1;		break;	case DBG_PATCH_DMIC1:		dbg_on = DBG_48K_PATTERN_labelID;		dbg_off = DMIC1_labelID;		task_patch = C_ABE_FW_TASK_DMIC1_SPLIT;		idx_patch = 1;		break;	case DBG_PATCH_DMIC2:		dbg_on = DBG_48K_PATTERN_labelID;		dbg_off = DMIC2_labelID;		task_patch = C_ABE_FW_TASK_DMIC2_SPLIT;		idx_patch = 1;		break;	case DBG_PATCH_DMIC3:		dbg_on = DBG_48K_PATTERN_labelID;		dbg_off = DMIC3_labelID;		task_patch = C_ABE_FW_TASK_DMIC3_SPLIT;		idx_patch = 1;		break;	case DBG_PATCH_VX_REC:		dbg_on = DBG_48K_PATTERN_labelID;		dbg_off = VX_REC_labelID;		task_patch = C_ABE_FW_TASK_VXREC_SPLIT;		idx_patch = 1;		break;	case DBG_PATCH_BT_UL:		dbg_on = DBG_48K_PATTERN_labelID;		dbg_off = BT_UL_labelID;		task_patch = C_ABE_FW_TASK_BT_UL_SPLIT;		idx_patch = 1;		break;	case DBG_PATCH_MM_DL:		dbg_on = DBG_48K_PATTERN_labelID;		dbg_off = MM_DL_labelID;		task_patch = C_ABE_FW_TASK_MM_SPLIT;		idx_patch = 1;		break;	case DBG_PATCH_DL2_EQ:		dbg_on = DBG_48K_PATTERN_labelID;		dbg_off = DL2_EQ_labelID;		task_patch = C_ABE_FW_TASK_DL2_APS_SPLIT;		idx_patch = 1;		break;	case DBG_PATCH_VIBRA:		dbg_on = DBG_48K_PATTERN_labelID;		dbg_off = VIBRA_labelID;		task_patch = C_ABE_FW_TASK_VIBRA_SPLIT;		idx_patch = 1;		break;	case DBG_PATCH_MM_EXT_IN:		dbg_on = DBG_48K_PATTERN_labelID;		dbg_off = MM_EXT_IN_labelID;		task_patch = C_ABE_FW_TASK_MM_EXT_IN_SPLIT;		idx_patch = 1;		break;	case DBG_PATCH_MIC4:		dbg_on = DBG_48K_PATTERN_labelID;		dbg_off = MIC4_labelID;		task_patch = C_ABE_FW_TASK_MIC4_SPLIT;		idx_patch = 1;		break;	case DBG_PATCH_MM_DL_MIXDL1:		dbg_on = DBG_48K_PATTERN_labelID;		dbg_off = AMIC_labelID;		task_patch = C_ABE_FW_TASK_DL1Mixer;		idx_patch = 1;		break;	case DBG_PATCH_MM_DL_MIXDL2:		dbg_on = DBG_48K_PATTERN_labelID;		dbg_off = AMIC_labelID;		task_patch = C_ABE_FW_TASK_DL2Mixer;		idx_patch = 1;		break;	default:		return 0;	}	patch = (on_off != 0) ? dbg_on : dbg_off;		addr_patch = D_tasksList_ADDR + (16 * task_patch) + (2 * idx_patch);		abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM, addr_patch & (~0x03),		       &task32, 4);	if (addr_patch & 0x03)		task32 = (0x0000FFFFL & task32) | (patch << 16);	else		task32 = (0xFFFF0000L & task32) | (0x0000FFFF & patch);	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM, addr_patch & (~0x03),		       &task32, 4);	return 0;}EXPORT_SYMBOL(abe_enable_test_pattern);int abe_wakeup(void){		abe_write_event_generator(EVENT_TIMER);		abe_hw_configuration();	return 0;}EXPORT_SYMBOL(abe_wakeup);int abe_check_activity(void){	u32 i, ret = 0;	for (i = 0; i < (LAST_PORT_ID - 1); i++) {		if (abe_port[abe_port_priority[i]].status ==		    OMAP_ABE_PORT_ACTIVITY_RUNNING)			break;	}	if (i < (LAST_PORT_ID - 1))		ret = 1;	return ret;}EXPORT_SYMBOL(abe_check_activity);int abe_init_mem(void __iomem *_io_base){	abe = kzalloc(sizeof(struct omap_abe), GFP_KERNEL);	if (abe == NULL)		return -ENOMEM;	abe->io_base = _io_base;	mutex_init(&abe->mutex);	return 0;}EXPORT_SYMBOL(abe_init_mem);